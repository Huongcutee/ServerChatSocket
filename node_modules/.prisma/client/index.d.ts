
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model TwoFactorToken
 * 
 */
export type TwoFactorToken = $Result.DefaultSelection<Prisma.$TwoFactorTokenPayload>
/**
 * Model TwoFactorConfirmation
 * 
 */
export type TwoFactorConfirmation = $Result.DefaultSelection<Prisma.$TwoFactorConfirmationPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model SchoolScholarship
 * 
 */
export type SchoolScholarship = $Result.DefaultSelection<Prisma.$SchoolScholarshipPayload>
/**
 * Model SchoolScholarshipImage
 * 
 */
export type SchoolScholarshipImage = $Result.DefaultSelection<Prisma.$SchoolScholarshipImagePayload>
/**
 * Model StudentSchoolScholarship
 * 
 */
export type StudentSchoolScholarship = $Result.DefaultSelection<Prisma.$StudentSchoolScholarshipPayload>
/**
 * Model SchoolGallery
 * 
 */
export type SchoolGallery = $Result.DefaultSelection<Prisma.$SchoolGalleryPayload>
/**
 * Model SchoolGalleryImage
 * 
 */
export type SchoolGalleryImage = $Result.DefaultSelection<Prisma.$SchoolGalleryImagePayload>
/**
 * Model SchoolLocation
 * 
 */
export type SchoolLocation = $Result.DefaultSelection<Prisma.$SchoolLocationPayload>
/**
 * Model SchoolLocationImage
 * 
 */
export type SchoolLocationImage = $Result.DefaultSelection<Prisma.$SchoolLocationImagePayload>
/**
 * Model SchoolLocationContact
 * 
 */
export type SchoolLocationContact = $Result.DefaultSelection<Prisma.$SchoolLocationContactPayload>
/**
 * Model SchoolProgram
 * 
 */
export type SchoolProgram = $Result.DefaultSelection<Prisma.$SchoolProgramPayload>
/**
 * Model SchoolProgramImage
 * 
 */
export type SchoolProgramImage = $Result.DefaultSelection<Prisma.$SchoolProgramImagePayload>
/**
 * Model StudentSchoolProgram
 * 
 */
export type StudentSchoolProgram = $Result.DefaultSelection<Prisma.$StudentSchoolProgramPayload>
/**
 * Model StudentSchoolLocation
 * 
 */
export type StudentSchoolLocation = $Result.DefaultSelection<Prisma.$StudentSchoolLocationPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventProfile
 * 
 */
export type EventProfile = $Result.DefaultSelection<Prisma.$EventProfilePayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model ProfileFriend
 * 
 */
export type ProfileFriend = $Result.DefaultSelection<Prisma.$ProfileFriendPayload>
/**
 * Model Area
 * 
 */
export type Area = $Result.DefaultSelection<Prisma.$AreaPayload>
/**
 * Model ProfileBiography
 * 
 */
export type ProfileBiography = $Result.DefaultSelection<Prisma.$ProfileBiographyPayload>
/**
 * Model ProfileBiographyArea
 * 
 */
export type ProfileBiographyArea = $Result.DefaultSelection<Prisma.$ProfileBiographyAreaPayload>
/**
 * Model ProfileBiographySocial
 * 
 */
export type ProfileBiographySocial = $Result.DefaultSelection<Prisma.$ProfileBiographySocialPayload>
/**
 * Model ProfileBlog
 * 
 */
export type ProfileBlog = $Result.DefaultSelection<Prisma.$ProfileBlogPayload>
/**
 * Model ProfileBlogImage
 * 
 */
export type ProfileBlogImage = $Result.DefaultSelection<Prisma.$ProfileBlogImagePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model PostImage
 * 
 */
export type PostImage = $Result.DefaultSelection<Prisma.$PostImagePayload>
/**
 * Model PostLike
 * 
 */
export type PostLike = $Result.DefaultSelection<Prisma.$PostLikePayload>
/**
 * Model PostShare
 * 
 */
export type PostShare = $Result.DefaultSelection<Prisma.$PostSharePayload>
/**
 * Model PostSave
 * 
 */
export type PostSave = $Result.DefaultSelection<Prisma.$PostSavePayload>
/**
 * Model PostComment
 * 
 */
export type PostComment = $Result.DefaultSelection<Prisma.$PostCommentPayload>
/**
 * Model PostCommentLike
 * 
 */
export type PostCommentLike = $Result.DefaultSelection<Prisma.$PostCommentLikePayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model ProfileGroup
 * 
 */
export type ProfileGroup = $Result.DefaultSelection<Prisma.$ProfileGroupPayload>
/**
 * Model News
 * 
 */
export type News = $Result.DefaultSelection<Prisma.$NewsPayload>
/**
 * Model NewsNotification
 * 
 */
export type NewsNotification = $Result.DefaultSelection<Prisma.$NewsNotificationPayload>
/**
 * Model StudentFollow
 * 
 */
export type StudentFollow = $Result.DefaultSelection<Prisma.$StudentFollowPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Country: {
  AUSTRALIA: 'AUSTRALIA',
  KOREA: 'KOREA',
  CANADA: 'CANADA'
};

export type Country = (typeof Country)[keyof typeof Country]


export const DegreeType: {
  HIGHSCHOOL: 'HIGHSCHOOL',
  UNIVERSITY: 'UNIVERSITY'
};

export type DegreeType = (typeof DegreeType)[keyof typeof DegreeType]


export const CertificateType: {
  IELTS: 'IELTS',
  TOEFL: 'TOEFL'
};

export type CertificateType = (typeof CertificateType)[keyof typeof CertificateType]


export const GradeType: {
  GPA: 'GPA',
  CGPA: 'CGPA'
};

export type GradeType = (typeof GradeType)[keyof typeof GradeType]


export const StudentStatus: {
  STUDYING: 'STUDYING',
  DROPPED: 'DROPPED',
  AWAITING: 'AWAITING',
  APPROVED: 'APPROVED'
};

export type StudentStatus = (typeof StudentStatus)[keyof typeof StudentStatus]


export const ProfileStatus: {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  IDLE: 'IDLE',
  BUSY: 'BUSY',
  INVISIBLE: 'INVISIBLE'
};

export type ProfileStatus = (typeof ProfileStatus)[keyof typeof ProfileStatus]


export const SocialType: {
  YOUTUBE: 'YOUTUBE',
  FACEBOOK: 'FACEBOOK',
  INSTAGRAM: 'INSTAGRAM',
  TIKTOK: 'TIKTOK',
  TWITCH: 'TWITCH',
  TWITTER: 'TWITTER',
  PORTFOLLIO: 'PORTFOLLIO'
};

export type SocialType = (typeof SocialType)[keyof typeof SocialType]


export const PostStatus: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  FRIENDS: 'FRIENDS',
  EXCEPT: 'EXCEPT'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const NewsType: {
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  EVENT: 'EVENT',
  BLOG: 'BLOG'
};

export type NewsType = (typeof NewsType)[keyof typeof NewsType]


export const ContactTitle: {
  FEEDBACK: 'FEEDBACK',
  SYSTEM: 'SYSTEM',
  REFUND: 'REFUND',
  BILLING: 'BILLING',
  SUBSCRIPTION: 'SUBSCRIPTION',
  SCHOLARSHIP: 'SCHOLARSHIP',
  PROCEDURE: 'PROCEDURE'
};

export type ContactTitle = (typeof ContactTitle)[keyof typeof ContactTitle]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type Country = $Enums.Country

export const Country: typeof $Enums.Country

export type DegreeType = $Enums.DegreeType

export const DegreeType: typeof $Enums.DegreeType

export type CertificateType = $Enums.CertificateType

export const CertificateType: typeof $Enums.CertificateType

export type GradeType = $Enums.GradeType

export const GradeType: typeof $Enums.GradeType

export type StudentStatus = $Enums.StudentStatus

export const StudentStatus: typeof $Enums.StudentStatus

export type ProfileStatus = $Enums.ProfileStatus

export const ProfileStatus: typeof $Enums.ProfileStatus

export type SocialType = $Enums.SocialType

export const SocialType: typeof $Enums.SocialType

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type NewsType = $Enums.NewsType

export const NewsType: typeof $Enums.NewsType

export type ContactTitle = $Enums.ContactTitle

export const ContactTitle: typeof $Enums.ContactTitle

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.twoFactorToken`: Exposes CRUD operations for the **TwoFactorToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorTokens
    * const twoFactorTokens = await prisma.twoFactorToken.findMany()
    * ```
    */
  get twoFactorToken(): Prisma.TwoFactorTokenDelegate<ExtArgs>;

  /**
   * `prisma.twoFactorConfirmation`: Exposes CRUD operations for the **TwoFactorConfirmation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorConfirmations
    * const twoFactorConfirmations = await prisma.twoFactorConfirmation.findMany()
    * ```
    */
  get twoFactorConfirmation(): Prisma.TwoFactorConfirmationDelegate<ExtArgs>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs>;

  /**
   * `prisma.schoolScholarship`: Exposes CRUD operations for the **SchoolScholarship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolScholarships
    * const schoolScholarships = await prisma.schoolScholarship.findMany()
    * ```
    */
  get schoolScholarship(): Prisma.SchoolScholarshipDelegate<ExtArgs>;

  /**
   * `prisma.schoolScholarshipImage`: Exposes CRUD operations for the **SchoolScholarshipImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolScholarshipImages
    * const schoolScholarshipImages = await prisma.schoolScholarshipImage.findMany()
    * ```
    */
  get schoolScholarshipImage(): Prisma.SchoolScholarshipImageDelegate<ExtArgs>;

  /**
   * `prisma.studentSchoolScholarship`: Exposes CRUD operations for the **StudentSchoolScholarship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSchoolScholarships
    * const studentSchoolScholarships = await prisma.studentSchoolScholarship.findMany()
    * ```
    */
  get studentSchoolScholarship(): Prisma.StudentSchoolScholarshipDelegate<ExtArgs>;

  /**
   * `prisma.schoolGallery`: Exposes CRUD operations for the **SchoolGallery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolGalleries
    * const schoolGalleries = await prisma.schoolGallery.findMany()
    * ```
    */
  get schoolGallery(): Prisma.SchoolGalleryDelegate<ExtArgs>;

  /**
   * `prisma.schoolGalleryImage`: Exposes CRUD operations for the **SchoolGalleryImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolGalleryImages
    * const schoolGalleryImages = await prisma.schoolGalleryImage.findMany()
    * ```
    */
  get schoolGalleryImage(): Prisma.SchoolGalleryImageDelegate<ExtArgs>;

  /**
   * `prisma.schoolLocation`: Exposes CRUD operations for the **SchoolLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolLocations
    * const schoolLocations = await prisma.schoolLocation.findMany()
    * ```
    */
  get schoolLocation(): Prisma.SchoolLocationDelegate<ExtArgs>;

  /**
   * `prisma.schoolLocationImage`: Exposes CRUD operations for the **SchoolLocationImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolLocationImages
    * const schoolLocationImages = await prisma.schoolLocationImage.findMany()
    * ```
    */
  get schoolLocationImage(): Prisma.SchoolLocationImageDelegate<ExtArgs>;

  /**
   * `prisma.schoolLocationContact`: Exposes CRUD operations for the **SchoolLocationContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolLocationContacts
    * const schoolLocationContacts = await prisma.schoolLocationContact.findMany()
    * ```
    */
  get schoolLocationContact(): Prisma.SchoolLocationContactDelegate<ExtArgs>;

  /**
   * `prisma.schoolProgram`: Exposes CRUD operations for the **SchoolProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolPrograms
    * const schoolPrograms = await prisma.schoolProgram.findMany()
    * ```
    */
  get schoolProgram(): Prisma.SchoolProgramDelegate<ExtArgs>;

  /**
   * `prisma.schoolProgramImage`: Exposes CRUD operations for the **SchoolProgramImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolProgramImages
    * const schoolProgramImages = await prisma.schoolProgramImage.findMany()
    * ```
    */
  get schoolProgramImage(): Prisma.SchoolProgramImageDelegate<ExtArgs>;

  /**
   * `prisma.studentSchoolProgram`: Exposes CRUD operations for the **StudentSchoolProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSchoolPrograms
    * const studentSchoolPrograms = await prisma.studentSchoolProgram.findMany()
    * ```
    */
  get studentSchoolProgram(): Prisma.StudentSchoolProgramDelegate<ExtArgs>;

  /**
   * `prisma.studentSchoolLocation`: Exposes CRUD operations for the **StudentSchoolLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSchoolLocations
    * const studentSchoolLocations = await prisma.studentSchoolLocation.findMany()
    * ```
    */
  get studentSchoolLocation(): Prisma.StudentSchoolLocationDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.eventProfile`: Exposes CRUD operations for the **EventProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventProfiles
    * const eventProfiles = await prisma.eventProfile.findMany()
    * ```
    */
  get eventProfile(): Prisma.EventProfileDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.profileFriend`: Exposes CRUD operations for the **ProfileFriend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileFriends
    * const profileFriends = await prisma.profileFriend.findMany()
    * ```
    */
  get profileFriend(): Prisma.ProfileFriendDelegate<ExtArgs>;

  /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<ExtArgs>;

  /**
   * `prisma.profileBiography`: Exposes CRUD operations for the **ProfileBiography** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileBiographies
    * const profileBiographies = await prisma.profileBiography.findMany()
    * ```
    */
  get profileBiography(): Prisma.ProfileBiographyDelegate<ExtArgs>;

  /**
   * `prisma.profileBiographyArea`: Exposes CRUD operations for the **ProfileBiographyArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileBiographyAreas
    * const profileBiographyAreas = await prisma.profileBiographyArea.findMany()
    * ```
    */
  get profileBiographyArea(): Prisma.ProfileBiographyAreaDelegate<ExtArgs>;

  /**
   * `prisma.profileBiographySocial`: Exposes CRUD operations for the **ProfileBiographySocial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileBiographySocials
    * const profileBiographySocials = await prisma.profileBiographySocial.findMany()
    * ```
    */
  get profileBiographySocial(): Prisma.ProfileBiographySocialDelegate<ExtArgs>;

  /**
   * `prisma.profileBlog`: Exposes CRUD operations for the **ProfileBlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileBlogs
    * const profileBlogs = await prisma.profileBlog.findMany()
    * ```
    */
  get profileBlog(): Prisma.ProfileBlogDelegate<ExtArgs>;

  /**
   * `prisma.profileBlogImage`: Exposes CRUD operations for the **ProfileBlogImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileBlogImages
    * const profileBlogImages = await prisma.profileBlogImage.findMany()
    * ```
    */
  get profileBlogImage(): Prisma.ProfileBlogImageDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.postImage`: Exposes CRUD operations for the **PostImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostImages
    * const postImages = await prisma.postImage.findMany()
    * ```
    */
  get postImage(): Prisma.PostImageDelegate<ExtArgs>;

  /**
   * `prisma.postLike`: Exposes CRUD operations for the **PostLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostLikes
    * const postLikes = await prisma.postLike.findMany()
    * ```
    */
  get postLike(): Prisma.PostLikeDelegate<ExtArgs>;

  /**
   * `prisma.postShare`: Exposes CRUD operations for the **PostShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostShares
    * const postShares = await prisma.postShare.findMany()
    * ```
    */
  get postShare(): Prisma.PostShareDelegate<ExtArgs>;

  /**
   * `prisma.postSave`: Exposes CRUD operations for the **PostSave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostSaves
    * const postSaves = await prisma.postSave.findMany()
    * ```
    */
  get postSave(): Prisma.PostSaveDelegate<ExtArgs>;

  /**
   * `prisma.postComment`: Exposes CRUD operations for the **PostComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostComments
    * const postComments = await prisma.postComment.findMany()
    * ```
    */
  get postComment(): Prisma.PostCommentDelegate<ExtArgs>;

  /**
   * `prisma.postCommentLike`: Exposes CRUD operations for the **PostCommentLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostCommentLikes
    * const postCommentLikes = await prisma.postCommentLike.findMany()
    * ```
    */
  get postCommentLike(): Prisma.PostCommentLikeDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs>;

  /**
   * `prisma.profileGroup`: Exposes CRUD operations for the **ProfileGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileGroups
    * const profileGroups = await prisma.profileGroup.findMany()
    * ```
    */
  get profileGroup(): Prisma.ProfileGroupDelegate<ExtArgs>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<ExtArgs>;

  /**
   * `prisma.newsNotification`: Exposes CRUD operations for the **NewsNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsNotifications
    * const newsNotifications = await prisma.newsNotification.findMany()
    * ```
    */
  get newsNotification(): Prisma.NewsNotificationDelegate<ExtArgs>;

  /**
   * `prisma.studentFollow`: Exposes CRUD operations for the **StudentFollow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentFollows
    * const studentFollows = await prisma.studentFollow.findMany()
    * ```
    */
  get studentFollow(): Prisma.StudentFollowDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.16.0
   * Query Engine version: 34ace0eb2704183d2c05b60b52fba5c43c13f303
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    VerificationToken: 'VerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    TwoFactorToken: 'TwoFactorToken',
    TwoFactorConfirmation: 'TwoFactorConfirmation',
    School: 'School',
    SchoolScholarship: 'SchoolScholarship',
    SchoolScholarshipImage: 'SchoolScholarshipImage',
    StudentSchoolScholarship: 'StudentSchoolScholarship',
    SchoolGallery: 'SchoolGallery',
    SchoolGalleryImage: 'SchoolGalleryImage',
    SchoolLocation: 'SchoolLocation',
    SchoolLocationImage: 'SchoolLocationImage',
    SchoolLocationContact: 'SchoolLocationContact',
    SchoolProgram: 'SchoolProgram',
    SchoolProgramImage: 'SchoolProgramImage',
    StudentSchoolProgram: 'StudentSchoolProgram',
    StudentSchoolLocation: 'StudentSchoolLocation',
    Student: 'Student',
    Chat: 'Chat',
    Message: 'Message',
    Event: 'Event',
    EventProfile: 'EventProfile',
    Profile: 'Profile',
    ProfileFriend: 'ProfileFriend',
    Area: 'Area',
    ProfileBiography: 'ProfileBiography',
    ProfileBiographyArea: 'ProfileBiographyArea',
    ProfileBiographySocial: 'ProfileBiographySocial',
    ProfileBlog: 'ProfileBlog',
    ProfileBlogImage: 'ProfileBlogImage',
    Post: 'Post',
    PostImage: 'PostImage',
    PostLike: 'PostLike',
    PostShare: 'PostShare',
    PostSave: 'PostSave',
    PostComment: 'PostComment',
    PostCommentLike: 'PostCommentLike',
    Group: 'Group',
    ProfileGroup: 'ProfileGroup',
    News: 'News',
    NewsNotification: 'NewsNotification',
    StudentFollow: 'StudentFollow',
    Contact: 'Contact'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "account" | "verificationToken" | "passwordResetToken" | "twoFactorToken" | "twoFactorConfirmation" | "school" | "schoolScholarship" | "schoolScholarshipImage" | "studentSchoolScholarship" | "schoolGallery" | "schoolGalleryImage" | "schoolLocation" | "schoolLocationImage" | "schoolLocationContact" | "schoolProgram" | "schoolProgramImage" | "studentSchoolProgram" | "studentSchoolLocation" | "student" | "chat" | "message" | "event" | "eventProfile" | "profile" | "profileFriend" | "area" | "profileBiography" | "profileBiographyArea" | "profileBiographySocial" | "profileBlog" | "profileBlogImage" | "post" | "postImage" | "postLike" | "postShare" | "postSave" | "postComment" | "postCommentLike" | "group" | "profileGroup" | "news" | "newsNotification" | "studentFollow" | "contact"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorToken: {
        payload: Prisma.$TwoFactorTokenPayload<ExtArgs>
        fields: Prisma.TwoFactorTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          findMany: {
            args: Prisma.TwoFactorTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>[]
          }
          create: {
            args: Prisma.TwoFactorTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          createMany: {
            args: Prisma.TwoFactorTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwoFactorTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>[]
          }
          delete: {
            args: Prisma.TwoFactorTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          update: {
            args: Prisma.TwoFactorTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactorToken>
          }
          groupBy: {
            args: Prisma.TwoFactorTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorTokenCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorTokenCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorConfirmation: {
        payload: Prisma.$TwoFactorConfirmationPayload<ExtArgs>
        fields: Prisma.TwoFactorConfirmationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorConfirmationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorConfirmationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorConfirmationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorConfirmationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          findMany: {
            args: Prisma.TwoFactorConfirmationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>[]
          }
          create: {
            args: Prisma.TwoFactorConfirmationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          createMany: {
            args: Prisma.TwoFactorConfirmationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwoFactorConfirmationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>[]
          }
          delete: {
            args: Prisma.TwoFactorConfirmationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          update: {
            args: Prisma.TwoFactorConfirmationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorConfirmationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorConfirmationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorConfirmationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorConfirmationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactorConfirmation>
          }
          groupBy: {
            args: Prisma.TwoFactorConfirmationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorConfirmationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorConfirmationCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorConfirmationCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      SchoolScholarship: {
        payload: Prisma.$SchoolScholarshipPayload<ExtArgs>
        fields: Prisma.SchoolScholarshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolScholarshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolScholarshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload>
          }
          findFirst: {
            args: Prisma.SchoolScholarshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolScholarshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload>
          }
          findMany: {
            args: Prisma.SchoolScholarshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload>[]
          }
          create: {
            args: Prisma.SchoolScholarshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload>
          }
          createMany: {
            args: Prisma.SchoolScholarshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolScholarshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload>[]
          }
          delete: {
            args: Prisma.SchoolScholarshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload>
          }
          update: {
            args: Prisma.SchoolScholarshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload>
          }
          deleteMany: {
            args: Prisma.SchoolScholarshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolScholarshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolScholarshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipPayload>
          }
          aggregate: {
            args: Prisma.SchoolScholarshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolScholarship>
          }
          groupBy: {
            args: Prisma.SchoolScholarshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolScholarshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolScholarshipCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolScholarshipCountAggregateOutputType> | number
          }
        }
      }
      SchoolScholarshipImage: {
        payload: Prisma.$SchoolScholarshipImagePayload<ExtArgs>
        fields: Prisma.SchoolScholarshipImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolScholarshipImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolScholarshipImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload>
          }
          findFirst: {
            args: Prisma.SchoolScholarshipImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolScholarshipImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload>
          }
          findMany: {
            args: Prisma.SchoolScholarshipImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload>[]
          }
          create: {
            args: Prisma.SchoolScholarshipImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload>
          }
          createMany: {
            args: Prisma.SchoolScholarshipImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolScholarshipImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload>[]
          }
          delete: {
            args: Prisma.SchoolScholarshipImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload>
          }
          update: {
            args: Prisma.SchoolScholarshipImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload>
          }
          deleteMany: {
            args: Prisma.SchoolScholarshipImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolScholarshipImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolScholarshipImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolScholarshipImagePayload>
          }
          aggregate: {
            args: Prisma.SchoolScholarshipImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolScholarshipImage>
          }
          groupBy: {
            args: Prisma.SchoolScholarshipImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolScholarshipImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolScholarshipImageCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolScholarshipImageCountAggregateOutputType> | number
          }
        }
      }
      StudentSchoolScholarship: {
        payload: Prisma.$StudentSchoolScholarshipPayload<ExtArgs>
        fields: Prisma.StudentSchoolScholarshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSchoolScholarshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSchoolScholarshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload>
          }
          findFirst: {
            args: Prisma.StudentSchoolScholarshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSchoolScholarshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload>
          }
          findMany: {
            args: Prisma.StudentSchoolScholarshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload>[]
          }
          create: {
            args: Prisma.StudentSchoolScholarshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload>
          }
          createMany: {
            args: Prisma.StudentSchoolScholarshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentSchoolScholarshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload>[]
          }
          delete: {
            args: Prisma.StudentSchoolScholarshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload>
          }
          update: {
            args: Prisma.StudentSchoolScholarshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload>
          }
          deleteMany: {
            args: Prisma.StudentSchoolScholarshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSchoolScholarshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSchoolScholarshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolScholarshipPayload>
          }
          aggregate: {
            args: Prisma.StudentSchoolScholarshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSchoolScholarship>
          }
          groupBy: {
            args: Prisma.StudentSchoolScholarshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSchoolScholarshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSchoolScholarshipCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSchoolScholarshipCountAggregateOutputType> | number
          }
        }
      }
      SchoolGallery: {
        payload: Prisma.$SchoolGalleryPayload<ExtArgs>
        fields: Prisma.SchoolGalleryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolGalleryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolGalleryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload>
          }
          findFirst: {
            args: Prisma.SchoolGalleryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolGalleryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload>
          }
          findMany: {
            args: Prisma.SchoolGalleryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload>[]
          }
          create: {
            args: Prisma.SchoolGalleryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload>
          }
          createMany: {
            args: Prisma.SchoolGalleryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolGalleryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload>[]
          }
          delete: {
            args: Prisma.SchoolGalleryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload>
          }
          update: {
            args: Prisma.SchoolGalleryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload>
          }
          deleteMany: {
            args: Prisma.SchoolGalleryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolGalleryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolGalleryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryPayload>
          }
          aggregate: {
            args: Prisma.SchoolGalleryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolGallery>
          }
          groupBy: {
            args: Prisma.SchoolGalleryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGalleryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolGalleryCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolGalleryCountAggregateOutputType> | number
          }
        }
      }
      SchoolGalleryImage: {
        payload: Prisma.$SchoolGalleryImagePayload<ExtArgs>
        fields: Prisma.SchoolGalleryImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolGalleryImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolGalleryImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload>
          }
          findFirst: {
            args: Prisma.SchoolGalleryImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolGalleryImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload>
          }
          findMany: {
            args: Prisma.SchoolGalleryImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload>[]
          }
          create: {
            args: Prisma.SchoolGalleryImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload>
          }
          createMany: {
            args: Prisma.SchoolGalleryImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolGalleryImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload>[]
          }
          delete: {
            args: Prisma.SchoolGalleryImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload>
          }
          update: {
            args: Prisma.SchoolGalleryImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload>
          }
          deleteMany: {
            args: Prisma.SchoolGalleryImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolGalleryImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolGalleryImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolGalleryImagePayload>
          }
          aggregate: {
            args: Prisma.SchoolGalleryImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolGalleryImage>
          }
          groupBy: {
            args: Prisma.SchoolGalleryImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGalleryImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolGalleryImageCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolGalleryImageCountAggregateOutputType> | number
          }
        }
      }
      SchoolLocation: {
        payload: Prisma.$SchoolLocationPayload<ExtArgs>
        fields: Prisma.SchoolLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload>
          }
          findFirst: {
            args: Prisma.SchoolLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload>
          }
          findMany: {
            args: Prisma.SchoolLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload>[]
          }
          create: {
            args: Prisma.SchoolLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload>
          }
          createMany: {
            args: Prisma.SchoolLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload>[]
          }
          delete: {
            args: Prisma.SchoolLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload>
          }
          update: {
            args: Prisma.SchoolLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload>
          }
          deleteMany: {
            args: Prisma.SchoolLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationPayload>
          }
          aggregate: {
            args: Prisma.SchoolLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolLocation>
          }
          groupBy: {
            args: Prisma.SchoolLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolLocationCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolLocationCountAggregateOutputType> | number
          }
        }
      }
      SchoolLocationImage: {
        payload: Prisma.$SchoolLocationImagePayload<ExtArgs>
        fields: Prisma.SchoolLocationImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolLocationImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolLocationImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload>
          }
          findFirst: {
            args: Prisma.SchoolLocationImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolLocationImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload>
          }
          findMany: {
            args: Prisma.SchoolLocationImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload>[]
          }
          create: {
            args: Prisma.SchoolLocationImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload>
          }
          createMany: {
            args: Prisma.SchoolLocationImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolLocationImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload>[]
          }
          delete: {
            args: Prisma.SchoolLocationImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload>
          }
          update: {
            args: Prisma.SchoolLocationImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload>
          }
          deleteMany: {
            args: Prisma.SchoolLocationImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolLocationImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolLocationImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationImagePayload>
          }
          aggregate: {
            args: Prisma.SchoolLocationImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolLocationImage>
          }
          groupBy: {
            args: Prisma.SchoolLocationImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolLocationImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolLocationImageCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolLocationImageCountAggregateOutputType> | number
          }
        }
      }
      SchoolLocationContact: {
        payload: Prisma.$SchoolLocationContactPayload<ExtArgs>
        fields: Prisma.SchoolLocationContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolLocationContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolLocationContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload>
          }
          findFirst: {
            args: Prisma.SchoolLocationContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolLocationContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload>
          }
          findMany: {
            args: Prisma.SchoolLocationContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload>[]
          }
          create: {
            args: Prisma.SchoolLocationContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload>
          }
          createMany: {
            args: Prisma.SchoolLocationContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolLocationContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload>[]
          }
          delete: {
            args: Prisma.SchoolLocationContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload>
          }
          update: {
            args: Prisma.SchoolLocationContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload>
          }
          deleteMany: {
            args: Prisma.SchoolLocationContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolLocationContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolLocationContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolLocationContactPayload>
          }
          aggregate: {
            args: Prisma.SchoolLocationContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolLocationContact>
          }
          groupBy: {
            args: Prisma.SchoolLocationContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolLocationContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolLocationContactCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolLocationContactCountAggregateOutputType> | number
          }
        }
      }
      SchoolProgram: {
        payload: Prisma.$SchoolProgramPayload<ExtArgs>
        fields: Prisma.SchoolProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload>
          }
          findFirst: {
            args: Prisma.SchoolProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload>
          }
          findMany: {
            args: Prisma.SchoolProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload>[]
          }
          create: {
            args: Prisma.SchoolProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload>
          }
          createMany: {
            args: Prisma.SchoolProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload>[]
          }
          delete: {
            args: Prisma.SchoolProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload>
          }
          update: {
            args: Prisma.SchoolProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload>
          }
          deleteMany: {
            args: Prisma.SchoolProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramPayload>
          }
          aggregate: {
            args: Prisma.SchoolProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolProgram>
          }
          groupBy: {
            args: Prisma.SchoolProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolProgramCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolProgramCountAggregateOutputType> | number
          }
        }
      }
      SchoolProgramImage: {
        payload: Prisma.$SchoolProgramImagePayload<ExtArgs>
        fields: Prisma.SchoolProgramImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolProgramImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolProgramImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload>
          }
          findFirst: {
            args: Prisma.SchoolProgramImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolProgramImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload>
          }
          findMany: {
            args: Prisma.SchoolProgramImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload>[]
          }
          create: {
            args: Prisma.SchoolProgramImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload>
          }
          createMany: {
            args: Prisma.SchoolProgramImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolProgramImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload>[]
          }
          delete: {
            args: Prisma.SchoolProgramImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload>
          }
          update: {
            args: Prisma.SchoolProgramImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload>
          }
          deleteMany: {
            args: Prisma.SchoolProgramImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolProgramImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolProgramImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolProgramImagePayload>
          }
          aggregate: {
            args: Prisma.SchoolProgramImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolProgramImage>
          }
          groupBy: {
            args: Prisma.SchoolProgramImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolProgramImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolProgramImageCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolProgramImageCountAggregateOutputType> | number
          }
        }
      }
      StudentSchoolProgram: {
        payload: Prisma.$StudentSchoolProgramPayload<ExtArgs>
        fields: Prisma.StudentSchoolProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSchoolProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSchoolProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload>
          }
          findFirst: {
            args: Prisma.StudentSchoolProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSchoolProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload>
          }
          findMany: {
            args: Prisma.StudentSchoolProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload>[]
          }
          create: {
            args: Prisma.StudentSchoolProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload>
          }
          createMany: {
            args: Prisma.StudentSchoolProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentSchoolProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload>[]
          }
          delete: {
            args: Prisma.StudentSchoolProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload>
          }
          update: {
            args: Prisma.StudentSchoolProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload>
          }
          deleteMany: {
            args: Prisma.StudentSchoolProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSchoolProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSchoolProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolProgramPayload>
          }
          aggregate: {
            args: Prisma.StudentSchoolProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSchoolProgram>
          }
          groupBy: {
            args: Prisma.StudentSchoolProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSchoolProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSchoolProgramCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSchoolProgramCountAggregateOutputType> | number
          }
        }
      }
      StudentSchoolLocation: {
        payload: Prisma.$StudentSchoolLocationPayload<ExtArgs>
        fields: Prisma.StudentSchoolLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSchoolLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSchoolLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload>
          }
          findFirst: {
            args: Prisma.StudentSchoolLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSchoolLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload>
          }
          findMany: {
            args: Prisma.StudentSchoolLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload>[]
          }
          create: {
            args: Prisma.StudentSchoolLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload>
          }
          createMany: {
            args: Prisma.StudentSchoolLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentSchoolLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload>[]
          }
          delete: {
            args: Prisma.StudentSchoolLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload>
          }
          update: {
            args: Prisma.StudentSchoolLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload>
          }
          deleteMany: {
            args: Prisma.StudentSchoolLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSchoolLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSchoolLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSchoolLocationPayload>
          }
          aggregate: {
            args: Prisma.StudentSchoolLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSchoolLocation>
          }
          groupBy: {
            args: Prisma.StudentSchoolLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSchoolLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSchoolLocationCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSchoolLocationCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventProfile: {
        payload: Prisma.$EventProfilePayload<ExtArgs>
        fields: Prisma.EventProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload>
          }
          findFirst: {
            args: Prisma.EventProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload>
          }
          findMany: {
            args: Prisma.EventProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload>[]
          }
          create: {
            args: Prisma.EventProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload>
          }
          createMany: {
            args: Prisma.EventProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload>[]
          }
          delete: {
            args: Prisma.EventProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload>
          }
          update: {
            args: Prisma.EventProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload>
          }
          deleteMany: {
            args: Prisma.EventProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventProfilePayload>
          }
          aggregate: {
            args: Prisma.EventProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventProfile>
          }
          groupBy: {
            args: Prisma.EventProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventProfileCountArgs<ExtArgs>
            result: $Utils.Optional<EventProfileCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      ProfileFriend: {
        payload: Prisma.$ProfileFriendPayload<ExtArgs>
        fields: Prisma.ProfileFriendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFriendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFriendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload>
          }
          findFirst: {
            args: Prisma.ProfileFriendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFriendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload>
          }
          findMany: {
            args: Prisma.ProfileFriendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload>[]
          }
          create: {
            args: Prisma.ProfileFriendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload>
          }
          createMany: {
            args: Prisma.ProfileFriendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileFriendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload>[]
          }
          delete: {
            args: Prisma.ProfileFriendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload>
          }
          update: {
            args: Prisma.ProfileFriendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload>
          }
          deleteMany: {
            args: Prisma.ProfileFriendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileFriendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileFriendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileFriendPayload>
          }
          aggregate: {
            args: Prisma.ProfileFriendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileFriend>
          }
          groupBy: {
            args: Prisma.ProfileFriendGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileFriendGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileFriendCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileFriendCountAggregateOutputType> | number
          }
        }
      }
      Area: {
        payload: Prisma.$AreaPayload<ExtArgs>
        fields: Prisma.AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findFirst: {
            args: Prisma.AreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findMany: {
            args: Prisma.AreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          create: {
            args: Prisma.AreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          createMany: {
            args: Prisma.AreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          delete: {
            args: Prisma.AreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          update: {
            args: Prisma.AreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          deleteMany: {
            args: Prisma.AreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArea>
          }
          groupBy: {
            args: Prisma.AreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaCountArgs<ExtArgs>
            result: $Utils.Optional<AreaCountAggregateOutputType> | number
          }
        }
      }
      ProfileBiography: {
        payload: Prisma.$ProfileBiographyPayload<ExtArgs>
        fields: Prisma.ProfileBiographyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileBiographyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileBiographyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload>
          }
          findFirst: {
            args: Prisma.ProfileBiographyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileBiographyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload>
          }
          findMany: {
            args: Prisma.ProfileBiographyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload>[]
          }
          create: {
            args: Prisma.ProfileBiographyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload>
          }
          createMany: {
            args: Prisma.ProfileBiographyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileBiographyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload>[]
          }
          delete: {
            args: Prisma.ProfileBiographyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload>
          }
          update: {
            args: Prisma.ProfileBiographyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload>
          }
          deleteMany: {
            args: Prisma.ProfileBiographyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileBiographyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileBiographyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyPayload>
          }
          aggregate: {
            args: Prisma.ProfileBiographyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileBiography>
          }
          groupBy: {
            args: Prisma.ProfileBiographyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileBiographyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileBiographyCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileBiographyCountAggregateOutputType> | number
          }
        }
      }
      ProfileBiographyArea: {
        payload: Prisma.$ProfileBiographyAreaPayload<ExtArgs>
        fields: Prisma.ProfileBiographyAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileBiographyAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileBiographyAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload>
          }
          findFirst: {
            args: Prisma.ProfileBiographyAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileBiographyAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload>
          }
          findMany: {
            args: Prisma.ProfileBiographyAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload>[]
          }
          create: {
            args: Prisma.ProfileBiographyAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload>
          }
          createMany: {
            args: Prisma.ProfileBiographyAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileBiographyAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload>[]
          }
          delete: {
            args: Prisma.ProfileBiographyAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload>
          }
          update: {
            args: Prisma.ProfileBiographyAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload>
          }
          deleteMany: {
            args: Prisma.ProfileBiographyAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileBiographyAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileBiographyAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographyAreaPayload>
          }
          aggregate: {
            args: Prisma.ProfileBiographyAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileBiographyArea>
          }
          groupBy: {
            args: Prisma.ProfileBiographyAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileBiographyAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileBiographyAreaCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileBiographyAreaCountAggregateOutputType> | number
          }
        }
      }
      ProfileBiographySocial: {
        payload: Prisma.$ProfileBiographySocialPayload<ExtArgs>
        fields: Prisma.ProfileBiographySocialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileBiographySocialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileBiographySocialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload>
          }
          findFirst: {
            args: Prisma.ProfileBiographySocialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileBiographySocialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload>
          }
          findMany: {
            args: Prisma.ProfileBiographySocialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload>[]
          }
          create: {
            args: Prisma.ProfileBiographySocialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload>
          }
          createMany: {
            args: Prisma.ProfileBiographySocialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileBiographySocialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload>[]
          }
          delete: {
            args: Prisma.ProfileBiographySocialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload>
          }
          update: {
            args: Prisma.ProfileBiographySocialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload>
          }
          deleteMany: {
            args: Prisma.ProfileBiographySocialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileBiographySocialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileBiographySocialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBiographySocialPayload>
          }
          aggregate: {
            args: Prisma.ProfileBiographySocialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileBiographySocial>
          }
          groupBy: {
            args: Prisma.ProfileBiographySocialGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileBiographySocialGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileBiographySocialCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileBiographySocialCountAggregateOutputType> | number
          }
        }
      }
      ProfileBlog: {
        payload: Prisma.$ProfileBlogPayload<ExtArgs>
        fields: Prisma.ProfileBlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileBlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileBlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload>
          }
          findFirst: {
            args: Prisma.ProfileBlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileBlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload>
          }
          findMany: {
            args: Prisma.ProfileBlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload>[]
          }
          create: {
            args: Prisma.ProfileBlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload>
          }
          createMany: {
            args: Prisma.ProfileBlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileBlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload>[]
          }
          delete: {
            args: Prisma.ProfileBlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload>
          }
          update: {
            args: Prisma.ProfileBlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload>
          }
          deleteMany: {
            args: Prisma.ProfileBlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileBlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileBlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogPayload>
          }
          aggregate: {
            args: Prisma.ProfileBlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileBlog>
          }
          groupBy: {
            args: Prisma.ProfileBlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileBlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileBlogCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileBlogCountAggregateOutputType> | number
          }
        }
      }
      ProfileBlogImage: {
        payload: Prisma.$ProfileBlogImagePayload<ExtArgs>
        fields: Prisma.ProfileBlogImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileBlogImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileBlogImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload>
          }
          findFirst: {
            args: Prisma.ProfileBlogImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileBlogImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload>
          }
          findMany: {
            args: Prisma.ProfileBlogImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload>[]
          }
          create: {
            args: Prisma.ProfileBlogImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload>
          }
          createMany: {
            args: Prisma.ProfileBlogImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileBlogImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload>[]
          }
          delete: {
            args: Prisma.ProfileBlogImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload>
          }
          update: {
            args: Prisma.ProfileBlogImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload>
          }
          deleteMany: {
            args: Prisma.ProfileBlogImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileBlogImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileBlogImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileBlogImagePayload>
          }
          aggregate: {
            args: Prisma.ProfileBlogImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileBlogImage>
          }
          groupBy: {
            args: Prisma.ProfileBlogImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileBlogImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileBlogImageCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileBlogImageCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      PostImage: {
        payload: Prisma.$PostImagePayload<ExtArgs>
        fields: Prisma.PostImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          findFirst: {
            args: Prisma.PostImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          findMany: {
            args: Prisma.PostImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>[]
          }
          create: {
            args: Prisma.PostImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          createMany: {
            args: Prisma.PostImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>[]
          }
          delete: {
            args: Prisma.PostImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          update: {
            args: Prisma.PostImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          deleteMany: {
            args: Prisma.PostImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          aggregate: {
            args: Prisma.PostImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostImage>
          }
          groupBy: {
            args: Prisma.PostImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostImageCountArgs<ExtArgs>
            result: $Utils.Optional<PostImageCountAggregateOutputType> | number
          }
        }
      }
      PostLike: {
        payload: Prisma.$PostLikePayload<ExtArgs>
        fields: Prisma.PostLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          findFirst: {
            args: Prisma.PostLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          findMany: {
            args: Prisma.PostLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
          }
          create: {
            args: Prisma.PostLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          createMany: {
            args: Prisma.PostLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
          }
          delete: {
            args: Prisma.PostLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          update: {
            args: Prisma.PostLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          deleteMany: {
            args: Prisma.PostLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          aggregate: {
            args: Prisma.PostLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostLike>
          }
          groupBy: {
            args: Prisma.PostLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostLikeCountArgs<ExtArgs>
            result: $Utils.Optional<PostLikeCountAggregateOutputType> | number
          }
        }
      }
      PostShare: {
        payload: Prisma.$PostSharePayload<ExtArgs>
        fields: Prisma.PostShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload>
          }
          findFirst: {
            args: Prisma.PostShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload>
          }
          findMany: {
            args: Prisma.PostShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload>[]
          }
          create: {
            args: Prisma.PostShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload>
          }
          createMany: {
            args: Prisma.PostShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload>[]
          }
          delete: {
            args: Prisma.PostShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload>
          }
          update: {
            args: Prisma.PostShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload>
          }
          deleteMany: {
            args: Prisma.PostShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSharePayload>
          }
          aggregate: {
            args: Prisma.PostShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostShare>
          }
          groupBy: {
            args: Prisma.PostShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostShareCountArgs<ExtArgs>
            result: $Utils.Optional<PostShareCountAggregateOutputType> | number
          }
        }
      }
      PostSave: {
        payload: Prisma.$PostSavePayload<ExtArgs>
        fields: Prisma.PostSaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostSaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostSaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload>
          }
          findFirst: {
            args: Prisma.PostSaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostSaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload>
          }
          findMany: {
            args: Prisma.PostSaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload>[]
          }
          create: {
            args: Prisma.PostSaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload>
          }
          createMany: {
            args: Prisma.PostSaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostSaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload>[]
          }
          delete: {
            args: Prisma.PostSaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload>
          }
          update: {
            args: Prisma.PostSaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload>
          }
          deleteMany: {
            args: Prisma.PostSaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostSaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostSaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostSavePayload>
          }
          aggregate: {
            args: Prisma.PostSaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostSave>
          }
          groupBy: {
            args: Prisma.PostSaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostSaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostSaveCountArgs<ExtArgs>
            result: $Utils.Optional<PostSaveCountAggregateOutputType> | number
          }
        }
      }
      PostComment: {
        payload: Prisma.$PostCommentPayload<ExtArgs>
        fields: Prisma.PostCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
          }
          findFirst: {
            args: Prisma.PostCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
          }
          findMany: {
            args: Prisma.PostCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>[]
          }
          create: {
            args: Prisma.PostCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
          }
          createMany: {
            args: Prisma.PostCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>[]
          }
          delete: {
            args: Prisma.PostCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
          }
          update: {
            args: Prisma.PostCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
          }
          deleteMany: {
            args: Prisma.PostCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentPayload>
          }
          aggregate: {
            args: Prisma.PostCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostComment>
          }
          groupBy: {
            args: Prisma.PostCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCommentCountArgs<ExtArgs>
            result: $Utils.Optional<PostCommentCountAggregateOutputType> | number
          }
        }
      }
      PostCommentLike: {
        payload: Prisma.$PostCommentLikePayload<ExtArgs>
        fields: Prisma.PostCommentLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostCommentLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostCommentLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload>
          }
          findFirst: {
            args: Prisma.PostCommentLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostCommentLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload>
          }
          findMany: {
            args: Prisma.PostCommentLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload>[]
          }
          create: {
            args: Prisma.PostCommentLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload>
          }
          createMany: {
            args: Prisma.PostCommentLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCommentLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload>[]
          }
          delete: {
            args: Prisma.PostCommentLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload>
          }
          update: {
            args: Prisma.PostCommentLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload>
          }
          deleteMany: {
            args: Prisma.PostCommentLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostCommentLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostCommentLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostCommentLikePayload>
          }
          aggregate: {
            args: Prisma.PostCommentLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostCommentLike>
          }
          groupBy: {
            args: Prisma.PostCommentLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostCommentLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCommentLikeCountArgs<ExtArgs>
            result: $Utils.Optional<PostCommentLikeCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      ProfileGroup: {
        payload: Prisma.$ProfileGroupPayload<ExtArgs>
        fields: Prisma.ProfileGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload>
          }
          findFirst: {
            args: Prisma.ProfileGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload>
          }
          findMany: {
            args: Prisma.ProfileGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload>[]
          }
          create: {
            args: Prisma.ProfileGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload>
          }
          createMany: {
            args: Prisma.ProfileGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload>[]
          }
          delete: {
            args: Prisma.ProfileGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload>
          }
          update: {
            args: Prisma.ProfileGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload>
          }
          deleteMany: {
            args: Prisma.ProfileGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileGroupPayload>
          }
          aggregate: {
            args: Prisma.ProfileGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileGroup>
          }
          groupBy: {
            args: Prisma.ProfileGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileGroupCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupCountAggregateOutputType> | number
          }
        }
      }
      News: {
        payload: Prisma.$NewsPayload<ExtArgs>
        fields: Prisma.NewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findFirst: {
            args: Prisma.NewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findMany: {
            args: Prisma.NewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          create: {
            args: Prisma.NewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          createMany: {
            args: Prisma.NewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          delete: {
            args: Prisma.NewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          update: {
            args: Prisma.NewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          deleteMany: {
            args: Prisma.NewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.NewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsCountArgs<ExtArgs>
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      NewsNotification: {
        payload: Prisma.$NewsNotificationPayload<ExtArgs>
        fields: Prisma.NewsNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload>
          }
          findFirst: {
            args: Prisma.NewsNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload>
          }
          findMany: {
            args: Prisma.NewsNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload>[]
          }
          create: {
            args: Prisma.NewsNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload>
          }
          createMany: {
            args: Prisma.NewsNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload>[]
          }
          delete: {
            args: Prisma.NewsNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload>
          }
          update: {
            args: Prisma.NewsNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload>
          }
          deleteMany: {
            args: Prisma.NewsNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsNotificationPayload>
          }
          aggregate: {
            args: Prisma.NewsNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsNotification>
          }
          groupBy: {
            args: Prisma.NewsNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NewsNotificationCountAggregateOutputType> | number
          }
        }
      }
      StudentFollow: {
        payload: Prisma.$StudentFollowPayload<ExtArgs>
        fields: Prisma.StudentFollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload>
          }
          findFirst: {
            args: Prisma.StudentFollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload>
          }
          findMany: {
            args: Prisma.StudentFollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload>[]
          }
          create: {
            args: Prisma.StudentFollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload>
          }
          createMany: {
            args: Prisma.StudentFollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentFollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload>[]
          }
          delete: {
            args: Prisma.StudentFollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload>
          }
          update: {
            args: Prisma.StudentFollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload>
          }
          deleteMany: {
            args: Prisma.StudentFollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentFollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentFollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFollowPayload>
          }
          aggregate: {
            args: Prisma.StudentFollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentFollow>
          }
          groupBy: {
            args: Prisma.StudentFollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentFollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentFollowCountArgs<ExtArgs>
            result: $Utils.Optional<StudentFollowCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    students: number
    locations: number
    programs: number
    galleries: number
    scholarships: number
    news: number
    contacts: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | SchoolCountOutputTypeCountStudentsArgs
    locations?: boolean | SchoolCountOutputTypeCountLocationsArgs
    programs?: boolean | SchoolCountOutputTypeCountProgramsArgs
    galleries?: boolean | SchoolCountOutputTypeCountGalleriesArgs
    scholarships?: boolean | SchoolCountOutputTypeCountScholarshipsArgs
    news?: boolean | SchoolCountOutputTypeCountNewsArgs
    contacts?: boolean | SchoolCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolLocationWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolProgramWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountGalleriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolGalleryWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountScholarshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolScholarshipWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountNewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Count Type SchoolScholarshipCountOutputType
   */

  export type SchoolScholarshipCountOutputType = {
    owners: number
    images: number
  }

  export type SchoolScholarshipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owners?: boolean | SchoolScholarshipCountOutputTypeCountOwnersArgs
    images?: boolean | SchoolScholarshipCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * SchoolScholarshipCountOutputType without action
   */
  export type SchoolScholarshipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipCountOutputType
     */
    select?: SchoolScholarshipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolScholarshipCountOutputType without action
   */
  export type SchoolScholarshipCountOutputTypeCountOwnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSchoolScholarshipWhereInput
  }

  /**
   * SchoolScholarshipCountOutputType without action
   */
  export type SchoolScholarshipCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolScholarshipImageWhereInput
  }


  /**
   * Count Type SchoolGalleryCountOutputType
   */

  export type SchoolGalleryCountOutputType = {
    images: number
  }

  export type SchoolGalleryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | SchoolGalleryCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * SchoolGalleryCountOutputType without action
   */
  export type SchoolGalleryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryCountOutputType
     */
    select?: SchoolGalleryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolGalleryCountOutputType without action
   */
  export type SchoolGalleryCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolGalleryImageWhereInput
  }


  /**
   * Count Type SchoolLocationCountOutputType
   */

  export type SchoolLocationCountOutputType = {
    images: number
    contacts: number
    students: number
  }

  export type SchoolLocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | SchoolLocationCountOutputTypeCountImagesArgs
    contacts?: boolean | SchoolLocationCountOutputTypeCountContactsArgs
    students?: boolean | SchoolLocationCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * SchoolLocationCountOutputType without action
   */
  export type SchoolLocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationCountOutputType
     */
    select?: SchoolLocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolLocationCountOutputType without action
   */
  export type SchoolLocationCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolLocationImageWhereInput
  }

  /**
   * SchoolLocationCountOutputType without action
   */
  export type SchoolLocationCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolLocationContactWhereInput
  }

  /**
   * SchoolLocationCountOutputType without action
   */
  export type SchoolLocationCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSchoolLocationWhereInput
  }


  /**
   * Count Type SchoolProgramCountOutputType
   */

  export type SchoolProgramCountOutputType = {
    studentPrograms: number
    images: number
  }

  export type SchoolProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentPrograms?: boolean | SchoolProgramCountOutputTypeCountStudentProgramsArgs
    images?: boolean | SchoolProgramCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * SchoolProgramCountOutputType without action
   */
  export type SchoolProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramCountOutputType
     */
    select?: SchoolProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolProgramCountOutputType without action
   */
  export type SchoolProgramCountOutputTypeCountStudentProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSchoolProgramWhereInput
  }

  /**
   * SchoolProgramCountOutputType without action
   */
  export type SchoolProgramCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolProgramImageWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    messeages: number
    chats: number
    scholarship: number
    notifications: number
    ownedNotifications: number
    follows: number
    followers: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messeages?: boolean | StudentCountOutputTypeCountMesseagesArgs
    chats?: boolean | StudentCountOutputTypeCountChatsArgs
    scholarship?: boolean | StudentCountOutputTypeCountScholarshipArgs
    notifications?: boolean | StudentCountOutputTypeCountNotificationsArgs
    ownedNotifications?: boolean | StudentCountOutputTypeCountOwnedNotificationsArgs
    follows?: boolean | StudentCountOutputTypeCountFollowsArgs
    followers?: boolean | StudentCountOutputTypeCountFollowersArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountMesseagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountScholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSchoolScholarshipWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsNotificationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountOwnedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsNotificationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFollowWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFollowWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messeges: number
    students: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messeges?: boolean | ChatCountOutputTypeCountMessegesArgs
    students?: boolean | ChatCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessegesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    participants: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | EventCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventProfileWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    hostedEvents: number
    participatedEvents: number
    posts: number
    friendRequests: number
    friendReceived: number
    ownedGroups: number
    groups: number
    blogs: number
    postComments: number
    postCommentLikes: number
    postLikes: number
    postShares: number
    postSaved: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hostedEvents?: boolean | ProfileCountOutputTypeCountHostedEventsArgs
    participatedEvents?: boolean | ProfileCountOutputTypeCountParticipatedEventsArgs
    posts?: boolean | ProfileCountOutputTypeCountPostsArgs
    friendRequests?: boolean | ProfileCountOutputTypeCountFriendRequestsArgs
    friendReceived?: boolean | ProfileCountOutputTypeCountFriendReceivedArgs
    ownedGroups?: boolean | ProfileCountOutputTypeCountOwnedGroupsArgs
    groups?: boolean | ProfileCountOutputTypeCountGroupsArgs
    blogs?: boolean | ProfileCountOutputTypeCountBlogsArgs
    postComments?: boolean | ProfileCountOutputTypeCountPostCommentsArgs
    postCommentLikes?: boolean | ProfileCountOutputTypeCountPostCommentLikesArgs
    postLikes?: boolean | ProfileCountOutputTypeCountPostLikesArgs
    postShares?: boolean | ProfileCountOutputTypeCountPostSharesArgs
    postSaved?: boolean | ProfileCountOutputTypeCountPostSavedArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountHostedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountParticipatedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventProfileWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountFriendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileFriendWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountFriendReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileFriendWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountOwnedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileGroupWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBlogWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCommentWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostCommentLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCommentLikeWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostShareWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostSavedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostSaveWhereInput
  }


  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    biographies: number
  }

  export type AreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    biographies?: boolean | AreaCountOutputTypeCountBiographiesArgs
  }

  // Custom InputTypes
  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountBiographiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBiographyAreaWhereInput
  }


  /**
   * Count Type ProfileBiographyCountOutputType
   */

  export type ProfileBiographyCountOutputType = {
    areas: number
    socials: number
  }

  export type ProfileBiographyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | ProfileBiographyCountOutputTypeCountAreasArgs
    socials?: boolean | ProfileBiographyCountOutputTypeCountSocialsArgs
  }

  // Custom InputTypes
  /**
   * ProfileBiographyCountOutputType without action
   */
  export type ProfileBiographyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyCountOutputType
     */
    select?: ProfileBiographyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileBiographyCountOutputType without action
   */
  export type ProfileBiographyCountOutputTypeCountAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBiographyAreaWhereInput
  }

  /**
   * ProfileBiographyCountOutputType without action
   */
  export type ProfileBiographyCountOutputTypeCountSocialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBiographySocialWhereInput
  }


  /**
   * Count Type ProfileBlogCountOutputType
   */

  export type ProfileBlogCountOutputType = {
    images: number
  }

  export type ProfileBlogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ProfileBlogCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * ProfileBlogCountOutputType without action
   */
  export type ProfileBlogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogCountOutputType
     */
    select?: ProfileBlogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileBlogCountOutputType without action
   */
  export type ProfileBlogCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBlogImageWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    images: number
    comments: number
    likes: number
    shares: number
    saves: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | PostCountOutputTypeCountImagesArgs
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    likes?: boolean | PostCountOutputTypeCountLikesArgs
    shares?: boolean | PostCountOutputTypeCountSharesArgs
    saves?: boolean | PostCountOutputTypeCountSavesArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostImageWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostShareWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountSavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostSaveWhereInput
  }


  /**
   * Count Type PostCommentCountOutputType
   */

  export type PostCommentCountOutputType = {
    children: number
    likes: number
  }

  export type PostCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | PostCommentCountOutputTypeCountChildrenArgs
    likes?: boolean | PostCommentCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * PostCommentCountOutputType without action
   */
  export type PostCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentCountOutputType
     */
    select?: PostCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCommentCountOutputType without action
   */
  export type PostCommentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCommentWhereInput
  }

  /**
   * PostCommentCountOutputType without action
   */
  export type PostCommentCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCommentLikeWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    profiles: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | GroupCountOutputTypeCountProfilesArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileGroupWhereInput
  }


  /**
   * Count Type NewsCountOutputType
   */

  export type NewsCountOutputType = {
    notifications: number
  }

  export type NewsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | NewsCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * NewsCountOutputType without action
   */
  export type NewsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsCountOutputType
     */
    select?: NewsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsCountOutputType without action
   */
  export type NewsCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsNotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    name: string | null
    dob: Date | null
    gender: $Enums.Gender | null
    phoneNumber: string | null
    idCardNumber: string | null
    address: string | null
    image: string | null
    isLocked: boolean | null
    isTwoFactorEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    name: string | null
    dob: Date | null
    gender: $Enums.Gender | null
    phoneNumber: string | null
    idCardNumber: string | null
    address: string | null
    image: string | null
    isLocked: boolean | null
    isTwoFactorEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    password: number
    name: number
    dob: number
    gender: number
    phoneNumber: number
    idCardNumber: number
    address: number
    image: number
    isLocked: number
    isTwoFactorEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    password?: true
    name?: true
    dob?: true
    gender?: true
    phoneNumber?: true
    idCardNumber?: true
    address?: true
    image?: true
    isLocked?: true
    isTwoFactorEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    password?: true
    name?: true
    dob?: true
    gender?: true
    phoneNumber?: true
    idCardNumber?: true
    address?: true
    image?: true
    isLocked?: true
    isTwoFactorEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    password?: true
    name?: true
    dob?: true
    gender?: true
    phoneNumber?: true
    idCardNumber?: true
    address?: true
    image?: true
    isLocked?: true
    isTwoFactorEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    email: string
    emailVerified: Date | null
    password: string
    name: string
    dob: Date
    gender: $Enums.Gender
    phoneNumber: string
    idCardNumber: string
    address: string
    image: string | null
    isLocked: boolean
    isTwoFactorEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    name?: boolean
    dob?: boolean
    gender?: boolean
    phoneNumber?: boolean
    idCardNumber?: boolean
    address?: boolean
    image?: boolean
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorConfirmation?: boolean | Account$twoFactorConfirmationArgs<ExtArgs>
    student?: boolean | Account$studentArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    name?: boolean
    dob?: boolean
    gender?: boolean
    phoneNumber?: boolean
    idCardNumber?: boolean
    address?: boolean
    image?: boolean
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    name?: boolean
    dob?: boolean
    gender?: boolean
    phoneNumber?: boolean
    idCardNumber?: boolean
    address?: boolean
    image?: boolean
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    twoFactorConfirmation?: boolean | Account$twoFactorConfirmationArgs<ExtArgs>
    student?: boolean | Account$studentArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      twoFactorConfirmation: Prisma.$TwoFactorConfirmationPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: Date | null
      password: string
      name: string
      dob: Date
      gender: $Enums.Gender
      phoneNumber: string
      idCardNumber: string
      address: string
      image: string | null
      isLocked: boolean
      isTwoFactorEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    twoFactorConfirmation<T extends Account$twoFactorConfirmationArgs<ExtArgs> = {}>(args?: Subset<T, Account$twoFactorConfirmationArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    student<T extends Account$studentArgs<ExtArgs> = {}>(args?: Subset<T, Account$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly email: FieldRef<"Account", 'String'>
    readonly emailVerified: FieldRef<"Account", 'DateTime'>
    readonly password: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly dob: FieldRef<"Account", 'DateTime'>
    readonly gender: FieldRef<"Account", 'Gender'>
    readonly phoneNumber: FieldRef<"Account", 'String'>
    readonly idCardNumber: FieldRef<"Account", 'String'>
    readonly address: FieldRef<"Account", 'String'>
    readonly image: FieldRef<"Account", 'String'>
    readonly isLocked: FieldRef<"Account", 'Boolean'>
    readonly isTwoFactorEnabled: FieldRef<"Account", 'Boolean'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.twoFactorConfirmation
   */
  export type Account$twoFactorConfirmationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    where?: TwoFactorConfirmationWhereInput
  }

  /**
   * Account.student
   */
  export type Account$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    createdAt: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    createdAt: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
      createdAt: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly email: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
    readonly createdAt: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }


  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
  }


  /**
   * Model TwoFactorToken
   */

  export type AggregateTwoFactorToken = {
    _count: TwoFactorTokenCountAggregateOutputType | null
    _min: TwoFactorTokenMinAggregateOutputType | null
    _max: TwoFactorTokenMaxAggregateOutputType | null
  }

  export type TwoFactorTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type TwoFactorTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type TwoFactorTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    createdAt: number
    _all: number
  }


  export type TwoFactorTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type TwoFactorTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type TwoFactorTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
    _all?: true
  }

  export type TwoFactorTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorToken to aggregate.
     */
    where?: TwoFactorTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorTokens to fetch.
     */
    orderBy?: TwoFactorTokenOrderByWithRelationInput | TwoFactorTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorTokens
    **/
    _count?: true | TwoFactorTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorTokenMaxAggregateInputType
  }

  export type GetTwoFactorTokenAggregateType<T extends TwoFactorTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorToken[P]>
      : GetScalarType<T[P], AggregateTwoFactorToken[P]>
  }




  export type TwoFactorTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorTokenWhereInput
    orderBy?: TwoFactorTokenOrderByWithAggregationInput | TwoFactorTokenOrderByWithAggregationInput[]
    by: TwoFactorTokenScalarFieldEnum[] | TwoFactorTokenScalarFieldEnum
    having?: TwoFactorTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorTokenCountAggregateInputType | true
    _min?: TwoFactorTokenMinAggregateInputType
    _max?: TwoFactorTokenMaxAggregateInputType
  }

  export type TwoFactorTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    createdAt: Date
    _count: TwoFactorTokenCountAggregateOutputType | null
    _min: TwoFactorTokenMinAggregateOutputType | null
    _max: TwoFactorTokenMaxAggregateOutputType | null
  }

  type GetTwoFactorTokenGroupByPayload<T extends TwoFactorTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorTokenGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorTokenGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["twoFactorToken"]>

  export type TwoFactorTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["twoFactorToken"]>

  export type TwoFactorTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }


  export type $TwoFactorTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactorToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
      createdAt: Date
    }, ExtArgs["result"]["twoFactorToken"]>
    composites: {}
  }

  type TwoFactorTokenGetPayload<S extends boolean | null | undefined | TwoFactorTokenDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorTokenPayload, S>

  type TwoFactorTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TwoFactorTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TwoFactorTokenCountAggregateInputType | true
    }

  export interface TwoFactorTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorToken'], meta: { name: 'TwoFactorToken' } }
    /**
     * Find zero or one TwoFactorToken that matches the filter.
     * @param {TwoFactorTokenFindUniqueArgs} args - Arguments to find a TwoFactorToken
     * @example
     * // Get one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorTokenFindUniqueArgs>(args: SelectSubset<T, TwoFactorTokenFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TwoFactorToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TwoFactorTokenFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorToken
     * @example
     * // Get one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TwoFactorToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenFindFirstArgs} args - Arguments to find a TwoFactorToken
     * @example
     * // Get one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorTokenFindFirstArgs>(args?: SelectSubset<T, TwoFactorTokenFindFirstArgs<ExtArgs>>): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TwoFactorToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenFindFirstOrThrowArgs} args - Arguments to find a TwoFactorToken
     * @example
     * // Get one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TwoFactorTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorTokens
     * const twoFactorTokens = await prisma.twoFactorToken.findMany()
     * 
     * // Get first 10 TwoFactorTokens
     * const twoFactorTokens = await prisma.twoFactorToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorTokenWithIdOnly = await prisma.twoFactorToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorTokenFindManyArgs>(args?: SelectSubset<T, TwoFactorTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TwoFactorToken.
     * @param {TwoFactorTokenCreateArgs} args - Arguments to create a TwoFactorToken.
     * @example
     * // Create one TwoFactorToken
     * const TwoFactorToken = await prisma.twoFactorToken.create({
     *   data: {
     *     // ... data to create a TwoFactorToken
     *   }
     * })
     * 
     */
    create<T extends TwoFactorTokenCreateArgs>(args: SelectSubset<T, TwoFactorTokenCreateArgs<ExtArgs>>): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TwoFactorTokens.
     * @param {TwoFactorTokenCreateManyArgs} args - Arguments to create many TwoFactorTokens.
     * @example
     * // Create many TwoFactorTokens
     * const twoFactorToken = await prisma.twoFactorToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorTokenCreateManyArgs>(args?: SelectSubset<T, TwoFactorTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwoFactorTokens and returns the data saved in the database.
     * @param {TwoFactorTokenCreateManyAndReturnArgs} args - Arguments to create many TwoFactorTokens.
     * @example
     * // Create many TwoFactorTokens
     * const twoFactorToken = await prisma.twoFactorToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwoFactorTokens and only return the `id`
     * const twoFactorTokenWithIdOnly = await prisma.twoFactorToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwoFactorTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TwoFactorTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TwoFactorToken.
     * @param {TwoFactorTokenDeleteArgs} args - Arguments to delete one TwoFactorToken.
     * @example
     * // Delete one TwoFactorToken
     * const TwoFactorToken = await prisma.twoFactorToken.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorToken
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorTokenDeleteArgs>(args: SelectSubset<T, TwoFactorTokenDeleteArgs<ExtArgs>>): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TwoFactorToken.
     * @param {TwoFactorTokenUpdateArgs} args - Arguments to update one TwoFactorToken.
     * @example
     * // Update one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorTokenUpdateArgs>(args: SelectSubset<T, TwoFactorTokenUpdateArgs<ExtArgs>>): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TwoFactorTokens.
     * @param {TwoFactorTokenDeleteManyArgs} args - Arguments to filter TwoFactorTokens to delete.
     * @example
     * // Delete a few TwoFactorTokens
     * const { count } = await prisma.twoFactorToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorTokenDeleteManyArgs>(args?: SelectSubset<T, TwoFactorTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorTokens
     * const twoFactorToken = await prisma.twoFactorToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorTokenUpdateManyArgs>(args: SelectSubset<T, TwoFactorTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactorToken.
     * @param {TwoFactorTokenUpsertArgs} args - Arguments to update or create a TwoFactorToken.
     * @example
     * // Update or create a TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.upsert({
     *   create: {
     *     // ... data to create a TwoFactorToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorToken we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorTokenUpsertArgs>(args: SelectSubset<T, TwoFactorTokenUpsertArgs<ExtArgs>>): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TwoFactorTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenCountArgs} args - Arguments to filter TwoFactorTokens to count.
     * @example
     * // Count the number of TwoFactorTokens
     * const count = await prisma.twoFactorToken.count({
     *   where: {
     *     // ... the filter for the TwoFactorTokens we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorTokenCountArgs>(
      args?: Subset<T, TwoFactorTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorTokenAggregateArgs>(args: Subset<T, TwoFactorTokenAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorTokenAggregateType<T>>

    /**
     * Group by TwoFactorToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorTokenGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactorToken model
   */
  readonly fields: TwoFactorTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactorToken model
   */ 
  interface TwoFactorTokenFieldRefs {
    readonly id: FieldRef<"TwoFactorToken", 'String'>
    readonly email: FieldRef<"TwoFactorToken", 'String'>
    readonly token: FieldRef<"TwoFactorToken", 'String'>
    readonly expires: FieldRef<"TwoFactorToken", 'DateTime'>
    readonly createdAt: FieldRef<"TwoFactorToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactorToken findUnique
   */
  export type TwoFactorTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorToken to fetch.
     */
    where: TwoFactorTokenWhereUniqueInput
  }

  /**
   * TwoFactorToken findUniqueOrThrow
   */
  export type TwoFactorTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorToken to fetch.
     */
    where: TwoFactorTokenWhereUniqueInput
  }

  /**
   * TwoFactorToken findFirst
   */
  export type TwoFactorTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorToken to fetch.
     */
    where?: TwoFactorTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorTokens to fetch.
     */
    orderBy?: TwoFactorTokenOrderByWithRelationInput | TwoFactorTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorTokens.
     */
    cursor?: TwoFactorTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorTokens.
     */
    distinct?: TwoFactorTokenScalarFieldEnum | TwoFactorTokenScalarFieldEnum[]
  }

  /**
   * TwoFactorToken findFirstOrThrow
   */
  export type TwoFactorTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorToken to fetch.
     */
    where?: TwoFactorTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorTokens to fetch.
     */
    orderBy?: TwoFactorTokenOrderByWithRelationInput | TwoFactorTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorTokens.
     */
    cursor?: TwoFactorTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorTokens.
     */
    distinct?: TwoFactorTokenScalarFieldEnum | TwoFactorTokenScalarFieldEnum[]
  }

  /**
   * TwoFactorToken findMany
   */
  export type TwoFactorTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorTokens to fetch.
     */
    where?: TwoFactorTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorTokens to fetch.
     */
    orderBy?: TwoFactorTokenOrderByWithRelationInput | TwoFactorTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorTokens.
     */
    cursor?: TwoFactorTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorTokens.
     */
    skip?: number
    distinct?: TwoFactorTokenScalarFieldEnum | TwoFactorTokenScalarFieldEnum[]
  }

  /**
   * TwoFactorToken create
   */
  export type TwoFactorTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorToken.
     */
    data: XOR<TwoFactorTokenCreateInput, TwoFactorTokenUncheckedCreateInput>
  }

  /**
   * TwoFactorToken createMany
   */
  export type TwoFactorTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorTokens.
     */
    data: TwoFactorTokenCreateManyInput | TwoFactorTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactorToken createManyAndReturn
   */
  export type TwoFactorTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TwoFactorTokens.
     */
    data: TwoFactorTokenCreateManyInput | TwoFactorTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactorToken update
   */
  export type TwoFactorTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorToken.
     */
    data: XOR<TwoFactorTokenUpdateInput, TwoFactorTokenUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorToken to update.
     */
    where: TwoFactorTokenWhereUniqueInput
  }

  /**
   * TwoFactorToken updateMany
   */
  export type TwoFactorTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorTokens.
     */
    data: XOR<TwoFactorTokenUpdateManyMutationInput, TwoFactorTokenUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorTokens to update
     */
    where?: TwoFactorTokenWhereInput
  }

  /**
   * TwoFactorToken upsert
   */
  export type TwoFactorTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorToken to update in case it exists.
     */
    where: TwoFactorTokenWhereUniqueInput
    /**
     * In case the TwoFactorToken found by the `where` argument doesn't exist, create a new TwoFactorToken with this data.
     */
    create: XOR<TwoFactorTokenCreateInput, TwoFactorTokenUncheckedCreateInput>
    /**
     * In case the TwoFactorToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorTokenUpdateInput, TwoFactorTokenUncheckedUpdateInput>
  }

  /**
   * TwoFactorToken delete
   */
  export type TwoFactorTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter which TwoFactorToken to delete.
     */
    where: TwoFactorTokenWhereUniqueInput
  }

  /**
   * TwoFactorToken deleteMany
   */
  export type TwoFactorTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorTokens to delete
     */
    where?: TwoFactorTokenWhereInput
  }

  /**
   * TwoFactorToken without action
   */
  export type TwoFactorTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
  }


  /**
   * Model TwoFactorConfirmation
   */

  export type AggregateTwoFactorConfirmation = {
    _count: TwoFactorConfirmationCountAggregateOutputType | null
    _min: TwoFactorConfirmationMinAggregateOutputType | null
    _max: TwoFactorConfirmationMaxAggregateOutputType | null
  }

  export type TwoFactorConfirmationMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorConfirmationMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorConfirmationCountAggregateOutputType = {
    id: number
    accountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwoFactorConfirmationMinAggregateInputType = {
    id?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorConfirmationMaxAggregateInputType = {
    id?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorConfirmationCountAggregateInputType = {
    id?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwoFactorConfirmationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorConfirmation to aggregate.
     */
    where?: TwoFactorConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorConfirmations to fetch.
     */
    orderBy?: TwoFactorConfirmationOrderByWithRelationInput | TwoFactorConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorConfirmations
    **/
    _count?: true | TwoFactorConfirmationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorConfirmationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorConfirmationMaxAggregateInputType
  }

  export type GetTwoFactorConfirmationAggregateType<T extends TwoFactorConfirmationAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorConfirmation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorConfirmation[P]>
      : GetScalarType<T[P], AggregateTwoFactorConfirmation[P]>
  }




  export type TwoFactorConfirmationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorConfirmationWhereInput
    orderBy?: TwoFactorConfirmationOrderByWithAggregationInput | TwoFactorConfirmationOrderByWithAggregationInput[]
    by: TwoFactorConfirmationScalarFieldEnum[] | TwoFactorConfirmationScalarFieldEnum
    having?: TwoFactorConfirmationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorConfirmationCountAggregateInputType | true
    _min?: TwoFactorConfirmationMinAggregateInputType
    _max?: TwoFactorConfirmationMaxAggregateInputType
  }

  export type TwoFactorConfirmationGroupByOutputType = {
    id: string
    accountId: string
    createdAt: Date
    updatedAt: Date
    _count: TwoFactorConfirmationCountAggregateOutputType | null
    _min: TwoFactorConfirmationMinAggregateOutputType | null
    _max: TwoFactorConfirmationMaxAggregateOutputType | null
  }

  type GetTwoFactorConfirmationGroupByPayload<T extends TwoFactorConfirmationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorConfirmationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorConfirmationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorConfirmationGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorConfirmationGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorConfirmationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorConfirmation"]>

  export type TwoFactorConfirmationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorConfirmation"]>

  export type TwoFactorConfirmationSelectScalar = {
    id?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TwoFactorConfirmationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type TwoFactorConfirmationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $TwoFactorConfirmationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactorConfirmation"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["twoFactorConfirmation"]>
    composites: {}
  }

  type TwoFactorConfirmationGetPayload<S extends boolean | null | undefined | TwoFactorConfirmationDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorConfirmationPayload, S>

  type TwoFactorConfirmationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TwoFactorConfirmationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TwoFactorConfirmationCountAggregateInputType | true
    }

  export interface TwoFactorConfirmationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorConfirmation'], meta: { name: 'TwoFactorConfirmation' } }
    /**
     * Find zero or one TwoFactorConfirmation that matches the filter.
     * @param {TwoFactorConfirmationFindUniqueArgs} args - Arguments to find a TwoFactorConfirmation
     * @example
     * // Get one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorConfirmationFindUniqueArgs>(args: SelectSubset<T, TwoFactorConfirmationFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TwoFactorConfirmation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TwoFactorConfirmationFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorConfirmation
     * @example
     * // Get one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorConfirmationFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorConfirmationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TwoFactorConfirmation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationFindFirstArgs} args - Arguments to find a TwoFactorConfirmation
     * @example
     * // Get one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorConfirmationFindFirstArgs>(args?: SelectSubset<T, TwoFactorConfirmationFindFirstArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TwoFactorConfirmation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationFindFirstOrThrowArgs} args - Arguments to find a TwoFactorConfirmation
     * @example
     * // Get one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorConfirmationFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorConfirmationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TwoFactorConfirmations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorConfirmations
     * const twoFactorConfirmations = await prisma.twoFactorConfirmation.findMany()
     * 
     * // Get first 10 TwoFactorConfirmations
     * const twoFactorConfirmations = await prisma.twoFactorConfirmation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorConfirmationWithIdOnly = await prisma.twoFactorConfirmation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorConfirmationFindManyArgs>(args?: SelectSubset<T, TwoFactorConfirmationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TwoFactorConfirmation.
     * @param {TwoFactorConfirmationCreateArgs} args - Arguments to create a TwoFactorConfirmation.
     * @example
     * // Create one TwoFactorConfirmation
     * const TwoFactorConfirmation = await prisma.twoFactorConfirmation.create({
     *   data: {
     *     // ... data to create a TwoFactorConfirmation
     *   }
     * })
     * 
     */
    create<T extends TwoFactorConfirmationCreateArgs>(args: SelectSubset<T, TwoFactorConfirmationCreateArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TwoFactorConfirmations.
     * @param {TwoFactorConfirmationCreateManyArgs} args - Arguments to create many TwoFactorConfirmations.
     * @example
     * // Create many TwoFactorConfirmations
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorConfirmationCreateManyArgs>(args?: SelectSubset<T, TwoFactorConfirmationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwoFactorConfirmations and returns the data saved in the database.
     * @param {TwoFactorConfirmationCreateManyAndReturnArgs} args - Arguments to create many TwoFactorConfirmations.
     * @example
     * // Create many TwoFactorConfirmations
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwoFactorConfirmations and only return the `id`
     * const twoFactorConfirmationWithIdOnly = await prisma.twoFactorConfirmation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwoFactorConfirmationCreateManyAndReturnArgs>(args?: SelectSubset<T, TwoFactorConfirmationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TwoFactorConfirmation.
     * @param {TwoFactorConfirmationDeleteArgs} args - Arguments to delete one TwoFactorConfirmation.
     * @example
     * // Delete one TwoFactorConfirmation
     * const TwoFactorConfirmation = await prisma.twoFactorConfirmation.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorConfirmation
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorConfirmationDeleteArgs>(args: SelectSubset<T, TwoFactorConfirmationDeleteArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TwoFactorConfirmation.
     * @param {TwoFactorConfirmationUpdateArgs} args - Arguments to update one TwoFactorConfirmation.
     * @example
     * // Update one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorConfirmationUpdateArgs>(args: SelectSubset<T, TwoFactorConfirmationUpdateArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TwoFactorConfirmations.
     * @param {TwoFactorConfirmationDeleteManyArgs} args - Arguments to filter TwoFactorConfirmations to delete.
     * @example
     * // Delete a few TwoFactorConfirmations
     * const { count } = await prisma.twoFactorConfirmation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorConfirmationDeleteManyArgs>(args?: SelectSubset<T, TwoFactorConfirmationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorConfirmations
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorConfirmationUpdateManyArgs>(args: SelectSubset<T, TwoFactorConfirmationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactorConfirmation.
     * @param {TwoFactorConfirmationUpsertArgs} args - Arguments to update or create a TwoFactorConfirmation.
     * @example
     * // Update or create a TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.upsert({
     *   create: {
     *     // ... data to create a TwoFactorConfirmation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorConfirmation we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorConfirmationUpsertArgs>(args: SelectSubset<T, TwoFactorConfirmationUpsertArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TwoFactorConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationCountArgs} args - Arguments to filter TwoFactorConfirmations to count.
     * @example
     * // Count the number of TwoFactorConfirmations
     * const count = await prisma.twoFactorConfirmation.count({
     *   where: {
     *     // ... the filter for the TwoFactorConfirmations we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorConfirmationCountArgs>(
      args?: Subset<T, TwoFactorConfirmationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorConfirmationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorConfirmationAggregateArgs>(args: Subset<T, TwoFactorConfirmationAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorConfirmationAggregateType<T>>

    /**
     * Group by TwoFactorConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorConfirmationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorConfirmationGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorConfirmationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorConfirmationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorConfirmationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactorConfirmation model
   */
  readonly fields: TwoFactorConfirmationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorConfirmation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorConfirmationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactorConfirmation model
   */ 
  interface TwoFactorConfirmationFieldRefs {
    readonly id: FieldRef<"TwoFactorConfirmation", 'String'>
    readonly accountId: FieldRef<"TwoFactorConfirmation", 'String'>
    readonly createdAt: FieldRef<"TwoFactorConfirmation", 'DateTime'>
    readonly updatedAt: FieldRef<"TwoFactorConfirmation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactorConfirmation findUnique
   */
  export type TwoFactorConfirmationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmation to fetch.
     */
    where: TwoFactorConfirmationWhereUniqueInput
  }

  /**
   * TwoFactorConfirmation findUniqueOrThrow
   */
  export type TwoFactorConfirmationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmation to fetch.
     */
    where: TwoFactorConfirmationWhereUniqueInput
  }

  /**
   * TwoFactorConfirmation findFirst
   */
  export type TwoFactorConfirmationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmation to fetch.
     */
    where?: TwoFactorConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorConfirmations to fetch.
     */
    orderBy?: TwoFactorConfirmationOrderByWithRelationInput | TwoFactorConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorConfirmations.
     */
    cursor?: TwoFactorConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorConfirmations.
     */
    distinct?: TwoFactorConfirmationScalarFieldEnum | TwoFactorConfirmationScalarFieldEnum[]
  }

  /**
   * TwoFactorConfirmation findFirstOrThrow
   */
  export type TwoFactorConfirmationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmation to fetch.
     */
    where?: TwoFactorConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorConfirmations to fetch.
     */
    orderBy?: TwoFactorConfirmationOrderByWithRelationInput | TwoFactorConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorConfirmations.
     */
    cursor?: TwoFactorConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorConfirmations.
     */
    distinct?: TwoFactorConfirmationScalarFieldEnum | TwoFactorConfirmationScalarFieldEnum[]
  }

  /**
   * TwoFactorConfirmation findMany
   */
  export type TwoFactorConfirmationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmations to fetch.
     */
    where?: TwoFactorConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorConfirmations to fetch.
     */
    orderBy?: TwoFactorConfirmationOrderByWithRelationInput | TwoFactorConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorConfirmations.
     */
    cursor?: TwoFactorConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorConfirmations.
     */
    skip?: number
    distinct?: TwoFactorConfirmationScalarFieldEnum | TwoFactorConfirmationScalarFieldEnum[]
  }

  /**
   * TwoFactorConfirmation create
   */
  export type TwoFactorConfirmationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorConfirmation.
     */
    data: XOR<TwoFactorConfirmationCreateInput, TwoFactorConfirmationUncheckedCreateInput>
  }

  /**
   * TwoFactorConfirmation createMany
   */
  export type TwoFactorConfirmationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorConfirmations.
     */
    data: TwoFactorConfirmationCreateManyInput | TwoFactorConfirmationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactorConfirmation createManyAndReturn
   */
  export type TwoFactorConfirmationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TwoFactorConfirmations.
     */
    data: TwoFactorConfirmationCreateManyInput | TwoFactorConfirmationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwoFactorConfirmation update
   */
  export type TwoFactorConfirmationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorConfirmation.
     */
    data: XOR<TwoFactorConfirmationUpdateInput, TwoFactorConfirmationUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorConfirmation to update.
     */
    where: TwoFactorConfirmationWhereUniqueInput
  }

  /**
   * TwoFactorConfirmation updateMany
   */
  export type TwoFactorConfirmationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorConfirmations.
     */
    data: XOR<TwoFactorConfirmationUpdateManyMutationInput, TwoFactorConfirmationUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorConfirmations to update
     */
    where?: TwoFactorConfirmationWhereInput
  }

  /**
   * TwoFactorConfirmation upsert
   */
  export type TwoFactorConfirmationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorConfirmation to update in case it exists.
     */
    where: TwoFactorConfirmationWhereUniqueInput
    /**
     * In case the TwoFactorConfirmation found by the `where` argument doesn't exist, create a new TwoFactorConfirmation with this data.
     */
    create: XOR<TwoFactorConfirmationCreateInput, TwoFactorConfirmationUncheckedCreateInput>
    /**
     * In case the TwoFactorConfirmation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorConfirmationUpdateInput, TwoFactorConfirmationUncheckedUpdateInput>
  }

  /**
   * TwoFactorConfirmation delete
   */
  export type TwoFactorConfirmationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter which TwoFactorConfirmation to delete.
     */
    where: TwoFactorConfirmationWhereUniqueInput
  }

  /**
   * TwoFactorConfirmation deleteMany
   */
  export type TwoFactorConfirmationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorConfirmations to delete
     */
    where?: TwoFactorConfirmationWhereInput
  }

  /**
   * TwoFactorConfirmation without action
   */
  export type TwoFactorConfirmationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    logo: string | null
    background: string | null
    name: string | null
    short: string | null
    description: string | null
    history: string | null
    color: string | null
    isPublished: boolean | null
    country: $Enums.Country | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    logo: string | null
    background: string | null
    name: string | null
    short: string | null
    description: string | null
    history: string | null
    color: string | null
    isPublished: boolean | null
    country: $Enums.Country | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    logo: number
    background: number
    name: number
    short: number
    description: number
    history: number
    color: number
    isPublished: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMinAggregateInputType = {
    id?: true
    logo?: true
    background?: true
    name?: true
    short?: true
    description?: true
    history?: true
    color?: true
    isPublished?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    logo?: true
    background?: true
    name?: true
    short?: true
    description?: true
    history?: true
    color?: true
    isPublished?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    logo?: true
    background?: true
    name?: true
    short?: true
    description?: true
    history?: true
    color?: true
    isPublished?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    logo: string
    background: string
    name: string
    short: string | null
    description: string | null
    history: string | null
    color: string
    isPublished: boolean
    country: $Enums.Country
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logo?: boolean
    background?: boolean
    name?: boolean
    short?: boolean
    description?: boolean
    history?: boolean
    color?: boolean
    isPublished?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    students?: boolean | School$studentsArgs<ExtArgs>
    locations?: boolean | School$locationsArgs<ExtArgs>
    programs?: boolean | School$programsArgs<ExtArgs>
    galleries?: boolean | School$galleriesArgs<ExtArgs>
    scholarships?: boolean | School$scholarshipsArgs<ExtArgs>
    news?: boolean | School$newsArgs<ExtArgs>
    contacts?: boolean | School$contactsArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logo?: boolean
    background?: boolean
    name?: boolean
    short?: boolean
    description?: boolean
    history?: boolean
    color?: boolean
    isPublished?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    logo?: boolean
    background?: boolean
    name?: boolean
    short?: boolean
    description?: boolean
    history?: boolean
    color?: boolean
    isPublished?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | School$studentsArgs<ExtArgs>
    locations?: boolean | School$locationsArgs<ExtArgs>
    programs?: boolean | School$programsArgs<ExtArgs>
    galleries?: boolean | School$galleriesArgs<ExtArgs>
    scholarships?: boolean | School$scholarshipsArgs<ExtArgs>
    news?: boolean | School$newsArgs<ExtArgs>
    contacts?: boolean | School$contactsArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      students: Prisma.$StudentPayload<ExtArgs>[]
      locations: Prisma.$SchoolLocationPayload<ExtArgs>[]
      programs: Prisma.$SchoolProgramPayload<ExtArgs>[]
      galleries: Prisma.$SchoolGalleryPayload<ExtArgs>[]
      scholarships: Prisma.$SchoolScholarshipPayload<ExtArgs>[]
      news: Prisma.$NewsPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      logo: string
      background: string
      name: string
      short: string | null
      description: string | null
      history: string | null
      color: string
      isPublished: boolean
      country: $Enums.Country
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends School$studentsArgs<ExtArgs> = {}>(args?: Subset<T, School$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    locations<T extends School$locationsArgs<ExtArgs> = {}>(args?: Subset<T, School$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "findMany"> | Null>
    programs<T extends School$programsArgs<ExtArgs> = {}>(args?: Subset<T, School$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "findMany"> | Null>
    galleries<T extends School$galleriesArgs<ExtArgs> = {}>(args?: Subset<T, School$galleriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "findMany"> | Null>
    scholarships<T extends School$scholarshipsArgs<ExtArgs> = {}>(args?: Subset<T, School$scholarshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "findMany"> | Null>
    news<T extends School$newsArgs<ExtArgs> = {}>(args?: Subset<T, School$newsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany"> | Null>
    contacts<T extends School$contactsArgs<ExtArgs> = {}>(args?: Subset<T, School$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */ 
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly logo: FieldRef<"School", 'String'>
    readonly background: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly short: FieldRef<"School", 'String'>
    readonly description: FieldRef<"School", 'String'>
    readonly history: FieldRef<"School", 'String'>
    readonly color: FieldRef<"School", 'String'>
    readonly isPublished: FieldRef<"School", 'Boolean'>
    readonly country: FieldRef<"School", 'Country'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
  }

  /**
   * School.students
   */
  export type School$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * School.locations
   */
  export type School$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    where?: SchoolLocationWhereInput
    orderBy?: SchoolLocationOrderByWithRelationInput | SchoolLocationOrderByWithRelationInput[]
    cursor?: SchoolLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolLocationScalarFieldEnum | SchoolLocationScalarFieldEnum[]
  }

  /**
   * School.programs
   */
  export type School$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    where?: SchoolProgramWhereInput
    orderBy?: SchoolProgramOrderByWithRelationInput | SchoolProgramOrderByWithRelationInput[]
    cursor?: SchoolProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolProgramScalarFieldEnum | SchoolProgramScalarFieldEnum[]
  }

  /**
   * School.galleries
   */
  export type School$galleriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    where?: SchoolGalleryWhereInput
    orderBy?: SchoolGalleryOrderByWithRelationInput | SchoolGalleryOrderByWithRelationInput[]
    cursor?: SchoolGalleryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolGalleryScalarFieldEnum | SchoolGalleryScalarFieldEnum[]
  }

  /**
   * School.scholarships
   */
  export type School$scholarshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    where?: SchoolScholarshipWhereInput
    orderBy?: SchoolScholarshipOrderByWithRelationInput | SchoolScholarshipOrderByWithRelationInput[]
    cursor?: SchoolScholarshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScholarshipScalarFieldEnum | SchoolScholarshipScalarFieldEnum[]
  }

  /**
   * School.news
   */
  export type School$newsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    cursor?: NewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * School.contacts
   */
  export type School$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model SchoolScholarship
   */

  export type AggregateSchoolScholarship = {
    _count: SchoolScholarshipCountAggregateOutputType | null
    _min: SchoolScholarshipMinAggregateOutputType | null
    _max: SchoolScholarshipMaxAggregateOutputType | null
  }

  export type SchoolScholarshipMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    cover: string | null
    isPublished: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolScholarshipMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    cover: string | null
    isPublished: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolScholarshipCountAggregateOutputType = {
    id: number
    name: number
    description: number
    cover: number
    isPublished: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolScholarshipMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cover?: true
    isPublished?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolScholarshipMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cover?: true
    isPublished?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolScholarshipCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cover?: true
    isPublished?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolScholarshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolScholarship to aggregate.
     */
    where?: SchoolScholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolScholarships to fetch.
     */
    orderBy?: SchoolScholarshipOrderByWithRelationInput | SchoolScholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolScholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolScholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolScholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolScholarships
    **/
    _count?: true | SchoolScholarshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolScholarshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolScholarshipMaxAggregateInputType
  }

  export type GetSchoolScholarshipAggregateType<T extends SchoolScholarshipAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolScholarship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolScholarship[P]>
      : GetScalarType<T[P], AggregateSchoolScholarship[P]>
  }




  export type SchoolScholarshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolScholarshipWhereInput
    orderBy?: SchoolScholarshipOrderByWithAggregationInput | SchoolScholarshipOrderByWithAggregationInput[]
    by: SchoolScholarshipScalarFieldEnum[] | SchoolScholarshipScalarFieldEnum
    having?: SchoolScholarshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolScholarshipCountAggregateInputType | true
    _min?: SchoolScholarshipMinAggregateInputType
    _max?: SchoolScholarshipMaxAggregateInputType
  }

  export type SchoolScholarshipGroupByOutputType = {
    id: string
    name: string
    description: string
    cover: string | null
    isPublished: boolean
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolScholarshipCountAggregateOutputType | null
    _min: SchoolScholarshipMinAggregateOutputType | null
    _max: SchoolScholarshipMaxAggregateOutputType | null
  }

  type GetSchoolScholarshipGroupByPayload<T extends SchoolScholarshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolScholarshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolScholarshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolScholarshipGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolScholarshipGroupByOutputType[P]>
        }
      >
    >


  export type SchoolScholarshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    cover?: boolean
    isPublished?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    owners?: boolean | SchoolScholarship$ownersArgs<ExtArgs>
    images?: boolean | SchoolScholarship$imagesArgs<ExtArgs>
    _count?: boolean | SchoolScholarshipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolScholarship"]>

  export type SchoolScholarshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    cover?: boolean
    isPublished?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolScholarship"]>

  export type SchoolScholarshipSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    cover?: boolean
    isPublished?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolScholarshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    owners?: boolean | SchoolScholarship$ownersArgs<ExtArgs>
    images?: boolean | SchoolScholarship$imagesArgs<ExtArgs>
    _count?: boolean | SchoolScholarshipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolScholarshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolScholarshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolScholarship"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      owners: Prisma.$StudentSchoolScholarshipPayload<ExtArgs>[]
      images: Prisma.$SchoolScholarshipImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      cover: string | null
      isPublished: boolean
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolScholarship"]>
    composites: {}
  }

  type SchoolScholarshipGetPayload<S extends boolean | null | undefined | SchoolScholarshipDefaultArgs> = $Result.GetResult<Prisma.$SchoolScholarshipPayload, S>

  type SchoolScholarshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolScholarshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolScholarshipCountAggregateInputType | true
    }

  export interface SchoolScholarshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolScholarship'], meta: { name: 'SchoolScholarship' } }
    /**
     * Find zero or one SchoolScholarship that matches the filter.
     * @param {SchoolScholarshipFindUniqueArgs} args - Arguments to find a SchoolScholarship
     * @example
     * // Get one SchoolScholarship
     * const schoolScholarship = await prisma.schoolScholarship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolScholarshipFindUniqueArgs>(args: SelectSubset<T, SchoolScholarshipFindUniqueArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolScholarship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolScholarshipFindUniqueOrThrowArgs} args - Arguments to find a SchoolScholarship
     * @example
     * // Get one SchoolScholarship
     * const schoolScholarship = await prisma.schoolScholarship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolScholarshipFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolScholarshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolScholarship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipFindFirstArgs} args - Arguments to find a SchoolScholarship
     * @example
     * // Get one SchoolScholarship
     * const schoolScholarship = await prisma.schoolScholarship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolScholarshipFindFirstArgs>(args?: SelectSubset<T, SchoolScholarshipFindFirstArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolScholarship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipFindFirstOrThrowArgs} args - Arguments to find a SchoolScholarship
     * @example
     * // Get one SchoolScholarship
     * const schoolScholarship = await prisma.schoolScholarship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolScholarshipFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolScholarshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolScholarships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolScholarships
     * const schoolScholarships = await prisma.schoolScholarship.findMany()
     * 
     * // Get first 10 SchoolScholarships
     * const schoolScholarships = await prisma.schoolScholarship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolScholarshipWithIdOnly = await prisma.schoolScholarship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolScholarshipFindManyArgs>(args?: SelectSubset<T, SchoolScholarshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolScholarship.
     * @param {SchoolScholarshipCreateArgs} args - Arguments to create a SchoolScholarship.
     * @example
     * // Create one SchoolScholarship
     * const SchoolScholarship = await prisma.schoolScholarship.create({
     *   data: {
     *     // ... data to create a SchoolScholarship
     *   }
     * })
     * 
     */
    create<T extends SchoolScholarshipCreateArgs>(args: SelectSubset<T, SchoolScholarshipCreateArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolScholarships.
     * @param {SchoolScholarshipCreateManyArgs} args - Arguments to create many SchoolScholarships.
     * @example
     * // Create many SchoolScholarships
     * const schoolScholarship = await prisma.schoolScholarship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolScholarshipCreateManyArgs>(args?: SelectSubset<T, SchoolScholarshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolScholarships and returns the data saved in the database.
     * @param {SchoolScholarshipCreateManyAndReturnArgs} args - Arguments to create many SchoolScholarships.
     * @example
     * // Create many SchoolScholarships
     * const schoolScholarship = await prisma.schoolScholarship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolScholarships and only return the `id`
     * const schoolScholarshipWithIdOnly = await prisma.schoolScholarship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolScholarshipCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolScholarshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolScholarship.
     * @param {SchoolScholarshipDeleteArgs} args - Arguments to delete one SchoolScholarship.
     * @example
     * // Delete one SchoolScholarship
     * const SchoolScholarship = await prisma.schoolScholarship.delete({
     *   where: {
     *     // ... filter to delete one SchoolScholarship
     *   }
     * })
     * 
     */
    delete<T extends SchoolScholarshipDeleteArgs>(args: SelectSubset<T, SchoolScholarshipDeleteArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolScholarship.
     * @param {SchoolScholarshipUpdateArgs} args - Arguments to update one SchoolScholarship.
     * @example
     * // Update one SchoolScholarship
     * const schoolScholarship = await prisma.schoolScholarship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolScholarshipUpdateArgs>(args: SelectSubset<T, SchoolScholarshipUpdateArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolScholarships.
     * @param {SchoolScholarshipDeleteManyArgs} args - Arguments to filter SchoolScholarships to delete.
     * @example
     * // Delete a few SchoolScholarships
     * const { count } = await prisma.schoolScholarship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolScholarshipDeleteManyArgs>(args?: SelectSubset<T, SchoolScholarshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolScholarships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolScholarships
     * const schoolScholarship = await prisma.schoolScholarship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolScholarshipUpdateManyArgs>(args: SelectSubset<T, SchoolScholarshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolScholarship.
     * @param {SchoolScholarshipUpsertArgs} args - Arguments to update or create a SchoolScholarship.
     * @example
     * // Update or create a SchoolScholarship
     * const schoolScholarship = await prisma.schoolScholarship.upsert({
     *   create: {
     *     // ... data to create a SchoolScholarship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolScholarship we want to update
     *   }
     * })
     */
    upsert<T extends SchoolScholarshipUpsertArgs>(args: SelectSubset<T, SchoolScholarshipUpsertArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolScholarships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipCountArgs} args - Arguments to filter SchoolScholarships to count.
     * @example
     * // Count the number of SchoolScholarships
     * const count = await prisma.schoolScholarship.count({
     *   where: {
     *     // ... the filter for the SchoolScholarships we want to count
     *   }
     * })
    **/
    count<T extends SchoolScholarshipCountArgs>(
      args?: Subset<T, SchoolScholarshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolScholarshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolScholarship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolScholarshipAggregateArgs>(args: Subset<T, SchoolScholarshipAggregateArgs>): Prisma.PrismaPromise<GetSchoolScholarshipAggregateType<T>>

    /**
     * Group by SchoolScholarship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolScholarshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolScholarshipGroupByArgs['orderBy'] }
        : { orderBy?: SchoolScholarshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolScholarshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolScholarshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolScholarship model
   */
  readonly fields: SchoolScholarshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolScholarship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolScholarshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owners<T extends SchoolScholarship$ownersArgs<ExtArgs> = {}>(args?: Subset<T, SchoolScholarship$ownersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "findMany"> | Null>
    images<T extends SchoolScholarship$imagesArgs<ExtArgs> = {}>(args?: Subset<T, SchoolScholarship$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolScholarship model
   */ 
  interface SchoolScholarshipFieldRefs {
    readonly id: FieldRef<"SchoolScholarship", 'String'>
    readonly name: FieldRef<"SchoolScholarship", 'String'>
    readonly description: FieldRef<"SchoolScholarship", 'String'>
    readonly cover: FieldRef<"SchoolScholarship", 'String'>
    readonly isPublished: FieldRef<"SchoolScholarship", 'Boolean'>
    readonly schoolId: FieldRef<"SchoolScholarship", 'String'>
    readonly createdAt: FieldRef<"SchoolScholarship", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolScholarship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolScholarship findUnique
   */
  export type SchoolScholarshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarship to fetch.
     */
    where: SchoolScholarshipWhereUniqueInput
  }

  /**
   * SchoolScholarship findUniqueOrThrow
   */
  export type SchoolScholarshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarship to fetch.
     */
    where: SchoolScholarshipWhereUniqueInput
  }

  /**
   * SchoolScholarship findFirst
   */
  export type SchoolScholarshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarship to fetch.
     */
    where?: SchoolScholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolScholarships to fetch.
     */
    orderBy?: SchoolScholarshipOrderByWithRelationInput | SchoolScholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolScholarships.
     */
    cursor?: SchoolScholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolScholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolScholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolScholarships.
     */
    distinct?: SchoolScholarshipScalarFieldEnum | SchoolScholarshipScalarFieldEnum[]
  }

  /**
   * SchoolScholarship findFirstOrThrow
   */
  export type SchoolScholarshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarship to fetch.
     */
    where?: SchoolScholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolScholarships to fetch.
     */
    orderBy?: SchoolScholarshipOrderByWithRelationInput | SchoolScholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolScholarships.
     */
    cursor?: SchoolScholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolScholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolScholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolScholarships.
     */
    distinct?: SchoolScholarshipScalarFieldEnum | SchoolScholarshipScalarFieldEnum[]
  }

  /**
   * SchoolScholarship findMany
   */
  export type SchoolScholarshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarships to fetch.
     */
    where?: SchoolScholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolScholarships to fetch.
     */
    orderBy?: SchoolScholarshipOrderByWithRelationInput | SchoolScholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolScholarships.
     */
    cursor?: SchoolScholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolScholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolScholarships.
     */
    skip?: number
    distinct?: SchoolScholarshipScalarFieldEnum | SchoolScholarshipScalarFieldEnum[]
  }

  /**
   * SchoolScholarship create
   */
  export type SchoolScholarshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolScholarship.
     */
    data: XOR<SchoolScholarshipCreateInput, SchoolScholarshipUncheckedCreateInput>
  }

  /**
   * SchoolScholarship createMany
   */
  export type SchoolScholarshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolScholarships.
     */
    data: SchoolScholarshipCreateManyInput | SchoolScholarshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolScholarship createManyAndReturn
   */
  export type SchoolScholarshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolScholarships.
     */
    data: SchoolScholarshipCreateManyInput | SchoolScholarshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolScholarship update
   */
  export type SchoolScholarshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolScholarship.
     */
    data: XOR<SchoolScholarshipUpdateInput, SchoolScholarshipUncheckedUpdateInput>
    /**
     * Choose, which SchoolScholarship to update.
     */
    where: SchoolScholarshipWhereUniqueInput
  }

  /**
   * SchoolScholarship updateMany
   */
  export type SchoolScholarshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolScholarships.
     */
    data: XOR<SchoolScholarshipUpdateManyMutationInput, SchoolScholarshipUncheckedUpdateManyInput>
    /**
     * Filter which SchoolScholarships to update
     */
    where?: SchoolScholarshipWhereInput
  }

  /**
   * SchoolScholarship upsert
   */
  export type SchoolScholarshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolScholarship to update in case it exists.
     */
    where: SchoolScholarshipWhereUniqueInput
    /**
     * In case the SchoolScholarship found by the `where` argument doesn't exist, create a new SchoolScholarship with this data.
     */
    create: XOR<SchoolScholarshipCreateInput, SchoolScholarshipUncheckedCreateInput>
    /**
     * In case the SchoolScholarship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolScholarshipUpdateInput, SchoolScholarshipUncheckedUpdateInput>
  }

  /**
   * SchoolScholarship delete
   */
  export type SchoolScholarshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter which SchoolScholarship to delete.
     */
    where: SchoolScholarshipWhereUniqueInput
  }

  /**
   * SchoolScholarship deleteMany
   */
  export type SchoolScholarshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolScholarships to delete
     */
    where?: SchoolScholarshipWhereInput
  }

  /**
   * SchoolScholarship.owners
   */
  export type SchoolScholarship$ownersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    where?: StudentSchoolScholarshipWhereInput
    orderBy?: StudentSchoolScholarshipOrderByWithRelationInput | StudentSchoolScholarshipOrderByWithRelationInput[]
    cursor?: StudentSchoolScholarshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSchoolScholarshipScalarFieldEnum | StudentSchoolScholarshipScalarFieldEnum[]
  }

  /**
   * SchoolScholarship.images
   */
  export type SchoolScholarship$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    where?: SchoolScholarshipImageWhereInput
    orderBy?: SchoolScholarshipImageOrderByWithRelationInput | SchoolScholarshipImageOrderByWithRelationInput[]
    cursor?: SchoolScholarshipImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScholarshipImageScalarFieldEnum | SchoolScholarshipImageScalarFieldEnum[]
  }

  /**
   * SchoolScholarship without action
   */
  export type SchoolScholarshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarship
     */
    select?: SchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipInclude<ExtArgs> | null
  }


  /**
   * Model SchoolScholarshipImage
   */

  export type AggregateSchoolScholarshipImage = {
    _count: SchoolScholarshipImageCountAggregateOutputType | null
    _min: SchoolScholarshipImageMinAggregateOutputType | null
    _max: SchoolScholarshipImageMaxAggregateOutputType | null
  }

  export type SchoolScholarshipImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    scholarshipId: string | null
  }

  export type SchoolScholarshipImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    scholarshipId: string | null
  }

  export type SchoolScholarshipImageCountAggregateOutputType = {
    id: number
    url: number
    scholarshipId: number
    _all: number
  }


  export type SchoolScholarshipImageMinAggregateInputType = {
    id?: true
    url?: true
    scholarshipId?: true
  }

  export type SchoolScholarshipImageMaxAggregateInputType = {
    id?: true
    url?: true
    scholarshipId?: true
  }

  export type SchoolScholarshipImageCountAggregateInputType = {
    id?: true
    url?: true
    scholarshipId?: true
    _all?: true
  }

  export type SchoolScholarshipImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolScholarshipImage to aggregate.
     */
    where?: SchoolScholarshipImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolScholarshipImages to fetch.
     */
    orderBy?: SchoolScholarshipImageOrderByWithRelationInput | SchoolScholarshipImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolScholarshipImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolScholarshipImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolScholarshipImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolScholarshipImages
    **/
    _count?: true | SchoolScholarshipImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolScholarshipImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolScholarshipImageMaxAggregateInputType
  }

  export type GetSchoolScholarshipImageAggregateType<T extends SchoolScholarshipImageAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolScholarshipImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolScholarshipImage[P]>
      : GetScalarType<T[P], AggregateSchoolScholarshipImage[P]>
  }




  export type SchoolScholarshipImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolScholarshipImageWhereInput
    orderBy?: SchoolScholarshipImageOrderByWithAggregationInput | SchoolScholarshipImageOrderByWithAggregationInput[]
    by: SchoolScholarshipImageScalarFieldEnum[] | SchoolScholarshipImageScalarFieldEnum
    having?: SchoolScholarshipImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolScholarshipImageCountAggregateInputType | true
    _min?: SchoolScholarshipImageMinAggregateInputType
    _max?: SchoolScholarshipImageMaxAggregateInputType
  }

  export type SchoolScholarshipImageGroupByOutputType = {
    id: string
    url: string
    scholarshipId: string
    _count: SchoolScholarshipImageCountAggregateOutputType | null
    _min: SchoolScholarshipImageMinAggregateOutputType | null
    _max: SchoolScholarshipImageMaxAggregateOutputType | null
  }

  type GetSchoolScholarshipImageGroupByPayload<T extends SchoolScholarshipImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolScholarshipImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolScholarshipImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolScholarshipImageGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolScholarshipImageGroupByOutputType[P]>
        }
      >
    >


  export type SchoolScholarshipImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    scholarshipId?: boolean
    scholarship?: boolean | SchoolScholarshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolScholarshipImage"]>

  export type SchoolScholarshipImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    scholarshipId?: boolean
    scholarship?: boolean | SchoolScholarshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolScholarshipImage"]>

  export type SchoolScholarshipImageSelectScalar = {
    id?: boolean
    url?: boolean
    scholarshipId?: boolean
  }

  export type SchoolScholarshipImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scholarship?: boolean | SchoolScholarshipDefaultArgs<ExtArgs>
  }
  export type SchoolScholarshipImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scholarship?: boolean | SchoolScholarshipDefaultArgs<ExtArgs>
  }

  export type $SchoolScholarshipImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolScholarshipImage"
    objects: {
      scholarship: Prisma.$SchoolScholarshipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      scholarshipId: string
    }, ExtArgs["result"]["schoolScholarshipImage"]>
    composites: {}
  }

  type SchoolScholarshipImageGetPayload<S extends boolean | null | undefined | SchoolScholarshipImageDefaultArgs> = $Result.GetResult<Prisma.$SchoolScholarshipImagePayload, S>

  type SchoolScholarshipImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolScholarshipImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolScholarshipImageCountAggregateInputType | true
    }

  export interface SchoolScholarshipImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolScholarshipImage'], meta: { name: 'SchoolScholarshipImage' } }
    /**
     * Find zero or one SchoolScholarshipImage that matches the filter.
     * @param {SchoolScholarshipImageFindUniqueArgs} args - Arguments to find a SchoolScholarshipImage
     * @example
     * // Get one SchoolScholarshipImage
     * const schoolScholarshipImage = await prisma.schoolScholarshipImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolScholarshipImageFindUniqueArgs>(args: SelectSubset<T, SchoolScholarshipImageFindUniqueArgs<ExtArgs>>): Prisma__SchoolScholarshipImageClient<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolScholarshipImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolScholarshipImageFindUniqueOrThrowArgs} args - Arguments to find a SchoolScholarshipImage
     * @example
     * // Get one SchoolScholarshipImage
     * const schoolScholarshipImage = await prisma.schoolScholarshipImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolScholarshipImageFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolScholarshipImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolScholarshipImageClient<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolScholarshipImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipImageFindFirstArgs} args - Arguments to find a SchoolScholarshipImage
     * @example
     * // Get one SchoolScholarshipImage
     * const schoolScholarshipImage = await prisma.schoolScholarshipImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolScholarshipImageFindFirstArgs>(args?: SelectSubset<T, SchoolScholarshipImageFindFirstArgs<ExtArgs>>): Prisma__SchoolScholarshipImageClient<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolScholarshipImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipImageFindFirstOrThrowArgs} args - Arguments to find a SchoolScholarshipImage
     * @example
     * // Get one SchoolScholarshipImage
     * const schoolScholarshipImage = await prisma.schoolScholarshipImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolScholarshipImageFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolScholarshipImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolScholarshipImageClient<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolScholarshipImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolScholarshipImages
     * const schoolScholarshipImages = await prisma.schoolScholarshipImage.findMany()
     * 
     * // Get first 10 SchoolScholarshipImages
     * const schoolScholarshipImages = await prisma.schoolScholarshipImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolScholarshipImageWithIdOnly = await prisma.schoolScholarshipImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolScholarshipImageFindManyArgs>(args?: SelectSubset<T, SchoolScholarshipImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolScholarshipImage.
     * @param {SchoolScholarshipImageCreateArgs} args - Arguments to create a SchoolScholarshipImage.
     * @example
     * // Create one SchoolScholarshipImage
     * const SchoolScholarshipImage = await prisma.schoolScholarshipImage.create({
     *   data: {
     *     // ... data to create a SchoolScholarshipImage
     *   }
     * })
     * 
     */
    create<T extends SchoolScholarshipImageCreateArgs>(args: SelectSubset<T, SchoolScholarshipImageCreateArgs<ExtArgs>>): Prisma__SchoolScholarshipImageClient<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolScholarshipImages.
     * @param {SchoolScholarshipImageCreateManyArgs} args - Arguments to create many SchoolScholarshipImages.
     * @example
     * // Create many SchoolScholarshipImages
     * const schoolScholarshipImage = await prisma.schoolScholarshipImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolScholarshipImageCreateManyArgs>(args?: SelectSubset<T, SchoolScholarshipImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolScholarshipImages and returns the data saved in the database.
     * @param {SchoolScholarshipImageCreateManyAndReturnArgs} args - Arguments to create many SchoolScholarshipImages.
     * @example
     * // Create many SchoolScholarshipImages
     * const schoolScholarshipImage = await prisma.schoolScholarshipImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolScholarshipImages and only return the `id`
     * const schoolScholarshipImageWithIdOnly = await prisma.schoolScholarshipImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolScholarshipImageCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolScholarshipImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolScholarshipImage.
     * @param {SchoolScholarshipImageDeleteArgs} args - Arguments to delete one SchoolScholarshipImage.
     * @example
     * // Delete one SchoolScholarshipImage
     * const SchoolScholarshipImage = await prisma.schoolScholarshipImage.delete({
     *   where: {
     *     // ... filter to delete one SchoolScholarshipImage
     *   }
     * })
     * 
     */
    delete<T extends SchoolScholarshipImageDeleteArgs>(args: SelectSubset<T, SchoolScholarshipImageDeleteArgs<ExtArgs>>): Prisma__SchoolScholarshipImageClient<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolScholarshipImage.
     * @param {SchoolScholarshipImageUpdateArgs} args - Arguments to update one SchoolScholarshipImage.
     * @example
     * // Update one SchoolScholarshipImage
     * const schoolScholarshipImage = await prisma.schoolScholarshipImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolScholarshipImageUpdateArgs>(args: SelectSubset<T, SchoolScholarshipImageUpdateArgs<ExtArgs>>): Prisma__SchoolScholarshipImageClient<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolScholarshipImages.
     * @param {SchoolScholarshipImageDeleteManyArgs} args - Arguments to filter SchoolScholarshipImages to delete.
     * @example
     * // Delete a few SchoolScholarshipImages
     * const { count } = await prisma.schoolScholarshipImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolScholarshipImageDeleteManyArgs>(args?: SelectSubset<T, SchoolScholarshipImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolScholarshipImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolScholarshipImages
     * const schoolScholarshipImage = await prisma.schoolScholarshipImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolScholarshipImageUpdateManyArgs>(args: SelectSubset<T, SchoolScholarshipImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolScholarshipImage.
     * @param {SchoolScholarshipImageUpsertArgs} args - Arguments to update or create a SchoolScholarshipImage.
     * @example
     * // Update or create a SchoolScholarshipImage
     * const schoolScholarshipImage = await prisma.schoolScholarshipImage.upsert({
     *   create: {
     *     // ... data to create a SchoolScholarshipImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolScholarshipImage we want to update
     *   }
     * })
     */
    upsert<T extends SchoolScholarshipImageUpsertArgs>(args: SelectSubset<T, SchoolScholarshipImageUpsertArgs<ExtArgs>>): Prisma__SchoolScholarshipImageClient<$Result.GetResult<Prisma.$SchoolScholarshipImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolScholarshipImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipImageCountArgs} args - Arguments to filter SchoolScholarshipImages to count.
     * @example
     * // Count the number of SchoolScholarshipImages
     * const count = await prisma.schoolScholarshipImage.count({
     *   where: {
     *     // ... the filter for the SchoolScholarshipImages we want to count
     *   }
     * })
    **/
    count<T extends SchoolScholarshipImageCountArgs>(
      args?: Subset<T, SchoolScholarshipImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolScholarshipImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolScholarshipImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolScholarshipImageAggregateArgs>(args: Subset<T, SchoolScholarshipImageAggregateArgs>): Prisma.PrismaPromise<GetSchoolScholarshipImageAggregateType<T>>

    /**
     * Group by SchoolScholarshipImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolScholarshipImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolScholarshipImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolScholarshipImageGroupByArgs['orderBy'] }
        : { orderBy?: SchoolScholarshipImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolScholarshipImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolScholarshipImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolScholarshipImage model
   */
  readonly fields: SchoolScholarshipImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolScholarshipImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolScholarshipImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scholarship<T extends SchoolScholarshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolScholarshipDefaultArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolScholarshipImage model
   */ 
  interface SchoolScholarshipImageFieldRefs {
    readonly id: FieldRef<"SchoolScholarshipImage", 'String'>
    readonly url: FieldRef<"SchoolScholarshipImage", 'String'>
    readonly scholarshipId: FieldRef<"SchoolScholarshipImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SchoolScholarshipImage findUnique
   */
  export type SchoolScholarshipImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarshipImage to fetch.
     */
    where: SchoolScholarshipImageWhereUniqueInput
  }

  /**
   * SchoolScholarshipImage findUniqueOrThrow
   */
  export type SchoolScholarshipImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarshipImage to fetch.
     */
    where: SchoolScholarshipImageWhereUniqueInput
  }

  /**
   * SchoolScholarshipImage findFirst
   */
  export type SchoolScholarshipImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarshipImage to fetch.
     */
    where?: SchoolScholarshipImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolScholarshipImages to fetch.
     */
    orderBy?: SchoolScholarshipImageOrderByWithRelationInput | SchoolScholarshipImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolScholarshipImages.
     */
    cursor?: SchoolScholarshipImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolScholarshipImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolScholarshipImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolScholarshipImages.
     */
    distinct?: SchoolScholarshipImageScalarFieldEnum | SchoolScholarshipImageScalarFieldEnum[]
  }

  /**
   * SchoolScholarshipImage findFirstOrThrow
   */
  export type SchoolScholarshipImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarshipImage to fetch.
     */
    where?: SchoolScholarshipImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolScholarshipImages to fetch.
     */
    orderBy?: SchoolScholarshipImageOrderByWithRelationInput | SchoolScholarshipImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolScholarshipImages.
     */
    cursor?: SchoolScholarshipImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolScholarshipImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolScholarshipImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolScholarshipImages.
     */
    distinct?: SchoolScholarshipImageScalarFieldEnum | SchoolScholarshipImageScalarFieldEnum[]
  }

  /**
   * SchoolScholarshipImage findMany
   */
  export type SchoolScholarshipImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolScholarshipImages to fetch.
     */
    where?: SchoolScholarshipImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolScholarshipImages to fetch.
     */
    orderBy?: SchoolScholarshipImageOrderByWithRelationInput | SchoolScholarshipImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolScholarshipImages.
     */
    cursor?: SchoolScholarshipImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolScholarshipImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolScholarshipImages.
     */
    skip?: number
    distinct?: SchoolScholarshipImageScalarFieldEnum | SchoolScholarshipImageScalarFieldEnum[]
  }

  /**
   * SchoolScholarshipImage create
   */
  export type SchoolScholarshipImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolScholarshipImage.
     */
    data: XOR<SchoolScholarshipImageCreateInput, SchoolScholarshipImageUncheckedCreateInput>
  }

  /**
   * SchoolScholarshipImage createMany
   */
  export type SchoolScholarshipImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolScholarshipImages.
     */
    data: SchoolScholarshipImageCreateManyInput | SchoolScholarshipImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolScholarshipImage createManyAndReturn
   */
  export type SchoolScholarshipImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolScholarshipImages.
     */
    data: SchoolScholarshipImageCreateManyInput | SchoolScholarshipImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolScholarshipImage update
   */
  export type SchoolScholarshipImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolScholarshipImage.
     */
    data: XOR<SchoolScholarshipImageUpdateInput, SchoolScholarshipImageUncheckedUpdateInput>
    /**
     * Choose, which SchoolScholarshipImage to update.
     */
    where: SchoolScholarshipImageWhereUniqueInput
  }

  /**
   * SchoolScholarshipImage updateMany
   */
  export type SchoolScholarshipImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolScholarshipImages.
     */
    data: XOR<SchoolScholarshipImageUpdateManyMutationInput, SchoolScholarshipImageUncheckedUpdateManyInput>
    /**
     * Filter which SchoolScholarshipImages to update
     */
    where?: SchoolScholarshipImageWhereInput
  }

  /**
   * SchoolScholarshipImage upsert
   */
  export type SchoolScholarshipImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolScholarshipImage to update in case it exists.
     */
    where: SchoolScholarshipImageWhereUniqueInput
    /**
     * In case the SchoolScholarshipImage found by the `where` argument doesn't exist, create a new SchoolScholarshipImage with this data.
     */
    create: XOR<SchoolScholarshipImageCreateInput, SchoolScholarshipImageUncheckedCreateInput>
    /**
     * In case the SchoolScholarshipImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolScholarshipImageUpdateInput, SchoolScholarshipImageUncheckedUpdateInput>
  }

  /**
   * SchoolScholarshipImage delete
   */
  export type SchoolScholarshipImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
    /**
     * Filter which SchoolScholarshipImage to delete.
     */
    where: SchoolScholarshipImageWhereUniqueInput
  }

  /**
   * SchoolScholarshipImage deleteMany
   */
  export type SchoolScholarshipImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolScholarshipImages to delete
     */
    where?: SchoolScholarshipImageWhereInput
  }

  /**
   * SchoolScholarshipImage without action
   */
  export type SchoolScholarshipImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolScholarshipImage
     */
    select?: SchoolScholarshipImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolScholarshipImageInclude<ExtArgs> | null
  }


  /**
   * Model StudentSchoolScholarship
   */

  export type AggregateStudentSchoolScholarship = {
    _count: StudentSchoolScholarshipCountAggregateOutputType | null
    _min: StudentSchoolScholarshipMinAggregateOutputType | null
    _max: StudentSchoolScholarshipMaxAggregateOutputType | null
  }

  export type StudentSchoolScholarshipMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    scholarshipId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSchoolScholarshipMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    scholarshipId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSchoolScholarshipCountAggregateOutputType = {
    id: number
    studentId: number
    scholarshipId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentSchoolScholarshipMinAggregateInputType = {
    id?: true
    studentId?: true
    scholarshipId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSchoolScholarshipMaxAggregateInputType = {
    id?: true
    studentId?: true
    scholarshipId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSchoolScholarshipCountAggregateInputType = {
    id?: true
    studentId?: true
    scholarshipId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentSchoolScholarshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSchoolScholarship to aggregate.
     */
    where?: StudentSchoolScholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolScholarships to fetch.
     */
    orderBy?: StudentSchoolScholarshipOrderByWithRelationInput | StudentSchoolScholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSchoolScholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolScholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolScholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSchoolScholarships
    **/
    _count?: true | StudentSchoolScholarshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSchoolScholarshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSchoolScholarshipMaxAggregateInputType
  }

  export type GetStudentSchoolScholarshipAggregateType<T extends StudentSchoolScholarshipAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSchoolScholarship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSchoolScholarship[P]>
      : GetScalarType<T[P], AggregateStudentSchoolScholarship[P]>
  }




  export type StudentSchoolScholarshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSchoolScholarshipWhereInput
    orderBy?: StudentSchoolScholarshipOrderByWithAggregationInput | StudentSchoolScholarshipOrderByWithAggregationInput[]
    by: StudentSchoolScholarshipScalarFieldEnum[] | StudentSchoolScholarshipScalarFieldEnum
    having?: StudentSchoolScholarshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSchoolScholarshipCountAggregateInputType | true
    _min?: StudentSchoolScholarshipMinAggregateInputType
    _max?: StudentSchoolScholarshipMaxAggregateInputType
  }

  export type StudentSchoolScholarshipGroupByOutputType = {
    id: string
    studentId: string
    scholarshipId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentSchoolScholarshipCountAggregateOutputType | null
    _min: StudentSchoolScholarshipMinAggregateOutputType | null
    _max: StudentSchoolScholarshipMaxAggregateOutputType | null
  }

  type GetStudentSchoolScholarshipGroupByPayload<T extends StudentSchoolScholarshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSchoolScholarshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSchoolScholarshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSchoolScholarshipGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSchoolScholarshipGroupByOutputType[P]>
        }
      >
    >


  export type StudentSchoolScholarshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    scholarshipId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    scholarship?: boolean | SchoolScholarshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSchoolScholarship"]>

  export type StudentSchoolScholarshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    scholarshipId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    scholarship?: boolean | SchoolScholarshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSchoolScholarship"]>

  export type StudentSchoolScholarshipSelectScalar = {
    id?: boolean
    studentId?: boolean
    scholarshipId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentSchoolScholarshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    scholarship?: boolean | SchoolScholarshipDefaultArgs<ExtArgs>
  }
  export type StudentSchoolScholarshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    scholarship?: boolean | SchoolScholarshipDefaultArgs<ExtArgs>
  }

  export type $StudentSchoolScholarshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSchoolScholarship"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      scholarship: Prisma.$SchoolScholarshipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      scholarshipId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentSchoolScholarship"]>
    composites: {}
  }

  type StudentSchoolScholarshipGetPayload<S extends boolean | null | undefined | StudentSchoolScholarshipDefaultArgs> = $Result.GetResult<Prisma.$StudentSchoolScholarshipPayload, S>

  type StudentSchoolScholarshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentSchoolScholarshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentSchoolScholarshipCountAggregateInputType | true
    }

  export interface StudentSchoolScholarshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSchoolScholarship'], meta: { name: 'StudentSchoolScholarship' } }
    /**
     * Find zero or one StudentSchoolScholarship that matches the filter.
     * @param {StudentSchoolScholarshipFindUniqueArgs} args - Arguments to find a StudentSchoolScholarship
     * @example
     * // Get one StudentSchoolScholarship
     * const studentSchoolScholarship = await prisma.studentSchoolScholarship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSchoolScholarshipFindUniqueArgs>(args: SelectSubset<T, StudentSchoolScholarshipFindUniqueArgs<ExtArgs>>): Prisma__StudentSchoolScholarshipClient<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentSchoolScholarship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentSchoolScholarshipFindUniqueOrThrowArgs} args - Arguments to find a StudentSchoolScholarship
     * @example
     * // Get one StudentSchoolScholarship
     * const studentSchoolScholarship = await prisma.studentSchoolScholarship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSchoolScholarshipFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSchoolScholarshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSchoolScholarshipClient<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentSchoolScholarship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolScholarshipFindFirstArgs} args - Arguments to find a StudentSchoolScholarship
     * @example
     * // Get one StudentSchoolScholarship
     * const studentSchoolScholarship = await prisma.studentSchoolScholarship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSchoolScholarshipFindFirstArgs>(args?: SelectSubset<T, StudentSchoolScholarshipFindFirstArgs<ExtArgs>>): Prisma__StudentSchoolScholarshipClient<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentSchoolScholarship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolScholarshipFindFirstOrThrowArgs} args - Arguments to find a StudentSchoolScholarship
     * @example
     * // Get one StudentSchoolScholarship
     * const studentSchoolScholarship = await prisma.studentSchoolScholarship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSchoolScholarshipFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSchoolScholarshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSchoolScholarshipClient<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentSchoolScholarships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolScholarshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSchoolScholarships
     * const studentSchoolScholarships = await prisma.studentSchoolScholarship.findMany()
     * 
     * // Get first 10 StudentSchoolScholarships
     * const studentSchoolScholarships = await prisma.studentSchoolScholarship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSchoolScholarshipWithIdOnly = await prisma.studentSchoolScholarship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSchoolScholarshipFindManyArgs>(args?: SelectSubset<T, StudentSchoolScholarshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentSchoolScholarship.
     * @param {StudentSchoolScholarshipCreateArgs} args - Arguments to create a StudentSchoolScholarship.
     * @example
     * // Create one StudentSchoolScholarship
     * const StudentSchoolScholarship = await prisma.studentSchoolScholarship.create({
     *   data: {
     *     // ... data to create a StudentSchoolScholarship
     *   }
     * })
     * 
     */
    create<T extends StudentSchoolScholarshipCreateArgs>(args: SelectSubset<T, StudentSchoolScholarshipCreateArgs<ExtArgs>>): Prisma__StudentSchoolScholarshipClient<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentSchoolScholarships.
     * @param {StudentSchoolScholarshipCreateManyArgs} args - Arguments to create many StudentSchoolScholarships.
     * @example
     * // Create many StudentSchoolScholarships
     * const studentSchoolScholarship = await prisma.studentSchoolScholarship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSchoolScholarshipCreateManyArgs>(args?: SelectSubset<T, StudentSchoolScholarshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentSchoolScholarships and returns the data saved in the database.
     * @param {StudentSchoolScholarshipCreateManyAndReturnArgs} args - Arguments to create many StudentSchoolScholarships.
     * @example
     * // Create many StudentSchoolScholarships
     * const studentSchoolScholarship = await prisma.studentSchoolScholarship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentSchoolScholarships and only return the `id`
     * const studentSchoolScholarshipWithIdOnly = await prisma.studentSchoolScholarship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentSchoolScholarshipCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentSchoolScholarshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentSchoolScholarship.
     * @param {StudentSchoolScholarshipDeleteArgs} args - Arguments to delete one StudentSchoolScholarship.
     * @example
     * // Delete one StudentSchoolScholarship
     * const StudentSchoolScholarship = await prisma.studentSchoolScholarship.delete({
     *   where: {
     *     // ... filter to delete one StudentSchoolScholarship
     *   }
     * })
     * 
     */
    delete<T extends StudentSchoolScholarshipDeleteArgs>(args: SelectSubset<T, StudentSchoolScholarshipDeleteArgs<ExtArgs>>): Prisma__StudentSchoolScholarshipClient<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentSchoolScholarship.
     * @param {StudentSchoolScholarshipUpdateArgs} args - Arguments to update one StudentSchoolScholarship.
     * @example
     * // Update one StudentSchoolScholarship
     * const studentSchoolScholarship = await prisma.studentSchoolScholarship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSchoolScholarshipUpdateArgs>(args: SelectSubset<T, StudentSchoolScholarshipUpdateArgs<ExtArgs>>): Prisma__StudentSchoolScholarshipClient<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentSchoolScholarships.
     * @param {StudentSchoolScholarshipDeleteManyArgs} args - Arguments to filter StudentSchoolScholarships to delete.
     * @example
     * // Delete a few StudentSchoolScholarships
     * const { count } = await prisma.studentSchoolScholarship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSchoolScholarshipDeleteManyArgs>(args?: SelectSubset<T, StudentSchoolScholarshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSchoolScholarships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolScholarshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSchoolScholarships
     * const studentSchoolScholarship = await prisma.studentSchoolScholarship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSchoolScholarshipUpdateManyArgs>(args: SelectSubset<T, StudentSchoolScholarshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSchoolScholarship.
     * @param {StudentSchoolScholarshipUpsertArgs} args - Arguments to update or create a StudentSchoolScholarship.
     * @example
     * // Update or create a StudentSchoolScholarship
     * const studentSchoolScholarship = await prisma.studentSchoolScholarship.upsert({
     *   create: {
     *     // ... data to create a StudentSchoolScholarship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSchoolScholarship we want to update
     *   }
     * })
     */
    upsert<T extends StudentSchoolScholarshipUpsertArgs>(args: SelectSubset<T, StudentSchoolScholarshipUpsertArgs<ExtArgs>>): Prisma__StudentSchoolScholarshipClient<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentSchoolScholarships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolScholarshipCountArgs} args - Arguments to filter StudentSchoolScholarships to count.
     * @example
     * // Count the number of StudentSchoolScholarships
     * const count = await prisma.studentSchoolScholarship.count({
     *   where: {
     *     // ... the filter for the StudentSchoolScholarships we want to count
     *   }
     * })
    **/
    count<T extends StudentSchoolScholarshipCountArgs>(
      args?: Subset<T, StudentSchoolScholarshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSchoolScholarshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSchoolScholarship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolScholarshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSchoolScholarshipAggregateArgs>(args: Subset<T, StudentSchoolScholarshipAggregateArgs>): Prisma.PrismaPromise<GetStudentSchoolScholarshipAggregateType<T>>

    /**
     * Group by StudentSchoolScholarship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolScholarshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSchoolScholarshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSchoolScholarshipGroupByArgs['orderBy'] }
        : { orderBy?: StudentSchoolScholarshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSchoolScholarshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSchoolScholarshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSchoolScholarship model
   */
  readonly fields: StudentSchoolScholarshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSchoolScholarship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSchoolScholarshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    scholarship<T extends SchoolScholarshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolScholarshipDefaultArgs<ExtArgs>>): Prisma__SchoolScholarshipClient<$Result.GetResult<Prisma.$SchoolScholarshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSchoolScholarship model
   */ 
  interface StudentSchoolScholarshipFieldRefs {
    readonly id: FieldRef<"StudentSchoolScholarship", 'String'>
    readonly studentId: FieldRef<"StudentSchoolScholarship", 'String'>
    readonly scholarshipId: FieldRef<"StudentSchoolScholarship", 'String'>
    readonly createdAt: FieldRef<"StudentSchoolScholarship", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSchoolScholarship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentSchoolScholarship findUnique
   */
  export type StudentSchoolScholarshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolScholarship to fetch.
     */
    where: StudentSchoolScholarshipWhereUniqueInput
  }

  /**
   * StudentSchoolScholarship findUniqueOrThrow
   */
  export type StudentSchoolScholarshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolScholarship to fetch.
     */
    where: StudentSchoolScholarshipWhereUniqueInput
  }

  /**
   * StudentSchoolScholarship findFirst
   */
  export type StudentSchoolScholarshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolScholarship to fetch.
     */
    where?: StudentSchoolScholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolScholarships to fetch.
     */
    orderBy?: StudentSchoolScholarshipOrderByWithRelationInput | StudentSchoolScholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSchoolScholarships.
     */
    cursor?: StudentSchoolScholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolScholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolScholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSchoolScholarships.
     */
    distinct?: StudentSchoolScholarshipScalarFieldEnum | StudentSchoolScholarshipScalarFieldEnum[]
  }

  /**
   * StudentSchoolScholarship findFirstOrThrow
   */
  export type StudentSchoolScholarshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolScholarship to fetch.
     */
    where?: StudentSchoolScholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolScholarships to fetch.
     */
    orderBy?: StudentSchoolScholarshipOrderByWithRelationInput | StudentSchoolScholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSchoolScholarships.
     */
    cursor?: StudentSchoolScholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolScholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolScholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSchoolScholarships.
     */
    distinct?: StudentSchoolScholarshipScalarFieldEnum | StudentSchoolScholarshipScalarFieldEnum[]
  }

  /**
   * StudentSchoolScholarship findMany
   */
  export type StudentSchoolScholarshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolScholarships to fetch.
     */
    where?: StudentSchoolScholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolScholarships to fetch.
     */
    orderBy?: StudentSchoolScholarshipOrderByWithRelationInput | StudentSchoolScholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSchoolScholarships.
     */
    cursor?: StudentSchoolScholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolScholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolScholarships.
     */
    skip?: number
    distinct?: StudentSchoolScholarshipScalarFieldEnum | StudentSchoolScholarshipScalarFieldEnum[]
  }

  /**
   * StudentSchoolScholarship create
   */
  export type StudentSchoolScholarshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSchoolScholarship.
     */
    data: XOR<StudentSchoolScholarshipCreateInput, StudentSchoolScholarshipUncheckedCreateInput>
  }

  /**
   * StudentSchoolScholarship createMany
   */
  export type StudentSchoolScholarshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSchoolScholarships.
     */
    data: StudentSchoolScholarshipCreateManyInput | StudentSchoolScholarshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSchoolScholarship createManyAndReturn
   */
  export type StudentSchoolScholarshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentSchoolScholarships.
     */
    data: StudentSchoolScholarshipCreateManyInput | StudentSchoolScholarshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSchoolScholarship update
   */
  export type StudentSchoolScholarshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSchoolScholarship.
     */
    data: XOR<StudentSchoolScholarshipUpdateInput, StudentSchoolScholarshipUncheckedUpdateInput>
    /**
     * Choose, which StudentSchoolScholarship to update.
     */
    where: StudentSchoolScholarshipWhereUniqueInput
  }

  /**
   * StudentSchoolScholarship updateMany
   */
  export type StudentSchoolScholarshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSchoolScholarships.
     */
    data: XOR<StudentSchoolScholarshipUpdateManyMutationInput, StudentSchoolScholarshipUncheckedUpdateManyInput>
    /**
     * Filter which StudentSchoolScholarships to update
     */
    where?: StudentSchoolScholarshipWhereInput
  }

  /**
   * StudentSchoolScholarship upsert
   */
  export type StudentSchoolScholarshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSchoolScholarship to update in case it exists.
     */
    where: StudentSchoolScholarshipWhereUniqueInput
    /**
     * In case the StudentSchoolScholarship found by the `where` argument doesn't exist, create a new StudentSchoolScholarship with this data.
     */
    create: XOR<StudentSchoolScholarshipCreateInput, StudentSchoolScholarshipUncheckedCreateInput>
    /**
     * In case the StudentSchoolScholarship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSchoolScholarshipUpdateInput, StudentSchoolScholarshipUncheckedUpdateInput>
  }

  /**
   * StudentSchoolScholarship delete
   */
  export type StudentSchoolScholarshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    /**
     * Filter which StudentSchoolScholarship to delete.
     */
    where: StudentSchoolScholarshipWhereUniqueInput
  }

  /**
   * StudentSchoolScholarship deleteMany
   */
  export type StudentSchoolScholarshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSchoolScholarships to delete
     */
    where?: StudentSchoolScholarshipWhereInput
  }

  /**
   * StudentSchoolScholarship without action
   */
  export type StudentSchoolScholarshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
  }


  /**
   * Model SchoolGallery
   */

  export type AggregateSchoolGallery = {
    _count: SchoolGalleryCountAggregateOutputType | null
    _min: SchoolGalleryMinAggregateOutputType | null
    _max: SchoolGalleryMaxAggregateOutputType | null
  }

  export type SchoolGalleryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolGalleryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolGalleryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolGalleryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolGalleryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolGalleryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolGalleryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolGallery to aggregate.
     */
    where?: SchoolGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolGalleries to fetch.
     */
    orderBy?: SchoolGalleryOrderByWithRelationInput | SchoolGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolGalleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolGalleries
    **/
    _count?: true | SchoolGalleryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolGalleryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolGalleryMaxAggregateInputType
  }

  export type GetSchoolGalleryAggregateType<T extends SchoolGalleryAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolGallery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolGallery[P]>
      : GetScalarType<T[P], AggregateSchoolGallery[P]>
  }




  export type SchoolGalleryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolGalleryWhereInput
    orderBy?: SchoolGalleryOrderByWithAggregationInput | SchoolGalleryOrderByWithAggregationInput[]
    by: SchoolGalleryScalarFieldEnum[] | SchoolGalleryScalarFieldEnum
    having?: SchoolGalleryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolGalleryCountAggregateInputType | true
    _min?: SchoolGalleryMinAggregateInputType
    _max?: SchoolGalleryMaxAggregateInputType
  }

  export type SchoolGalleryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolGalleryCountAggregateOutputType | null
    _min: SchoolGalleryMinAggregateOutputType | null
    _max: SchoolGalleryMaxAggregateOutputType | null
  }

  type GetSchoolGalleryGroupByPayload<T extends SchoolGalleryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGalleryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGalleryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGalleryGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGalleryGroupByOutputType[P]>
        }
      >
    >


  export type SchoolGallerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | SchoolGallery$imagesArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    _count?: boolean | SchoolGalleryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolGallery"]>

  export type SchoolGallerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolGallery"]>

  export type SchoolGallerySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolGalleryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | SchoolGallery$imagesArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    _count?: boolean | SchoolGalleryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolGalleryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolGalleryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolGallery"
    objects: {
      images: Prisma.$SchoolGalleryImagePayload<ExtArgs>[]
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolGallery"]>
    composites: {}
  }

  type SchoolGalleryGetPayload<S extends boolean | null | undefined | SchoolGalleryDefaultArgs> = $Result.GetResult<Prisma.$SchoolGalleryPayload, S>

  type SchoolGalleryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolGalleryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolGalleryCountAggregateInputType | true
    }

  export interface SchoolGalleryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolGallery'], meta: { name: 'SchoolGallery' } }
    /**
     * Find zero or one SchoolGallery that matches the filter.
     * @param {SchoolGalleryFindUniqueArgs} args - Arguments to find a SchoolGallery
     * @example
     * // Get one SchoolGallery
     * const schoolGallery = await prisma.schoolGallery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolGalleryFindUniqueArgs>(args: SelectSubset<T, SchoolGalleryFindUniqueArgs<ExtArgs>>): Prisma__SchoolGalleryClient<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolGallery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolGalleryFindUniqueOrThrowArgs} args - Arguments to find a SchoolGallery
     * @example
     * // Get one SchoolGallery
     * const schoolGallery = await prisma.schoolGallery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolGalleryFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolGalleryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolGalleryClient<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolGallery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryFindFirstArgs} args - Arguments to find a SchoolGallery
     * @example
     * // Get one SchoolGallery
     * const schoolGallery = await prisma.schoolGallery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolGalleryFindFirstArgs>(args?: SelectSubset<T, SchoolGalleryFindFirstArgs<ExtArgs>>): Prisma__SchoolGalleryClient<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolGallery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryFindFirstOrThrowArgs} args - Arguments to find a SchoolGallery
     * @example
     * // Get one SchoolGallery
     * const schoolGallery = await prisma.schoolGallery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolGalleryFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolGalleryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolGalleryClient<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolGalleries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolGalleries
     * const schoolGalleries = await prisma.schoolGallery.findMany()
     * 
     * // Get first 10 SchoolGalleries
     * const schoolGalleries = await prisma.schoolGallery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolGalleryWithIdOnly = await prisma.schoolGallery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolGalleryFindManyArgs>(args?: SelectSubset<T, SchoolGalleryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolGallery.
     * @param {SchoolGalleryCreateArgs} args - Arguments to create a SchoolGallery.
     * @example
     * // Create one SchoolGallery
     * const SchoolGallery = await prisma.schoolGallery.create({
     *   data: {
     *     // ... data to create a SchoolGallery
     *   }
     * })
     * 
     */
    create<T extends SchoolGalleryCreateArgs>(args: SelectSubset<T, SchoolGalleryCreateArgs<ExtArgs>>): Prisma__SchoolGalleryClient<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolGalleries.
     * @param {SchoolGalleryCreateManyArgs} args - Arguments to create many SchoolGalleries.
     * @example
     * // Create many SchoolGalleries
     * const schoolGallery = await prisma.schoolGallery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolGalleryCreateManyArgs>(args?: SelectSubset<T, SchoolGalleryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolGalleries and returns the data saved in the database.
     * @param {SchoolGalleryCreateManyAndReturnArgs} args - Arguments to create many SchoolGalleries.
     * @example
     * // Create many SchoolGalleries
     * const schoolGallery = await prisma.schoolGallery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolGalleries and only return the `id`
     * const schoolGalleryWithIdOnly = await prisma.schoolGallery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolGalleryCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolGalleryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolGallery.
     * @param {SchoolGalleryDeleteArgs} args - Arguments to delete one SchoolGallery.
     * @example
     * // Delete one SchoolGallery
     * const SchoolGallery = await prisma.schoolGallery.delete({
     *   where: {
     *     // ... filter to delete one SchoolGallery
     *   }
     * })
     * 
     */
    delete<T extends SchoolGalleryDeleteArgs>(args: SelectSubset<T, SchoolGalleryDeleteArgs<ExtArgs>>): Prisma__SchoolGalleryClient<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolGallery.
     * @param {SchoolGalleryUpdateArgs} args - Arguments to update one SchoolGallery.
     * @example
     * // Update one SchoolGallery
     * const schoolGallery = await prisma.schoolGallery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolGalleryUpdateArgs>(args: SelectSubset<T, SchoolGalleryUpdateArgs<ExtArgs>>): Prisma__SchoolGalleryClient<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolGalleries.
     * @param {SchoolGalleryDeleteManyArgs} args - Arguments to filter SchoolGalleries to delete.
     * @example
     * // Delete a few SchoolGalleries
     * const { count } = await prisma.schoolGallery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolGalleryDeleteManyArgs>(args?: SelectSubset<T, SchoolGalleryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolGalleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolGalleries
     * const schoolGallery = await prisma.schoolGallery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolGalleryUpdateManyArgs>(args: SelectSubset<T, SchoolGalleryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolGallery.
     * @param {SchoolGalleryUpsertArgs} args - Arguments to update or create a SchoolGallery.
     * @example
     * // Update or create a SchoolGallery
     * const schoolGallery = await prisma.schoolGallery.upsert({
     *   create: {
     *     // ... data to create a SchoolGallery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolGallery we want to update
     *   }
     * })
     */
    upsert<T extends SchoolGalleryUpsertArgs>(args: SelectSubset<T, SchoolGalleryUpsertArgs<ExtArgs>>): Prisma__SchoolGalleryClient<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolGalleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryCountArgs} args - Arguments to filter SchoolGalleries to count.
     * @example
     * // Count the number of SchoolGalleries
     * const count = await prisma.schoolGallery.count({
     *   where: {
     *     // ... the filter for the SchoolGalleries we want to count
     *   }
     * })
    **/
    count<T extends SchoolGalleryCountArgs>(
      args?: Subset<T, SchoolGalleryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolGalleryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolGallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolGalleryAggregateArgs>(args: Subset<T, SchoolGalleryAggregateArgs>): Prisma.PrismaPromise<GetSchoolGalleryAggregateType<T>>

    /**
     * Group by SchoolGallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGalleryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGalleryGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGalleryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGalleryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGalleryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolGallery model
   */
  readonly fields: SchoolGalleryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolGallery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolGalleryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends SchoolGallery$imagesArgs<ExtArgs> = {}>(args?: Subset<T, SchoolGallery$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "findMany"> | Null>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolGallery model
   */ 
  interface SchoolGalleryFieldRefs {
    readonly id: FieldRef<"SchoolGallery", 'String'>
    readonly name: FieldRef<"SchoolGallery", 'String'>
    readonly description: FieldRef<"SchoolGallery", 'String'>
    readonly schoolId: FieldRef<"SchoolGallery", 'String'>
    readonly createdAt: FieldRef<"SchoolGallery", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolGallery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolGallery findUnique
   */
  export type SchoolGalleryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGallery to fetch.
     */
    where: SchoolGalleryWhereUniqueInput
  }

  /**
   * SchoolGallery findUniqueOrThrow
   */
  export type SchoolGalleryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGallery to fetch.
     */
    where: SchoolGalleryWhereUniqueInput
  }

  /**
   * SchoolGallery findFirst
   */
  export type SchoolGalleryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGallery to fetch.
     */
    where?: SchoolGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolGalleries to fetch.
     */
    orderBy?: SchoolGalleryOrderByWithRelationInput | SchoolGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolGalleries.
     */
    cursor?: SchoolGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolGalleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolGalleries.
     */
    distinct?: SchoolGalleryScalarFieldEnum | SchoolGalleryScalarFieldEnum[]
  }

  /**
   * SchoolGallery findFirstOrThrow
   */
  export type SchoolGalleryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGallery to fetch.
     */
    where?: SchoolGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolGalleries to fetch.
     */
    orderBy?: SchoolGalleryOrderByWithRelationInput | SchoolGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolGalleries.
     */
    cursor?: SchoolGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolGalleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolGalleries.
     */
    distinct?: SchoolGalleryScalarFieldEnum | SchoolGalleryScalarFieldEnum[]
  }

  /**
   * SchoolGallery findMany
   */
  export type SchoolGalleryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGalleries to fetch.
     */
    where?: SchoolGalleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolGalleries to fetch.
     */
    orderBy?: SchoolGalleryOrderByWithRelationInput | SchoolGalleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolGalleries.
     */
    cursor?: SchoolGalleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolGalleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolGalleries.
     */
    skip?: number
    distinct?: SchoolGalleryScalarFieldEnum | SchoolGalleryScalarFieldEnum[]
  }

  /**
   * SchoolGallery create
   */
  export type SchoolGalleryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolGallery.
     */
    data: XOR<SchoolGalleryCreateInput, SchoolGalleryUncheckedCreateInput>
  }

  /**
   * SchoolGallery createMany
   */
  export type SchoolGalleryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolGalleries.
     */
    data: SchoolGalleryCreateManyInput | SchoolGalleryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolGallery createManyAndReturn
   */
  export type SchoolGalleryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolGalleries.
     */
    data: SchoolGalleryCreateManyInput | SchoolGalleryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolGallery update
   */
  export type SchoolGalleryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolGallery.
     */
    data: XOR<SchoolGalleryUpdateInput, SchoolGalleryUncheckedUpdateInput>
    /**
     * Choose, which SchoolGallery to update.
     */
    where: SchoolGalleryWhereUniqueInput
  }

  /**
   * SchoolGallery updateMany
   */
  export type SchoolGalleryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolGalleries.
     */
    data: XOR<SchoolGalleryUpdateManyMutationInput, SchoolGalleryUncheckedUpdateManyInput>
    /**
     * Filter which SchoolGalleries to update
     */
    where?: SchoolGalleryWhereInput
  }

  /**
   * SchoolGallery upsert
   */
  export type SchoolGalleryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolGallery to update in case it exists.
     */
    where: SchoolGalleryWhereUniqueInput
    /**
     * In case the SchoolGallery found by the `where` argument doesn't exist, create a new SchoolGallery with this data.
     */
    create: XOR<SchoolGalleryCreateInput, SchoolGalleryUncheckedCreateInput>
    /**
     * In case the SchoolGallery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolGalleryUpdateInput, SchoolGalleryUncheckedUpdateInput>
  }

  /**
   * SchoolGallery delete
   */
  export type SchoolGalleryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
    /**
     * Filter which SchoolGallery to delete.
     */
    where: SchoolGalleryWhereUniqueInput
  }

  /**
   * SchoolGallery deleteMany
   */
  export type SchoolGalleryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolGalleries to delete
     */
    where?: SchoolGalleryWhereInput
  }

  /**
   * SchoolGallery.images
   */
  export type SchoolGallery$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    where?: SchoolGalleryImageWhereInput
    orderBy?: SchoolGalleryImageOrderByWithRelationInput | SchoolGalleryImageOrderByWithRelationInput[]
    cursor?: SchoolGalleryImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolGalleryImageScalarFieldEnum | SchoolGalleryImageScalarFieldEnum[]
  }

  /**
   * SchoolGallery without action
   */
  export type SchoolGalleryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGallery
     */
    select?: SchoolGallerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryInclude<ExtArgs> | null
  }


  /**
   * Model SchoolGalleryImage
   */

  export type AggregateSchoolGalleryImage = {
    _count: SchoolGalleryImageCountAggregateOutputType | null
    _min: SchoolGalleryImageMinAggregateOutputType | null
    _max: SchoolGalleryImageMaxAggregateOutputType | null
  }

  export type SchoolGalleryImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    galleryId: string | null
  }

  export type SchoolGalleryImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    galleryId: string | null
  }

  export type SchoolGalleryImageCountAggregateOutputType = {
    id: number
    url: number
    galleryId: number
    _all: number
  }


  export type SchoolGalleryImageMinAggregateInputType = {
    id?: true
    url?: true
    galleryId?: true
  }

  export type SchoolGalleryImageMaxAggregateInputType = {
    id?: true
    url?: true
    galleryId?: true
  }

  export type SchoolGalleryImageCountAggregateInputType = {
    id?: true
    url?: true
    galleryId?: true
    _all?: true
  }

  export type SchoolGalleryImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolGalleryImage to aggregate.
     */
    where?: SchoolGalleryImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolGalleryImages to fetch.
     */
    orderBy?: SchoolGalleryImageOrderByWithRelationInput | SchoolGalleryImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolGalleryImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolGalleryImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolGalleryImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolGalleryImages
    **/
    _count?: true | SchoolGalleryImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolGalleryImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolGalleryImageMaxAggregateInputType
  }

  export type GetSchoolGalleryImageAggregateType<T extends SchoolGalleryImageAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolGalleryImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolGalleryImage[P]>
      : GetScalarType<T[P], AggregateSchoolGalleryImage[P]>
  }




  export type SchoolGalleryImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolGalleryImageWhereInput
    orderBy?: SchoolGalleryImageOrderByWithAggregationInput | SchoolGalleryImageOrderByWithAggregationInput[]
    by: SchoolGalleryImageScalarFieldEnum[] | SchoolGalleryImageScalarFieldEnum
    having?: SchoolGalleryImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolGalleryImageCountAggregateInputType | true
    _min?: SchoolGalleryImageMinAggregateInputType
    _max?: SchoolGalleryImageMaxAggregateInputType
  }

  export type SchoolGalleryImageGroupByOutputType = {
    id: string
    url: string
    galleryId: string
    _count: SchoolGalleryImageCountAggregateOutputType | null
    _min: SchoolGalleryImageMinAggregateOutputType | null
    _max: SchoolGalleryImageMaxAggregateOutputType | null
  }

  type GetSchoolGalleryImageGroupByPayload<T extends SchoolGalleryImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGalleryImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGalleryImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGalleryImageGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGalleryImageGroupByOutputType[P]>
        }
      >
    >


  export type SchoolGalleryImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    galleryId?: boolean
    gallery?: boolean | SchoolGalleryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolGalleryImage"]>

  export type SchoolGalleryImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    galleryId?: boolean
    gallery?: boolean | SchoolGalleryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolGalleryImage"]>

  export type SchoolGalleryImageSelectScalar = {
    id?: boolean
    url?: boolean
    galleryId?: boolean
  }

  export type SchoolGalleryImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gallery?: boolean | SchoolGalleryDefaultArgs<ExtArgs>
  }
  export type SchoolGalleryImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gallery?: boolean | SchoolGalleryDefaultArgs<ExtArgs>
  }

  export type $SchoolGalleryImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolGalleryImage"
    objects: {
      gallery: Prisma.$SchoolGalleryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      galleryId: string
    }, ExtArgs["result"]["schoolGalleryImage"]>
    composites: {}
  }

  type SchoolGalleryImageGetPayload<S extends boolean | null | undefined | SchoolGalleryImageDefaultArgs> = $Result.GetResult<Prisma.$SchoolGalleryImagePayload, S>

  type SchoolGalleryImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolGalleryImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolGalleryImageCountAggregateInputType | true
    }

  export interface SchoolGalleryImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolGalleryImage'], meta: { name: 'SchoolGalleryImage' } }
    /**
     * Find zero or one SchoolGalleryImage that matches the filter.
     * @param {SchoolGalleryImageFindUniqueArgs} args - Arguments to find a SchoolGalleryImage
     * @example
     * // Get one SchoolGalleryImage
     * const schoolGalleryImage = await prisma.schoolGalleryImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolGalleryImageFindUniqueArgs>(args: SelectSubset<T, SchoolGalleryImageFindUniqueArgs<ExtArgs>>): Prisma__SchoolGalleryImageClient<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolGalleryImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolGalleryImageFindUniqueOrThrowArgs} args - Arguments to find a SchoolGalleryImage
     * @example
     * // Get one SchoolGalleryImage
     * const schoolGalleryImage = await prisma.schoolGalleryImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolGalleryImageFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolGalleryImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolGalleryImageClient<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolGalleryImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryImageFindFirstArgs} args - Arguments to find a SchoolGalleryImage
     * @example
     * // Get one SchoolGalleryImage
     * const schoolGalleryImage = await prisma.schoolGalleryImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolGalleryImageFindFirstArgs>(args?: SelectSubset<T, SchoolGalleryImageFindFirstArgs<ExtArgs>>): Prisma__SchoolGalleryImageClient<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolGalleryImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryImageFindFirstOrThrowArgs} args - Arguments to find a SchoolGalleryImage
     * @example
     * // Get one SchoolGalleryImage
     * const schoolGalleryImage = await prisma.schoolGalleryImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolGalleryImageFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolGalleryImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolGalleryImageClient<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolGalleryImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolGalleryImages
     * const schoolGalleryImages = await prisma.schoolGalleryImage.findMany()
     * 
     * // Get first 10 SchoolGalleryImages
     * const schoolGalleryImages = await prisma.schoolGalleryImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolGalleryImageWithIdOnly = await prisma.schoolGalleryImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolGalleryImageFindManyArgs>(args?: SelectSubset<T, SchoolGalleryImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolGalleryImage.
     * @param {SchoolGalleryImageCreateArgs} args - Arguments to create a SchoolGalleryImage.
     * @example
     * // Create one SchoolGalleryImage
     * const SchoolGalleryImage = await prisma.schoolGalleryImage.create({
     *   data: {
     *     // ... data to create a SchoolGalleryImage
     *   }
     * })
     * 
     */
    create<T extends SchoolGalleryImageCreateArgs>(args: SelectSubset<T, SchoolGalleryImageCreateArgs<ExtArgs>>): Prisma__SchoolGalleryImageClient<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolGalleryImages.
     * @param {SchoolGalleryImageCreateManyArgs} args - Arguments to create many SchoolGalleryImages.
     * @example
     * // Create many SchoolGalleryImages
     * const schoolGalleryImage = await prisma.schoolGalleryImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolGalleryImageCreateManyArgs>(args?: SelectSubset<T, SchoolGalleryImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolGalleryImages and returns the data saved in the database.
     * @param {SchoolGalleryImageCreateManyAndReturnArgs} args - Arguments to create many SchoolGalleryImages.
     * @example
     * // Create many SchoolGalleryImages
     * const schoolGalleryImage = await prisma.schoolGalleryImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolGalleryImages and only return the `id`
     * const schoolGalleryImageWithIdOnly = await prisma.schoolGalleryImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolGalleryImageCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolGalleryImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolGalleryImage.
     * @param {SchoolGalleryImageDeleteArgs} args - Arguments to delete one SchoolGalleryImage.
     * @example
     * // Delete one SchoolGalleryImage
     * const SchoolGalleryImage = await prisma.schoolGalleryImage.delete({
     *   where: {
     *     // ... filter to delete one SchoolGalleryImage
     *   }
     * })
     * 
     */
    delete<T extends SchoolGalleryImageDeleteArgs>(args: SelectSubset<T, SchoolGalleryImageDeleteArgs<ExtArgs>>): Prisma__SchoolGalleryImageClient<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolGalleryImage.
     * @param {SchoolGalleryImageUpdateArgs} args - Arguments to update one SchoolGalleryImage.
     * @example
     * // Update one SchoolGalleryImage
     * const schoolGalleryImage = await prisma.schoolGalleryImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolGalleryImageUpdateArgs>(args: SelectSubset<T, SchoolGalleryImageUpdateArgs<ExtArgs>>): Prisma__SchoolGalleryImageClient<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolGalleryImages.
     * @param {SchoolGalleryImageDeleteManyArgs} args - Arguments to filter SchoolGalleryImages to delete.
     * @example
     * // Delete a few SchoolGalleryImages
     * const { count } = await prisma.schoolGalleryImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolGalleryImageDeleteManyArgs>(args?: SelectSubset<T, SchoolGalleryImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolGalleryImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolGalleryImages
     * const schoolGalleryImage = await prisma.schoolGalleryImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolGalleryImageUpdateManyArgs>(args: SelectSubset<T, SchoolGalleryImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolGalleryImage.
     * @param {SchoolGalleryImageUpsertArgs} args - Arguments to update or create a SchoolGalleryImage.
     * @example
     * // Update or create a SchoolGalleryImage
     * const schoolGalleryImage = await prisma.schoolGalleryImage.upsert({
     *   create: {
     *     // ... data to create a SchoolGalleryImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolGalleryImage we want to update
     *   }
     * })
     */
    upsert<T extends SchoolGalleryImageUpsertArgs>(args: SelectSubset<T, SchoolGalleryImageUpsertArgs<ExtArgs>>): Prisma__SchoolGalleryImageClient<$Result.GetResult<Prisma.$SchoolGalleryImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolGalleryImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryImageCountArgs} args - Arguments to filter SchoolGalleryImages to count.
     * @example
     * // Count the number of SchoolGalleryImages
     * const count = await prisma.schoolGalleryImage.count({
     *   where: {
     *     // ... the filter for the SchoolGalleryImages we want to count
     *   }
     * })
    **/
    count<T extends SchoolGalleryImageCountArgs>(
      args?: Subset<T, SchoolGalleryImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolGalleryImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolGalleryImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolGalleryImageAggregateArgs>(args: Subset<T, SchoolGalleryImageAggregateArgs>): Prisma.PrismaPromise<GetSchoolGalleryImageAggregateType<T>>

    /**
     * Group by SchoolGalleryImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGalleryImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGalleryImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGalleryImageGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGalleryImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGalleryImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGalleryImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolGalleryImage model
   */
  readonly fields: SchoolGalleryImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolGalleryImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolGalleryImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gallery<T extends SchoolGalleryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolGalleryDefaultArgs<ExtArgs>>): Prisma__SchoolGalleryClient<$Result.GetResult<Prisma.$SchoolGalleryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolGalleryImage model
   */ 
  interface SchoolGalleryImageFieldRefs {
    readonly id: FieldRef<"SchoolGalleryImage", 'String'>
    readonly url: FieldRef<"SchoolGalleryImage", 'String'>
    readonly galleryId: FieldRef<"SchoolGalleryImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SchoolGalleryImage findUnique
   */
  export type SchoolGalleryImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGalleryImage to fetch.
     */
    where: SchoolGalleryImageWhereUniqueInput
  }

  /**
   * SchoolGalleryImage findUniqueOrThrow
   */
  export type SchoolGalleryImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGalleryImage to fetch.
     */
    where: SchoolGalleryImageWhereUniqueInput
  }

  /**
   * SchoolGalleryImage findFirst
   */
  export type SchoolGalleryImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGalleryImage to fetch.
     */
    where?: SchoolGalleryImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolGalleryImages to fetch.
     */
    orderBy?: SchoolGalleryImageOrderByWithRelationInput | SchoolGalleryImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolGalleryImages.
     */
    cursor?: SchoolGalleryImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolGalleryImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolGalleryImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolGalleryImages.
     */
    distinct?: SchoolGalleryImageScalarFieldEnum | SchoolGalleryImageScalarFieldEnum[]
  }

  /**
   * SchoolGalleryImage findFirstOrThrow
   */
  export type SchoolGalleryImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGalleryImage to fetch.
     */
    where?: SchoolGalleryImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolGalleryImages to fetch.
     */
    orderBy?: SchoolGalleryImageOrderByWithRelationInput | SchoolGalleryImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolGalleryImages.
     */
    cursor?: SchoolGalleryImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolGalleryImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolGalleryImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolGalleryImages.
     */
    distinct?: SchoolGalleryImageScalarFieldEnum | SchoolGalleryImageScalarFieldEnum[]
  }

  /**
   * SchoolGalleryImage findMany
   */
  export type SchoolGalleryImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolGalleryImages to fetch.
     */
    where?: SchoolGalleryImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolGalleryImages to fetch.
     */
    orderBy?: SchoolGalleryImageOrderByWithRelationInput | SchoolGalleryImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolGalleryImages.
     */
    cursor?: SchoolGalleryImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolGalleryImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolGalleryImages.
     */
    skip?: number
    distinct?: SchoolGalleryImageScalarFieldEnum | SchoolGalleryImageScalarFieldEnum[]
  }

  /**
   * SchoolGalleryImage create
   */
  export type SchoolGalleryImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolGalleryImage.
     */
    data: XOR<SchoolGalleryImageCreateInput, SchoolGalleryImageUncheckedCreateInput>
  }

  /**
   * SchoolGalleryImage createMany
   */
  export type SchoolGalleryImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolGalleryImages.
     */
    data: SchoolGalleryImageCreateManyInput | SchoolGalleryImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolGalleryImage createManyAndReturn
   */
  export type SchoolGalleryImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolGalleryImages.
     */
    data: SchoolGalleryImageCreateManyInput | SchoolGalleryImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolGalleryImage update
   */
  export type SchoolGalleryImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolGalleryImage.
     */
    data: XOR<SchoolGalleryImageUpdateInput, SchoolGalleryImageUncheckedUpdateInput>
    /**
     * Choose, which SchoolGalleryImage to update.
     */
    where: SchoolGalleryImageWhereUniqueInput
  }

  /**
   * SchoolGalleryImage updateMany
   */
  export type SchoolGalleryImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolGalleryImages.
     */
    data: XOR<SchoolGalleryImageUpdateManyMutationInput, SchoolGalleryImageUncheckedUpdateManyInput>
    /**
     * Filter which SchoolGalleryImages to update
     */
    where?: SchoolGalleryImageWhereInput
  }

  /**
   * SchoolGalleryImage upsert
   */
  export type SchoolGalleryImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolGalleryImage to update in case it exists.
     */
    where: SchoolGalleryImageWhereUniqueInput
    /**
     * In case the SchoolGalleryImage found by the `where` argument doesn't exist, create a new SchoolGalleryImage with this data.
     */
    create: XOR<SchoolGalleryImageCreateInput, SchoolGalleryImageUncheckedCreateInput>
    /**
     * In case the SchoolGalleryImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolGalleryImageUpdateInput, SchoolGalleryImageUncheckedUpdateInput>
  }

  /**
   * SchoolGalleryImage delete
   */
  export type SchoolGalleryImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
    /**
     * Filter which SchoolGalleryImage to delete.
     */
    where: SchoolGalleryImageWhereUniqueInput
  }

  /**
   * SchoolGalleryImage deleteMany
   */
  export type SchoolGalleryImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolGalleryImages to delete
     */
    where?: SchoolGalleryImageWhereInput
  }

  /**
   * SchoolGalleryImage without action
   */
  export type SchoolGalleryImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolGalleryImage
     */
    select?: SchoolGalleryImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolGalleryImageInclude<ExtArgs> | null
  }


  /**
   * Model SchoolLocation
   */

  export type AggregateSchoolLocation = {
    _count: SchoolLocationCountAggregateOutputType | null
    _min: SchoolLocationMinAggregateOutputType | null
    _max: SchoolLocationMaxAggregateOutputType | null
  }

  export type SchoolLocationMinAggregateOutputType = {
    id: string | null
    cover: string | null
    name: string | null
    address: string | null
    isMain: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolLocationMaxAggregateOutputType = {
    id: string | null
    cover: string | null
    name: string | null
    address: string | null
    isMain: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolLocationCountAggregateOutputType = {
    id: number
    cover: number
    name: number
    address: number
    isMain: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolLocationMinAggregateInputType = {
    id?: true
    cover?: true
    name?: true
    address?: true
    isMain?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolLocationMaxAggregateInputType = {
    id?: true
    cover?: true
    name?: true
    address?: true
    isMain?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolLocationCountAggregateInputType = {
    id?: true
    cover?: true
    name?: true
    address?: true
    isMain?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolLocation to aggregate.
     */
    where?: SchoolLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocations to fetch.
     */
    orderBy?: SchoolLocationOrderByWithRelationInput | SchoolLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolLocations
    **/
    _count?: true | SchoolLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolLocationMaxAggregateInputType
  }

  export type GetSchoolLocationAggregateType<T extends SchoolLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolLocation[P]>
      : GetScalarType<T[P], AggregateSchoolLocation[P]>
  }




  export type SchoolLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolLocationWhereInput
    orderBy?: SchoolLocationOrderByWithAggregationInput | SchoolLocationOrderByWithAggregationInput[]
    by: SchoolLocationScalarFieldEnum[] | SchoolLocationScalarFieldEnum
    having?: SchoolLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolLocationCountAggregateInputType | true
    _min?: SchoolLocationMinAggregateInputType
    _max?: SchoolLocationMaxAggregateInputType
  }

  export type SchoolLocationGroupByOutputType = {
    id: string
    cover: string | null
    name: string
    address: string
    isMain: boolean
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolLocationCountAggregateOutputType | null
    _min: SchoolLocationMinAggregateOutputType | null
    _max: SchoolLocationMaxAggregateOutputType | null
  }

  type GetSchoolLocationGroupByPayload<T extends SchoolLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolLocationGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolLocationGroupByOutputType[P]>
        }
      >
    >


  export type SchoolLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cover?: boolean
    name?: boolean
    address?: boolean
    isMain?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | SchoolLocation$imagesArgs<ExtArgs>
    contacts?: boolean | SchoolLocation$contactsArgs<ExtArgs>
    students?: boolean | SchoolLocation$studentsArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    _count?: boolean | SchoolLocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolLocation"]>

  export type SchoolLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cover?: boolean
    name?: boolean
    address?: boolean
    isMain?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolLocation"]>

  export type SchoolLocationSelectScalar = {
    id?: boolean
    cover?: boolean
    name?: boolean
    address?: boolean
    isMain?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | SchoolLocation$imagesArgs<ExtArgs>
    contacts?: boolean | SchoolLocation$contactsArgs<ExtArgs>
    students?: boolean | SchoolLocation$studentsArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    _count?: boolean | SchoolLocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolLocation"
    objects: {
      images: Prisma.$SchoolLocationImagePayload<ExtArgs>[]
      contacts: Prisma.$SchoolLocationContactPayload<ExtArgs>[]
      students: Prisma.$StudentSchoolLocationPayload<ExtArgs>[]
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cover: string | null
      name: string
      address: string
      isMain: boolean
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolLocation"]>
    composites: {}
  }

  type SchoolLocationGetPayload<S extends boolean | null | undefined | SchoolLocationDefaultArgs> = $Result.GetResult<Prisma.$SchoolLocationPayload, S>

  type SchoolLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolLocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolLocationCountAggregateInputType | true
    }

  export interface SchoolLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolLocation'], meta: { name: 'SchoolLocation' } }
    /**
     * Find zero or one SchoolLocation that matches the filter.
     * @param {SchoolLocationFindUniqueArgs} args - Arguments to find a SchoolLocation
     * @example
     * // Get one SchoolLocation
     * const schoolLocation = await prisma.schoolLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolLocationFindUniqueArgs>(args: SelectSubset<T, SchoolLocationFindUniqueArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolLocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolLocationFindUniqueOrThrowArgs} args - Arguments to find a SchoolLocation
     * @example
     * // Get one SchoolLocation
     * const schoolLocation = await prisma.schoolLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationFindFirstArgs} args - Arguments to find a SchoolLocation
     * @example
     * // Get one SchoolLocation
     * const schoolLocation = await prisma.schoolLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolLocationFindFirstArgs>(args?: SelectSubset<T, SchoolLocationFindFirstArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationFindFirstOrThrowArgs} args - Arguments to find a SchoolLocation
     * @example
     * // Get one SchoolLocation
     * const schoolLocation = await prisma.schoolLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolLocations
     * const schoolLocations = await prisma.schoolLocation.findMany()
     * 
     * // Get first 10 SchoolLocations
     * const schoolLocations = await prisma.schoolLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolLocationWithIdOnly = await prisma.schoolLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolLocationFindManyArgs>(args?: SelectSubset<T, SchoolLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolLocation.
     * @param {SchoolLocationCreateArgs} args - Arguments to create a SchoolLocation.
     * @example
     * // Create one SchoolLocation
     * const SchoolLocation = await prisma.schoolLocation.create({
     *   data: {
     *     // ... data to create a SchoolLocation
     *   }
     * })
     * 
     */
    create<T extends SchoolLocationCreateArgs>(args: SelectSubset<T, SchoolLocationCreateArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolLocations.
     * @param {SchoolLocationCreateManyArgs} args - Arguments to create many SchoolLocations.
     * @example
     * // Create many SchoolLocations
     * const schoolLocation = await prisma.schoolLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolLocationCreateManyArgs>(args?: SelectSubset<T, SchoolLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolLocations and returns the data saved in the database.
     * @param {SchoolLocationCreateManyAndReturnArgs} args - Arguments to create many SchoolLocations.
     * @example
     * // Create many SchoolLocations
     * const schoolLocation = await prisma.schoolLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolLocations and only return the `id`
     * const schoolLocationWithIdOnly = await prisma.schoolLocation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolLocation.
     * @param {SchoolLocationDeleteArgs} args - Arguments to delete one SchoolLocation.
     * @example
     * // Delete one SchoolLocation
     * const SchoolLocation = await prisma.schoolLocation.delete({
     *   where: {
     *     // ... filter to delete one SchoolLocation
     *   }
     * })
     * 
     */
    delete<T extends SchoolLocationDeleteArgs>(args: SelectSubset<T, SchoolLocationDeleteArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolLocation.
     * @param {SchoolLocationUpdateArgs} args - Arguments to update one SchoolLocation.
     * @example
     * // Update one SchoolLocation
     * const schoolLocation = await prisma.schoolLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolLocationUpdateArgs>(args: SelectSubset<T, SchoolLocationUpdateArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolLocations.
     * @param {SchoolLocationDeleteManyArgs} args - Arguments to filter SchoolLocations to delete.
     * @example
     * // Delete a few SchoolLocations
     * const { count } = await prisma.schoolLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolLocationDeleteManyArgs>(args?: SelectSubset<T, SchoolLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolLocations
     * const schoolLocation = await prisma.schoolLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolLocationUpdateManyArgs>(args: SelectSubset<T, SchoolLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolLocation.
     * @param {SchoolLocationUpsertArgs} args - Arguments to update or create a SchoolLocation.
     * @example
     * // Update or create a SchoolLocation
     * const schoolLocation = await prisma.schoolLocation.upsert({
     *   create: {
     *     // ... data to create a SchoolLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolLocation we want to update
     *   }
     * })
     */
    upsert<T extends SchoolLocationUpsertArgs>(args: SelectSubset<T, SchoolLocationUpsertArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationCountArgs} args - Arguments to filter SchoolLocations to count.
     * @example
     * // Count the number of SchoolLocations
     * const count = await prisma.schoolLocation.count({
     *   where: {
     *     // ... the filter for the SchoolLocations we want to count
     *   }
     * })
    **/
    count<T extends SchoolLocationCountArgs>(
      args?: Subset<T, SchoolLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolLocationAggregateArgs>(args: Subset<T, SchoolLocationAggregateArgs>): Prisma.PrismaPromise<GetSchoolLocationAggregateType<T>>

    /**
     * Group by SchoolLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolLocationGroupByArgs['orderBy'] }
        : { orderBy?: SchoolLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolLocation model
   */
  readonly fields: SchoolLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends SchoolLocation$imagesArgs<ExtArgs> = {}>(args?: Subset<T, SchoolLocation$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "findMany"> | Null>
    contacts<T extends SchoolLocation$contactsArgs<ExtArgs> = {}>(args?: Subset<T, SchoolLocation$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends SchoolLocation$studentsArgs<ExtArgs> = {}>(args?: Subset<T, SchoolLocation$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "findMany"> | Null>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolLocation model
   */ 
  interface SchoolLocationFieldRefs {
    readonly id: FieldRef<"SchoolLocation", 'String'>
    readonly cover: FieldRef<"SchoolLocation", 'String'>
    readonly name: FieldRef<"SchoolLocation", 'String'>
    readonly address: FieldRef<"SchoolLocation", 'String'>
    readonly isMain: FieldRef<"SchoolLocation", 'Boolean'>
    readonly schoolId: FieldRef<"SchoolLocation", 'String'>
    readonly createdAt: FieldRef<"SchoolLocation", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolLocation findUnique
   */
  export type SchoolLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocation to fetch.
     */
    where: SchoolLocationWhereUniqueInput
  }

  /**
   * SchoolLocation findUniqueOrThrow
   */
  export type SchoolLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocation to fetch.
     */
    where: SchoolLocationWhereUniqueInput
  }

  /**
   * SchoolLocation findFirst
   */
  export type SchoolLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocation to fetch.
     */
    where?: SchoolLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocations to fetch.
     */
    orderBy?: SchoolLocationOrderByWithRelationInput | SchoolLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolLocations.
     */
    cursor?: SchoolLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolLocations.
     */
    distinct?: SchoolLocationScalarFieldEnum | SchoolLocationScalarFieldEnum[]
  }

  /**
   * SchoolLocation findFirstOrThrow
   */
  export type SchoolLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocation to fetch.
     */
    where?: SchoolLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocations to fetch.
     */
    orderBy?: SchoolLocationOrderByWithRelationInput | SchoolLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolLocations.
     */
    cursor?: SchoolLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolLocations.
     */
    distinct?: SchoolLocationScalarFieldEnum | SchoolLocationScalarFieldEnum[]
  }

  /**
   * SchoolLocation findMany
   */
  export type SchoolLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocations to fetch.
     */
    where?: SchoolLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocations to fetch.
     */
    orderBy?: SchoolLocationOrderByWithRelationInput | SchoolLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolLocations.
     */
    cursor?: SchoolLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocations.
     */
    skip?: number
    distinct?: SchoolLocationScalarFieldEnum | SchoolLocationScalarFieldEnum[]
  }

  /**
   * SchoolLocation create
   */
  export type SchoolLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolLocation.
     */
    data: XOR<SchoolLocationCreateInput, SchoolLocationUncheckedCreateInput>
  }

  /**
   * SchoolLocation createMany
   */
  export type SchoolLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolLocations.
     */
    data: SchoolLocationCreateManyInput | SchoolLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolLocation createManyAndReturn
   */
  export type SchoolLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolLocations.
     */
    data: SchoolLocationCreateManyInput | SchoolLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolLocation update
   */
  export type SchoolLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolLocation.
     */
    data: XOR<SchoolLocationUpdateInput, SchoolLocationUncheckedUpdateInput>
    /**
     * Choose, which SchoolLocation to update.
     */
    where: SchoolLocationWhereUniqueInput
  }

  /**
   * SchoolLocation updateMany
   */
  export type SchoolLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolLocations.
     */
    data: XOR<SchoolLocationUpdateManyMutationInput, SchoolLocationUncheckedUpdateManyInput>
    /**
     * Filter which SchoolLocations to update
     */
    where?: SchoolLocationWhereInput
  }

  /**
   * SchoolLocation upsert
   */
  export type SchoolLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolLocation to update in case it exists.
     */
    where: SchoolLocationWhereUniqueInput
    /**
     * In case the SchoolLocation found by the `where` argument doesn't exist, create a new SchoolLocation with this data.
     */
    create: XOR<SchoolLocationCreateInput, SchoolLocationUncheckedCreateInput>
    /**
     * In case the SchoolLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolLocationUpdateInput, SchoolLocationUncheckedUpdateInput>
  }

  /**
   * SchoolLocation delete
   */
  export type SchoolLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
    /**
     * Filter which SchoolLocation to delete.
     */
    where: SchoolLocationWhereUniqueInput
  }

  /**
   * SchoolLocation deleteMany
   */
  export type SchoolLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolLocations to delete
     */
    where?: SchoolLocationWhereInput
  }

  /**
   * SchoolLocation.images
   */
  export type SchoolLocation$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    where?: SchoolLocationImageWhereInput
    orderBy?: SchoolLocationImageOrderByWithRelationInput | SchoolLocationImageOrderByWithRelationInput[]
    cursor?: SchoolLocationImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolLocationImageScalarFieldEnum | SchoolLocationImageScalarFieldEnum[]
  }

  /**
   * SchoolLocation.contacts
   */
  export type SchoolLocation$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    where?: SchoolLocationContactWhereInput
    orderBy?: SchoolLocationContactOrderByWithRelationInput | SchoolLocationContactOrderByWithRelationInput[]
    cursor?: SchoolLocationContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolLocationContactScalarFieldEnum | SchoolLocationContactScalarFieldEnum[]
  }

  /**
   * SchoolLocation.students
   */
  export type SchoolLocation$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    where?: StudentSchoolLocationWhereInput
    orderBy?: StudentSchoolLocationOrderByWithRelationInput | StudentSchoolLocationOrderByWithRelationInput[]
    cursor?: StudentSchoolLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSchoolLocationScalarFieldEnum | StudentSchoolLocationScalarFieldEnum[]
  }

  /**
   * SchoolLocation without action
   */
  export type SchoolLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocation
     */
    select?: SchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationInclude<ExtArgs> | null
  }


  /**
   * Model SchoolLocationImage
   */

  export type AggregateSchoolLocationImage = {
    _count: SchoolLocationImageCountAggregateOutputType | null
    _min: SchoolLocationImageMinAggregateOutputType | null
    _max: SchoolLocationImageMaxAggregateOutputType | null
  }

  export type SchoolLocationImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    locationId: string | null
  }

  export type SchoolLocationImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    locationId: string | null
  }

  export type SchoolLocationImageCountAggregateOutputType = {
    id: number
    url: number
    locationId: number
    _all: number
  }


  export type SchoolLocationImageMinAggregateInputType = {
    id?: true
    url?: true
    locationId?: true
  }

  export type SchoolLocationImageMaxAggregateInputType = {
    id?: true
    url?: true
    locationId?: true
  }

  export type SchoolLocationImageCountAggregateInputType = {
    id?: true
    url?: true
    locationId?: true
    _all?: true
  }

  export type SchoolLocationImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolLocationImage to aggregate.
     */
    where?: SchoolLocationImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocationImages to fetch.
     */
    orderBy?: SchoolLocationImageOrderByWithRelationInput | SchoolLocationImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolLocationImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolLocationImages
    **/
    _count?: true | SchoolLocationImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolLocationImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolLocationImageMaxAggregateInputType
  }

  export type GetSchoolLocationImageAggregateType<T extends SchoolLocationImageAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolLocationImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolLocationImage[P]>
      : GetScalarType<T[P], AggregateSchoolLocationImage[P]>
  }




  export type SchoolLocationImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolLocationImageWhereInput
    orderBy?: SchoolLocationImageOrderByWithAggregationInput | SchoolLocationImageOrderByWithAggregationInput[]
    by: SchoolLocationImageScalarFieldEnum[] | SchoolLocationImageScalarFieldEnum
    having?: SchoolLocationImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolLocationImageCountAggregateInputType | true
    _min?: SchoolLocationImageMinAggregateInputType
    _max?: SchoolLocationImageMaxAggregateInputType
  }

  export type SchoolLocationImageGroupByOutputType = {
    id: string
    url: string
    locationId: string
    _count: SchoolLocationImageCountAggregateOutputType | null
    _min: SchoolLocationImageMinAggregateOutputType | null
    _max: SchoolLocationImageMaxAggregateOutputType | null
  }

  type GetSchoolLocationImageGroupByPayload<T extends SchoolLocationImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolLocationImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolLocationImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolLocationImageGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolLocationImageGroupByOutputType[P]>
        }
      >
    >


  export type SchoolLocationImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    locationId?: boolean
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolLocationImage"]>

  export type SchoolLocationImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    locationId?: boolean
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolLocationImage"]>

  export type SchoolLocationImageSelectScalar = {
    id?: boolean
    url?: boolean
    locationId?: boolean
  }

  export type SchoolLocationImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }
  export type SchoolLocationImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }

  export type $SchoolLocationImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolLocationImage"
    objects: {
      location: Prisma.$SchoolLocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      locationId: string
    }, ExtArgs["result"]["schoolLocationImage"]>
    composites: {}
  }

  type SchoolLocationImageGetPayload<S extends boolean | null | undefined | SchoolLocationImageDefaultArgs> = $Result.GetResult<Prisma.$SchoolLocationImagePayload, S>

  type SchoolLocationImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolLocationImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolLocationImageCountAggregateInputType | true
    }

  export interface SchoolLocationImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolLocationImage'], meta: { name: 'SchoolLocationImage' } }
    /**
     * Find zero or one SchoolLocationImage that matches the filter.
     * @param {SchoolLocationImageFindUniqueArgs} args - Arguments to find a SchoolLocationImage
     * @example
     * // Get one SchoolLocationImage
     * const schoolLocationImage = await prisma.schoolLocationImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolLocationImageFindUniqueArgs>(args: SelectSubset<T, SchoolLocationImageFindUniqueArgs<ExtArgs>>): Prisma__SchoolLocationImageClient<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolLocationImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolLocationImageFindUniqueOrThrowArgs} args - Arguments to find a SchoolLocationImage
     * @example
     * // Get one SchoolLocationImage
     * const schoolLocationImage = await prisma.schoolLocationImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolLocationImageFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolLocationImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolLocationImageClient<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolLocationImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationImageFindFirstArgs} args - Arguments to find a SchoolLocationImage
     * @example
     * // Get one SchoolLocationImage
     * const schoolLocationImage = await prisma.schoolLocationImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolLocationImageFindFirstArgs>(args?: SelectSubset<T, SchoolLocationImageFindFirstArgs<ExtArgs>>): Prisma__SchoolLocationImageClient<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolLocationImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationImageFindFirstOrThrowArgs} args - Arguments to find a SchoolLocationImage
     * @example
     * // Get one SchoolLocationImage
     * const schoolLocationImage = await prisma.schoolLocationImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolLocationImageFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolLocationImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolLocationImageClient<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolLocationImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolLocationImages
     * const schoolLocationImages = await prisma.schoolLocationImage.findMany()
     * 
     * // Get first 10 SchoolLocationImages
     * const schoolLocationImages = await prisma.schoolLocationImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolLocationImageWithIdOnly = await prisma.schoolLocationImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolLocationImageFindManyArgs>(args?: SelectSubset<T, SchoolLocationImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolLocationImage.
     * @param {SchoolLocationImageCreateArgs} args - Arguments to create a SchoolLocationImage.
     * @example
     * // Create one SchoolLocationImage
     * const SchoolLocationImage = await prisma.schoolLocationImage.create({
     *   data: {
     *     // ... data to create a SchoolLocationImage
     *   }
     * })
     * 
     */
    create<T extends SchoolLocationImageCreateArgs>(args: SelectSubset<T, SchoolLocationImageCreateArgs<ExtArgs>>): Prisma__SchoolLocationImageClient<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolLocationImages.
     * @param {SchoolLocationImageCreateManyArgs} args - Arguments to create many SchoolLocationImages.
     * @example
     * // Create many SchoolLocationImages
     * const schoolLocationImage = await prisma.schoolLocationImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolLocationImageCreateManyArgs>(args?: SelectSubset<T, SchoolLocationImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolLocationImages and returns the data saved in the database.
     * @param {SchoolLocationImageCreateManyAndReturnArgs} args - Arguments to create many SchoolLocationImages.
     * @example
     * // Create many SchoolLocationImages
     * const schoolLocationImage = await prisma.schoolLocationImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolLocationImages and only return the `id`
     * const schoolLocationImageWithIdOnly = await prisma.schoolLocationImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolLocationImageCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolLocationImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolLocationImage.
     * @param {SchoolLocationImageDeleteArgs} args - Arguments to delete one SchoolLocationImage.
     * @example
     * // Delete one SchoolLocationImage
     * const SchoolLocationImage = await prisma.schoolLocationImage.delete({
     *   where: {
     *     // ... filter to delete one SchoolLocationImage
     *   }
     * })
     * 
     */
    delete<T extends SchoolLocationImageDeleteArgs>(args: SelectSubset<T, SchoolLocationImageDeleteArgs<ExtArgs>>): Prisma__SchoolLocationImageClient<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolLocationImage.
     * @param {SchoolLocationImageUpdateArgs} args - Arguments to update one SchoolLocationImage.
     * @example
     * // Update one SchoolLocationImage
     * const schoolLocationImage = await prisma.schoolLocationImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolLocationImageUpdateArgs>(args: SelectSubset<T, SchoolLocationImageUpdateArgs<ExtArgs>>): Prisma__SchoolLocationImageClient<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolLocationImages.
     * @param {SchoolLocationImageDeleteManyArgs} args - Arguments to filter SchoolLocationImages to delete.
     * @example
     * // Delete a few SchoolLocationImages
     * const { count } = await prisma.schoolLocationImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolLocationImageDeleteManyArgs>(args?: SelectSubset<T, SchoolLocationImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolLocationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolLocationImages
     * const schoolLocationImage = await prisma.schoolLocationImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolLocationImageUpdateManyArgs>(args: SelectSubset<T, SchoolLocationImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolLocationImage.
     * @param {SchoolLocationImageUpsertArgs} args - Arguments to update or create a SchoolLocationImage.
     * @example
     * // Update or create a SchoolLocationImage
     * const schoolLocationImage = await prisma.schoolLocationImage.upsert({
     *   create: {
     *     // ... data to create a SchoolLocationImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolLocationImage we want to update
     *   }
     * })
     */
    upsert<T extends SchoolLocationImageUpsertArgs>(args: SelectSubset<T, SchoolLocationImageUpsertArgs<ExtArgs>>): Prisma__SchoolLocationImageClient<$Result.GetResult<Prisma.$SchoolLocationImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolLocationImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationImageCountArgs} args - Arguments to filter SchoolLocationImages to count.
     * @example
     * // Count the number of SchoolLocationImages
     * const count = await prisma.schoolLocationImage.count({
     *   where: {
     *     // ... the filter for the SchoolLocationImages we want to count
     *   }
     * })
    **/
    count<T extends SchoolLocationImageCountArgs>(
      args?: Subset<T, SchoolLocationImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolLocationImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolLocationImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolLocationImageAggregateArgs>(args: Subset<T, SchoolLocationImageAggregateArgs>): Prisma.PrismaPromise<GetSchoolLocationImageAggregateType<T>>

    /**
     * Group by SchoolLocationImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolLocationImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolLocationImageGroupByArgs['orderBy'] }
        : { orderBy?: SchoolLocationImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolLocationImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolLocationImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolLocationImage model
   */
  readonly fields: SchoolLocationImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolLocationImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolLocationImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends SchoolLocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolLocationDefaultArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolLocationImage model
   */ 
  interface SchoolLocationImageFieldRefs {
    readonly id: FieldRef<"SchoolLocationImage", 'String'>
    readonly url: FieldRef<"SchoolLocationImage", 'String'>
    readonly locationId: FieldRef<"SchoolLocationImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SchoolLocationImage findUnique
   */
  export type SchoolLocationImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationImage to fetch.
     */
    where: SchoolLocationImageWhereUniqueInput
  }

  /**
   * SchoolLocationImage findUniqueOrThrow
   */
  export type SchoolLocationImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationImage to fetch.
     */
    where: SchoolLocationImageWhereUniqueInput
  }

  /**
   * SchoolLocationImage findFirst
   */
  export type SchoolLocationImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationImage to fetch.
     */
    where?: SchoolLocationImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocationImages to fetch.
     */
    orderBy?: SchoolLocationImageOrderByWithRelationInput | SchoolLocationImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolLocationImages.
     */
    cursor?: SchoolLocationImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolLocationImages.
     */
    distinct?: SchoolLocationImageScalarFieldEnum | SchoolLocationImageScalarFieldEnum[]
  }

  /**
   * SchoolLocationImage findFirstOrThrow
   */
  export type SchoolLocationImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationImage to fetch.
     */
    where?: SchoolLocationImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocationImages to fetch.
     */
    orderBy?: SchoolLocationImageOrderByWithRelationInput | SchoolLocationImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolLocationImages.
     */
    cursor?: SchoolLocationImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocationImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolLocationImages.
     */
    distinct?: SchoolLocationImageScalarFieldEnum | SchoolLocationImageScalarFieldEnum[]
  }

  /**
   * SchoolLocationImage findMany
   */
  export type SchoolLocationImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationImages to fetch.
     */
    where?: SchoolLocationImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocationImages to fetch.
     */
    orderBy?: SchoolLocationImageOrderByWithRelationInput | SchoolLocationImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolLocationImages.
     */
    cursor?: SchoolLocationImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocationImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocationImages.
     */
    skip?: number
    distinct?: SchoolLocationImageScalarFieldEnum | SchoolLocationImageScalarFieldEnum[]
  }

  /**
   * SchoolLocationImage create
   */
  export type SchoolLocationImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolLocationImage.
     */
    data: XOR<SchoolLocationImageCreateInput, SchoolLocationImageUncheckedCreateInput>
  }

  /**
   * SchoolLocationImage createMany
   */
  export type SchoolLocationImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolLocationImages.
     */
    data: SchoolLocationImageCreateManyInput | SchoolLocationImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolLocationImage createManyAndReturn
   */
  export type SchoolLocationImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolLocationImages.
     */
    data: SchoolLocationImageCreateManyInput | SchoolLocationImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolLocationImage update
   */
  export type SchoolLocationImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolLocationImage.
     */
    data: XOR<SchoolLocationImageUpdateInput, SchoolLocationImageUncheckedUpdateInput>
    /**
     * Choose, which SchoolLocationImage to update.
     */
    where: SchoolLocationImageWhereUniqueInput
  }

  /**
   * SchoolLocationImage updateMany
   */
  export type SchoolLocationImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolLocationImages.
     */
    data: XOR<SchoolLocationImageUpdateManyMutationInput, SchoolLocationImageUncheckedUpdateManyInput>
    /**
     * Filter which SchoolLocationImages to update
     */
    where?: SchoolLocationImageWhereInput
  }

  /**
   * SchoolLocationImage upsert
   */
  export type SchoolLocationImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolLocationImage to update in case it exists.
     */
    where: SchoolLocationImageWhereUniqueInput
    /**
     * In case the SchoolLocationImage found by the `where` argument doesn't exist, create a new SchoolLocationImage with this data.
     */
    create: XOR<SchoolLocationImageCreateInput, SchoolLocationImageUncheckedCreateInput>
    /**
     * In case the SchoolLocationImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolLocationImageUpdateInput, SchoolLocationImageUncheckedUpdateInput>
  }

  /**
   * SchoolLocationImage delete
   */
  export type SchoolLocationImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
    /**
     * Filter which SchoolLocationImage to delete.
     */
    where: SchoolLocationImageWhereUniqueInput
  }

  /**
   * SchoolLocationImage deleteMany
   */
  export type SchoolLocationImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolLocationImages to delete
     */
    where?: SchoolLocationImageWhereInput
  }

  /**
   * SchoolLocationImage without action
   */
  export type SchoolLocationImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationImage
     */
    select?: SchoolLocationImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationImageInclude<ExtArgs> | null
  }


  /**
   * Model SchoolLocationContact
   */

  export type AggregateSchoolLocationContact = {
    _count: SchoolLocationContactCountAggregateOutputType | null
    _min: SchoolLocationContactMinAggregateOutputType | null
    _max: SchoolLocationContactMaxAggregateOutputType | null
  }

  export type SchoolLocationContactMinAggregateOutputType = {
    id: string | null
    phone: string | null
    hours: string | null
    fax: string | null
    email: string | null
    url: string | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolLocationContactMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    hours: string | null
    fax: string | null
    email: string | null
    url: string | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolLocationContactCountAggregateOutputType = {
    id: number
    phone: number
    hours: number
    fax: number
    email: number
    url: number
    locationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolLocationContactMinAggregateInputType = {
    id?: true
    phone?: true
    hours?: true
    fax?: true
    email?: true
    url?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolLocationContactMaxAggregateInputType = {
    id?: true
    phone?: true
    hours?: true
    fax?: true
    email?: true
    url?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolLocationContactCountAggregateInputType = {
    id?: true
    phone?: true
    hours?: true
    fax?: true
    email?: true
    url?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolLocationContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolLocationContact to aggregate.
     */
    where?: SchoolLocationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocationContacts to fetch.
     */
    orderBy?: SchoolLocationContactOrderByWithRelationInput | SchoolLocationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolLocationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocationContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolLocationContacts
    **/
    _count?: true | SchoolLocationContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolLocationContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolLocationContactMaxAggregateInputType
  }

  export type GetSchoolLocationContactAggregateType<T extends SchoolLocationContactAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolLocationContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolLocationContact[P]>
      : GetScalarType<T[P], AggregateSchoolLocationContact[P]>
  }




  export type SchoolLocationContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolLocationContactWhereInput
    orderBy?: SchoolLocationContactOrderByWithAggregationInput | SchoolLocationContactOrderByWithAggregationInput[]
    by: SchoolLocationContactScalarFieldEnum[] | SchoolLocationContactScalarFieldEnum
    having?: SchoolLocationContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolLocationContactCountAggregateInputType | true
    _min?: SchoolLocationContactMinAggregateInputType
    _max?: SchoolLocationContactMaxAggregateInputType
  }

  export type SchoolLocationContactGroupByOutputType = {
    id: string
    phone: string | null
    hours: string | null
    fax: string | null
    email: string | null
    url: string | null
    locationId: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolLocationContactCountAggregateOutputType | null
    _min: SchoolLocationContactMinAggregateOutputType | null
    _max: SchoolLocationContactMaxAggregateOutputType | null
  }

  type GetSchoolLocationContactGroupByPayload<T extends SchoolLocationContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolLocationContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolLocationContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolLocationContactGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolLocationContactGroupByOutputType[P]>
        }
      >
    >


  export type SchoolLocationContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    hours?: boolean
    fax?: boolean
    email?: boolean
    url?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolLocationContact"]>

  export type SchoolLocationContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    hours?: boolean
    fax?: boolean
    email?: boolean
    url?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolLocationContact"]>

  export type SchoolLocationContactSelectScalar = {
    id?: boolean
    phone?: boolean
    hours?: boolean
    fax?: boolean
    email?: boolean
    url?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolLocationContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }
  export type SchoolLocationContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }

  export type $SchoolLocationContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolLocationContact"
    objects: {
      location: Prisma.$SchoolLocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone: string | null
      hours: string | null
      fax: string | null
      email: string | null
      url: string | null
      locationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolLocationContact"]>
    composites: {}
  }

  type SchoolLocationContactGetPayload<S extends boolean | null | undefined | SchoolLocationContactDefaultArgs> = $Result.GetResult<Prisma.$SchoolLocationContactPayload, S>

  type SchoolLocationContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolLocationContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolLocationContactCountAggregateInputType | true
    }

  export interface SchoolLocationContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolLocationContact'], meta: { name: 'SchoolLocationContact' } }
    /**
     * Find zero or one SchoolLocationContact that matches the filter.
     * @param {SchoolLocationContactFindUniqueArgs} args - Arguments to find a SchoolLocationContact
     * @example
     * // Get one SchoolLocationContact
     * const schoolLocationContact = await prisma.schoolLocationContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolLocationContactFindUniqueArgs>(args: SelectSubset<T, SchoolLocationContactFindUniqueArgs<ExtArgs>>): Prisma__SchoolLocationContactClient<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolLocationContact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolLocationContactFindUniqueOrThrowArgs} args - Arguments to find a SchoolLocationContact
     * @example
     * // Get one SchoolLocationContact
     * const schoolLocationContact = await prisma.schoolLocationContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolLocationContactFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolLocationContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolLocationContactClient<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolLocationContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationContactFindFirstArgs} args - Arguments to find a SchoolLocationContact
     * @example
     * // Get one SchoolLocationContact
     * const schoolLocationContact = await prisma.schoolLocationContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolLocationContactFindFirstArgs>(args?: SelectSubset<T, SchoolLocationContactFindFirstArgs<ExtArgs>>): Prisma__SchoolLocationContactClient<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolLocationContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationContactFindFirstOrThrowArgs} args - Arguments to find a SchoolLocationContact
     * @example
     * // Get one SchoolLocationContact
     * const schoolLocationContact = await prisma.schoolLocationContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolLocationContactFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolLocationContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolLocationContactClient<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolLocationContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolLocationContacts
     * const schoolLocationContacts = await prisma.schoolLocationContact.findMany()
     * 
     * // Get first 10 SchoolLocationContacts
     * const schoolLocationContacts = await prisma.schoolLocationContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolLocationContactWithIdOnly = await prisma.schoolLocationContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolLocationContactFindManyArgs>(args?: SelectSubset<T, SchoolLocationContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolLocationContact.
     * @param {SchoolLocationContactCreateArgs} args - Arguments to create a SchoolLocationContact.
     * @example
     * // Create one SchoolLocationContact
     * const SchoolLocationContact = await prisma.schoolLocationContact.create({
     *   data: {
     *     // ... data to create a SchoolLocationContact
     *   }
     * })
     * 
     */
    create<T extends SchoolLocationContactCreateArgs>(args: SelectSubset<T, SchoolLocationContactCreateArgs<ExtArgs>>): Prisma__SchoolLocationContactClient<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolLocationContacts.
     * @param {SchoolLocationContactCreateManyArgs} args - Arguments to create many SchoolLocationContacts.
     * @example
     * // Create many SchoolLocationContacts
     * const schoolLocationContact = await prisma.schoolLocationContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolLocationContactCreateManyArgs>(args?: SelectSubset<T, SchoolLocationContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolLocationContacts and returns the data saved in the database.
     * @param {SchoolLocationContactCreateManyAndReturnArgs} args - Arguments to create many SchoolLocationContacts.
     * @example
     * // Create many SchoolLocationContacts
     * const schoolLocationContact = await prisma.schoolLocationContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolLocationContacts and only return the `id`
     * const schoolLocationContactWithIdOnly = await prisma.schoolLocationContact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolLocationContactCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolLocationContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolLocationContact.
     * @param {SchoolLocationContactDeleteArgs} args - Arguments to delete one SchoolLocationContact.
     * @example
     * // Delete one SchoolLocationContact
     * const SchoolLocationContact = await prisma.schoolLocationContact.delete({
     *   where: {
     *     // ... filter to delete one SchoolLocationContact
     *   }
     * })
     * 
     */
    delete<T extends SchoolLocationContactDeleteArgs>(args: SelectSubset<T, SchoolLocationContactDeleteArgs<ExtArgs>>): Prisma__SchoolLocationContactClient<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolLocationContact.
     * @param {SchoolLocationContactUpdateArgs} args - Arguments to update one SchoolLocationContact.
     * @example
     * // Update one SchoolLocationContact
     * const schoolLocationContact = await prisma.schoolLocationContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolLocationContactUpdateArgs>(args: SelectSubset<T, SchoolLocationContactUpdateArgs<ExtArgs>>): Prisma__SchoolLocationContactClient<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolLocationContacts.
     * @param {SchoolLocationContactDeleteManyArgs} args - Arguments to filter SchoolLocationContacts to delete.
     * @example
     * // Delete a few SchoolLocationContacts
     * const { count } = await prisma.schoolLocationContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolLocationContactDeleteManyArgs>(args?: SelectSubset<T, SchoolLocationContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolLocationContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolLocationContacts
     * const schoolLocationContact = await prisma.schoolLocationContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolLocationContactUpdateManyArgs>(args: SelectSubset<T, SchoolLocationContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolLocationContact.
     * @param {SchoolLocationContactUpsertArgs} args - Arguments to update or create a SchoolLocationContact.
     * @example
     * // Update or create a SchoolLocationContact
     * const schoolLocationContact = await prisma.schoolLocationContact.upsert({
     *   create: {
     *     // ... data to create a SchoolLocationContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolLocationContact we want to update
     *   }
     * })
     */
    upsert<T extends SchoolLocationContactUpsertArgs>(args: SelectSubset<T, SchoolLocationContactUpsertArgs<ExtArgs>>): Prisma__SchoolLocationContactClient<$Result.GetResult<Prisma.$SchoolLocationContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolLocationContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationContactCountArgs} args - Arguments to filter SchoolLocationContacts to count.
     * @example
     * // Count the number of SchoolLocationContacts
     * const count = await prisma.schoolLocationContact.count({
     *   where: {
     *     // ... the filter for the SchoolLocationContacts we want to count
     *   }
     * })
    **/
    count<T extends SchoolLocationContactCountArgs>(
      args?: Subset<T, SchoolLocationContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolLocationContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolLocationContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolLocationContactAggregateArgs>(args: Subset<T, SchoolLocationContactAggregateArgs>): Prisma.PrismaPromise<GetSchoolLocationContactAggregateType<T>>

    /**
     * Group by SchoolLocationContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolLocationContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolLocationContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolLocationContactGroupByArgs['orderBy'] }
        : { orderBy?: SchoolLocationContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolLocationContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolLocationContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolLocationContact model
   */
  readonly fields: SchoolLocationContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolLocationContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolLocationContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends SchoolLocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolLocationDefaultArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolLocationContact model
   */ 
  interface SchoolLocationContactFieldRefs {
    readonly id: FieldRef<"SchoolLocationContact", 'String'>
    readonly phone: FieldRef<"SchoolLocationContact", 'String'>
    readonly hours: FieldRef<"SchoolLocationContact", 'String'>
    readonly fax: FieldRef<"SchoolLocationContact", 'String'>
    readonly email: FieldRef<"SchoolLocationContact", 'String'>
    readonly url: FieldRef<"SchoolLocationContact", 'String'>
    readonly locationId: FieldRef<"SchoolLocationContact", 'String'>
    readonly createdAt: FieldRef<"SchoolLocationContact", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolLocationContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolLocationContact findUnique
   */
  export type SchoolLocationContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationContact to fetch.
     */
    where: SchoolLocationContactWhereUniqueInput
  }

  /**
   * SchoolLocationContact findUniqueOrThrow
   */
  export type SchoolLocationContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationContact to fetch.
     */
    where: SchoolLocationContactWhereUniqueInput
  }

  /**
   * SchoolLocationContact findFirst
   */
  export type SchoolLocationContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationContact to fetch.
     */
    where?: SchoolLocationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocationContacts to fetch.
     */
    orderBy?: SchoolLocationContactOrderByWithRelationInput | SchoolLocationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolLocationContacts.
     */
    cursor?: SchoolLocationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocationContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolLocationContacts.
     */
    distinct?: SchoolLocationContactScalarFieldEnum | SchoolLocationContactScalarFieldEnum[]
  }

  /**
   * SchoolLocationContact findFirstOrThrow
   */
  export type SchoolLocationContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationContact to fetch.
     */
    where?: SchoolLocationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocationContacts to fetch.
     */
    orderBy?: SchoolLocationContactOrderByWithRelationInput | SchoolLocationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolLocationContacts.
     */
    cursor?: SchoolLocationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocationContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolLocationContacts.
     */
    distinct?: SchoolLocationContactScalarFieldEnum | SchoolLocationContactScalarFieldEnum[]
  }

  /**
   * SchoolLocationContact findMany
   */
  export type SchoolLocationContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    /**
     * Filter, which SchoolLocationContacts to fetch.
     */
    where?: SchoolLocationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolLocationContacts to fetch.
     */
    orderBy?: SchoolLocationContactOrderByWithRelationInput | SchoolLocationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolLocationContacts.
     */
    cursor?: SchoolLocationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolLocationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolLocationContacts.
     */
    skip?: number
    distinct?: SchoolLocationContactScalarFieldEnum | SchoolLocationContactScalarFieldEnum[]
  }

  /**
   * SchoolLocationContact create
   */
  export type SchoolLocationContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolLocationContact.
     */
    data: XOR<SchoolLocationContactCreateInput, SchoolLocationContactUncheckedCreateInput>
  }

  /**
   * SchoolLocationContact createMany
   */
  export type SchoolLocationContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolLocationContacts.
     */
    data: SchoolLocationContactCreateManyInput | SchoolLocationContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolLocationContact createManyAndReturn
   */
  export type SchoolLocationContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolLocationContacts.
     */
    data: SchoolLocationContactCreateManyInput | SchoolLocationContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolLocationContact update
   */
  export type SchoolLocationContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolLocationContact.
     */
    data: XOR<SchoolLocationContactUpdateInput, SchoolLocationContactUncheckedUpdateInput>
    /**
     * Choose, which SchoolLocationContact to update.
     */
    where: SchoolLocationContactWhereUniqueInput
  }

  /**
   * SchoolLocationContact updateMany
   */
  export type SchoolLocationContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolLocationContacts.
     */
    data: XOR<SchoolLocationContactUpdateManyMutationInput, SchoolLocationContactUncheckedUpdateManyInput>
    /**
     * Filter which SchoolLocationContacts to update
     */
    where?: SchoolLocationContactWhereInput
  }

  /**
   * SchoolLocationContact upsert
   */
  export type SchoolLocationContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolLocationContact to update in case it exists.
     */
    where: SchoolLocationContactWhereUniqueInput
    /**
     * In case the SchoolLocationContact found by the `where` argument doesn't exist, create a new SchoolLocationContact with this data.
     */
    create: XOR<SchoolLocationContactCreateInput, SchoolLocationContactUncheckedCreateInput>
    /**
     * In case the SchoolLocationContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolLocationContactUpdateInput, SchoolLocationContactUncheckedUpdateInput>
  }

  /**
   * SchoolLocationContact delete
   */
  export type SchoolLocationContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
    /**
     * Filter which SchoolLocationContact to delete.
     */
    where: SchoolLocationContactWhereUniqueInput
  }

  /**
   * SchoolLocationContact deleteMany
   */
  export type SchoolLocationContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolLocationContacts to delete
     */
    where?: SchoolLocationContactWhereInput
  }

  /**
   * SchoolLocationContact without action
   */
  export type SchoolLocationContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolLocationContact
     */
    select?: SchoolLocationContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolLocationContactInclude<ExtArgs> | null
  }


  /**
   * Model SchoolProgram
   */

  export type AggregateSchoolProgram = {
    _count: SchoolProgramCountAggregateOutputType | null
    _min: SchoolProgramMinAggregateOutputType | null
    _max: SchoolProgramMaxAggregateOutputType | null
  }

  export type SchoolProgramMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    cover: string | null
    isPublished: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolProgramMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    cover: string | null
    isPublished: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolProgramCountAggregateOutputType = {
    id: number
    name: number
    description: number
    cover: number
    isPublished: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolProgramMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cover?: true
    isPublished?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolProgramMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cover?: true
    isPublished?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolProgramCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    cover?: true
    isPublished?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolProgram to aggregate.
     */
    where?: SchoolProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPrograms to fetch.
     */
    orderBy?: SchoolProgramOrderByWithRelationInput | SchoolProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolPrograms
    **/
    _count?: true | SchoolProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolProgramMaxAggregateInputType
  }

  export type GetSchoolProgramAggregateType<T extends SchoolProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolProgram[P]>
      : GetScalarType<T[P], AggregateSchoolProgram[P]>
  }




  export type SchoolProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolProgramWhereInput
    orderBy?: SchoolProgramOrderByWithAggregationInput | SchoolProgramOrderByWithAggregationInput[]
    by: SchoolProgramScalarFieldEnum[] | SchoolProgramScalarFieldEnum
    having?: SchoolProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolProgramCountAggregateInputType | true
    _min?: SchoolProgramMinAggregateInputType
    _max?: SchoolProgramMaxAggregateInputType
  }

  export type SchoolProgramGroupByOutputType = {
    id: string
    name: string
    description: string
    cover: string | null
    isPublished: boolean
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolProgramCountAggregateOutputType | null
    _min: SchoolProgramMinAggregateOutputType | null
    _max: SchoolProgramMaxAggregateOutputType | null
  }

  type GetSchoolProgramGroupByPayload<T extends SchoolProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolProgramGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolProgramGroupByOutputType[P]>
        }
      >
    >


  export type SchoolProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    cover?: boolean
    isPublished?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    studentPrograms?: boolean | SchoolProgram$studentProgramsArgs<ExtArgs>
    images?: boolean | SchoolProgram$imagesArgs<ExtArgs>
    _count?: boolean | SchoolProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolProgram"]>

  export type SchoolProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    cover?: boolean
    isPublished?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolProgram"]>

  export type SchoolProgramSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    cover?: boolean
    isPublished?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    studentPrograms?: boolean | SchoolProgram$studentProgramsArgs<ExtArgs>
    images?: boolean | SchoolProgram$imagesArgs<ExtArgs>
    _count?: boolean | SchoolProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolProgram"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      studentPrograms: Prisma.$StudentSchoolProgramPayload<ExtArgs>[]
      images: Prisma.$SchoolProgramImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      cover: string | null
      isPublished: boolean
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolProgram"]>
    composites: {}
  }

  type SchoolProgramGetPayload<S extends boolean | null | undefined | SchoolProgramDefaultArgs> = $Result.GetResult<Prisma.$SchoolProgramPayload, S>

  type SchoolProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolProgramCountAggregateInputType | true
    }

  export interface SchoolProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolProgram'], meta: { name: 'SchoolProgram' } }
    /**
     * Find zero or one SchoolProgram that matches the filter.
     * @param {SchoolProgramFindUniqueArgs} args - Arguments to find a SchoolProgram
     * @example
     * // Get one SchoolProgram
     * const schoolProgram = await prisma.schoolProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolProgramFindUniqueArgs>(args: SelectSubset<T, SchoolProgramFindUniqueArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolProgram that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolProgramFindUniqueOrThrowArgs} args - Arguments to find a SchoolProgram
     * @example
     * // Get one SchoolProgram
     * const schoolProgram = await prisma.schoolProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramFindFirstArgs} args - Arguments to find a SchoolProgram
     * @example
     * // Get one SchoolProgram
     * const schoolProgram = await prisma.schoolProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolProgramFindFirstArgs>(args?: SelectSubset<T, SchoolProgramFindFirstArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramFindFirstOrThrowArgs} args - Arguments to find a SchoolProgram
     * @example
     * // Get one SchoolProgram
     * const schoolProgram = await prisma.schoolProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolPrograms
     * const schoolPrograms = await prisma.schoolProgram.findMany()
     * 
     * // Get first 10 SchoolPrograms
     * const schoolPrograms = await prisma.schoolProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolProgramWithIdOnly = await prisma.schoolProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolProgramFindManyArgs>(args?: SelectSubset<T, SchoolProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolProgram.
     * @param {SchoolProgramCreateArgs} args - Arguments to create a SchoolProgram.
     * @example
     * // Create one SchoolProgram
     * const SchoolProgram = await prisma.schoolProgram.create({
     *   data: {
     *     // ... data to create a SchoolProgram
     *   }
     * })
     * 
     */
    create<T extends SchoolProgramCreateArgs>(args: SelectSubset<T, SchoolProgramCreateArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolPrograms.
     * @param {SchoolProgramCreateManyArgs} args - Arguments to create many SchoolPrograms.
     * @example
     * // Create many SchoolPrograms
     * const schoolProgram = await prisma.schoolProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolProgramCreateManyArgs>(args?: SelectSubset<T, SchoolProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolPrograms and returns the data saved in the database.
     * @param {SchoolProgramCreateManyAndReturnArgs} args - Arguments to create many SchoolPrograms.
     * @example
     * // Create many SchoolPrograms
     * const schoolProgram = await prisma.schoolProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolPrograms and only return the `id`
     * const schoolProgramWithIdOnly = await prisma.schoolProgram.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolProgram.
     * @param {SchoolProgramDeleteArgs} args - Arguments to delete one SchoolProgram.
     * @example
     * // Delete one SchoolProgram
     * const SchoolProgram = await prisma.schoolProgram.delete({
     *   where: {
     *     // ... filter to delete one SchoolProgram
     *   }
     * })
     * 
     */
    delete<T extends SchoolProgramDeleteArgs>(args: SelectSubset<T, SchoolProgramDeleteArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolProgram.
     * @param {SchoolProgramUpdateArgs} args - Arguments to update one SchoolProgram.
     * @example
     * // Update one SchoolProgram
     * const schoolProgram = await prisma.schoolProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolProgramUpdateArgs>(args: SelectSubset<T, SchoolProgramUpdateArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolPrograms.
     * @param {SchoolProgramDeleteManyArgs} args - Arguments to filter SchoolPrograms to delete.
     * @example
     * // Delete a few SchoolPrograms
     * const { count } = await prisma.schoolProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolProgramDeleteManyArgs>(args?: SelectSubset<T, SchoolProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolPrograms
     * const schoolProgram = await prisma.schoolProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolProgramUpdateManyArgs>(args: SelectSubset<T, SchoolProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolProgram.
     * @param {SchoolProgramUpsertArgs} args - Arguments to update or create a SchoolProgram.
     * @example
     * // Update or create a SchoolProgram
     * const schoolProgram = await prisma.schoolProgram.upsert({
     *   create: {
     *     // ... data to create a SchoolProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolProgram we want to update
     *   }
     * })
     */
    upsert<T extends SchoolProgramUpsertArgs>(args: SelectSubset<T, SchoolProgramUpsertArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramCountArgs} args - Arguments to filter SchoolPrograms to count.
     * @example
     * // Count the number of SchoolPrograms
     * const count = await prisma.schoolProgram.count({
     *   where: {
     *     // ... the filter for the SchoolPrograms we want to count
     *   }
     * })
    **/
    count<T extends SchoolProgramCountArgs>(
      args?: Subset<T, SchoolProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolProgramAggregateArgs>(args: Subset<T, SchoolProgramAggregateArgs>): Prisma.PrismaPromise<GetSchoolProgramAggregateType<T>>

    /**
     * Group by SchoolProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolProgramGroupByArgs['orderBy'] }
        : { orderBy?: SchoolProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolProgram model
   */
  readonly fields: SchoolProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    studentPrograms<T extends SchoolProgram$studentProgramsArgs<ExtArgs> = {}>(args?: Subset<T, SchoolProgram$studentProgramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "findMany"> | Null>
    images<T extends SchoolProgram$imagesArgs<ExtArgs> = {}>(args?: Subset<T, SchoolProgram$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolProgram model
   */ 
  interface SchoolProgramFieldRefs {
    readonly id: FieldRef<"SchoolProgram", 'String'>
    readonly name: FieldRef<"SchoolProgram", 'String'>
    readonly description: FieldRef<"SchoolProgram", 'String'>
    readonly cover: FieldRef<"SchoolProgram", 'String'>
    readonly isPublished: FieldRef<"SchoolProgram", 'Boolean'>
    readonly schoolId: FieldRef<"SchoolProgram", 'String'>
    readonly createdAt: FieldRef<"SchoolProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolProgram findUnique
   */
  export type SchoolProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which SchoolProgram to fetch.
     */
    where: SchoolProgramWhereUniqueInput
  }

  /**
   * SchoolProgram findUniqueOrThrow
   */
  export type SchoolProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which SchoolProgram to fetch.
     */
    where: SchoolProgramWhereUniqueInput
  }

  /**
   * SchoolProgram findFirst
   */
  export type SchoolProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which SchoolProgram to fetch.
     */
    where?: SchoolProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPrograms to fetch.
     */
    orderBy?: SchoolProgramOrderByWithRelationInput | SchoolProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolPrograms.
     */
    cursor?: SchoolProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolPrograms.
     */
    distinct?: SchoolProgramScalarFieldEnum | SchoolProgramScalarFieldEnum[]
  }

  /**
   * SchoolProgram findFirstOrThrow
   */
  export type SchoolProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which SchoolProgram to fetch.
     */
    where?: SchoolProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPrograms to fetch.
     */
    orderBy?: SchoolProgramOrderByWithRelationInput | SchoolProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolPrograms.
     */
    cursor?: SchoolProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolPrograms.
     */
    distinct?: SchoolProgramScalarFieldEnum | SchoolProgramScalarFieldEnum[]
  }

  /**
   * SchoolProgram findMany
   */
  export type SchoolProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which SchoolPrograms to fetch.
     */
    where?: SchoolProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPrograms to fetch.
     */
    orderBy?: SchoolProgramOrderByWithRelationInput | SchoolProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolPrograms.
     */
    cursor?: SchoolProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPrograms.
     */
    skip?: number
    distinct?: SchoolProgramScalarFieldEnum | SchoolProgramScalarFieldEnum[]
  }

  /**
   * SchoolProgram create
   */
  export type SchoolProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolProgram.
     */
    data: XOR<SchoolProgramCreateInput, SchoolProgramUncheckedCreateInput>
  }

  /**
   * SchoolProgram createMany
   */
  export type SchoolProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolPrograms.
     */
    data: SchoolProgramCreateManyInput | SchoolProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolProgram createManyAndReturn
   */
  export type SchoolProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolPrograms.
     */
    data: SchoolProgramCreateManyInput | SchoolProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolProgram update
   */
  export type SchoolProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolProgram.
     */
    data: XOR<SchoolProgramUpdateInput, SchoolProgramUncheckedUpdateInput>
    /**
     * Choose, which SchoolProgram to update.
     */
    where: SchoolProgramWhereUniqueInput
  }

  /**
   * SchoolProgram updateMany
   */
  export type SchoolProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolPrograms.
     */
    data: XOR<SchoolProgramUpdateManyMutationInput, SchoolProgramUncheckedUpdateManyInput>
    /**
     * Filter which SchoolPrograms to update
     */
    where?: SchoolProgramWhereInput
  }

  /**
   * SchoolProgram upsert
   */
  export type SchoolProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolProgram to update in case it exists.
     */
    where: SchoolProgramWhereUniqueInput
    /**
     * In case the SchoolProgram found by the `where` argument doesn't exist, create a new SchoolProgram with this data.
     */
    create: XOR<SchoolProgramCreateInput, SchoolProgramUncheckedCreateInput>
    /**
     * In case the SchoolProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolProgramUpdateInput, SchoolProgramUncheckedUpdateInput>
  }

  /**
   * SchoolProgram delete
   */
  export type SchoolProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
    /**
     * Filter which SchoolProgram to delete.
     */
    where: SchoolProgramWhereUniqueInput
  }

  /**
   * SchoolProgram deleteMany
   */
  export type SchoolProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolPrograms to delete
     */
    where?: SchoolProgramWhereInput
  }

  /**
   * SchoolProgram.studentPrograms
   */
  export type SchoolProgram$studentProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    where?: StudentSchoolProgramWhereInput
    orderBy?: StudentSchoolProgramOrderByWithRelationInput | StudentSchoolProgramOrderByWithRelationInput[]
    cursor?: StudentSchoolProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSchoolProgramScalarFieldEnum | StudentSchoolProgramScalarFieldEnum[]
  }

  /**
   * SchoolProgram.images
   */
  export type SchoolProgram$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    where?: SchoolProgramImageWhereInput
    orderBy?: SchoolProgramImageOrderByWithRelationInput | SchoolProgramImageOrderByWithRelationInput[]
    cursor?: SchoolProgramImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolProgramImageScalarFieldEnum | SchoolProgramImageScalarFieldEnum[]
  }

  /**
   * SchoolProgram without action
   */
  export type SchoolProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgram
     */
    select?: SchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramInclude<ExtArgs> | null
  }


  /**
   * Model SchoolProgramImage
   */

  export type AggregateSchoolProgramImage = {
    _count: SchoolProgramImageCountAggregateOutputType | null
    _min: SchoolProgramImageMinAggregateOutputType | null
    _max: SchoolProgramImageMaxAggregateOutputType | null
  }

  export type SchoolProgramImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    programId: string | null
  }

  export type SchoolProgramImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    programId: string | null
  }

  export type SchoolProgramImageCountAggregateOutputType = {
    id: number
    url: number
    programId: number
    _all: number
  }


  export type SchoolProgramImageMinAggregateInputType = {
    id?: true
    url?: true
    programId?: true
  }

  export type SchoolProgramImageMaxAggregateInputType = {
    id?: true
    url?: true
    programId?: true
  }

  export type SchoolProgramImageCountAggregateInputType = {
    id?: true
    url?: true
    programId?: true
    _all?: true
  }

  export type SchoolProgramImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolProgramImage to aggregate.
     */
    where?: SchoolProgramImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolProgramImages to fetch.
     */
    orderBy?: SchoolProgramImageOrderByWithRelationInput | SchoolProgramImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolProgramImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolProgramImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolProgramImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolProgramImages
    **/
    _count?: true | SchoolProgramImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolProgramImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolProgramImageMaxAggregateInputType
  }

  export type GetSchoolProgramImageAggregateType<T extends SchoolProgramImageAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolProgramImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolProgramImage[P]>
      : GetScalarType<T[P], AggregateSchoolProgramImage[P]>
  }




  export type SchoolProgramImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolProgramImageWhereInput
    orderBy?: SchoolProgramImageOrderByWithAggregationInput | SchoolProgramImageOrderByWithAggregationInput[]
    by: SchoolProgramImageScalarFieldEnum[] | SchoolProgramImageScalarFieldEnum
    having?: SchoolProgramImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolProgramImageCountAggregateInputType | true
    _min?: SchoolProgramImageMinAggregateInputType
    _max?: SchoolProgramImageMaxAggregateInputType
  }

  export type SchoolProgramImageGroupByOutputType = {
    id: string
    url: string
    programId: string
    _count: SchoolProgramImageCountAggregateOutputType | null
    _min: SchoolProgramImageMinAggregateOutputType | null
    _max: SchoolProgramImageMaxAggregateOutputType | null
  }

  type GetSchoolProgramImageGroupByPayload<T extends SchoolProgramImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolProgramImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolProgramImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolProgramImageGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolProgramImageGroupByOutputType[P]>
        }
      >
    >


  export type SchoolProgramImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    programId?: boolean
    program?: boolean | SchoolProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolProgramImage"]>

  export type SchoolProgramImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    programId?: boolean
    program?: boolean | SchoolProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolProgramImage"]>

  export type SchoolProgramImageSelectScalar = {
    id?: boolean
    url?: boolean
    programId?: boolean
  }

  export type SchoolProgramImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | SchoolProgramDefaultArgs<ExtArgs>
  }
  export type SchoolProgramImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | SchoolProgramDefaultArgs<ExtArgs>
  }

  export type $SchoolProgramImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolProgramImage"
    objects: {
      program: Prisma.$SchoolProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      programId: string
    }, ExtArgs["result"]["schoolProgramImage"]>
    composites: {}
  }

  type SchoolProgramImageGetPayload<S extends boolean | null | undefined | SchoolProgramImageDefaultArgs> = $Result.GetResult<Prisma.$SchoolProgramImagePayload, S>

  type SchoolProgramImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolProgramImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolProgramImageCountAggregateInputType | true
    }

  export interface SchoolProgramImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolProgramImage'], meta: { name: 'SchoolProgramImage' } }
    /**
     * Find zero or one SchoolProgramImage that matches the filter.
     * @param {SchoolProgramImageFindUniqueArgs} args - Arguments to find a SchoolProgramImage
     * @example
     * // Get one SchoolProgramImage
     * const schoolProgramImage = await prisma.schoolProgramImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolProgramImageFindUniqueArgs>(args: SelectSubset<T, SchoolProgramImageFindUniqueArgs<ExtArgs>>): Prisma__SchoolProgramImageClient<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolProgramImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolProgramImageFindUniqueOrThrowArgs} args - Arguments to find a SchoolProgramImage
     * @example
     * // Get one SchoolProgramImage
     * const schoolProgramImage = await prisma.schoolProgramImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolProgramImageFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolProgramImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolProgramImageClient<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolProgramImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramImageFindFirstArgs} args - Arguments to find a SchoolProgramImage
     * @example
     * // Get one SchoolProgramImage
     * const schoolProgramImage = await prisma.schoolProgramImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolProgramImageFindFirstArgs>(args?: SelectSubset<T, SchoolProgramImageFindFirstArgs<ExtArgs>>): Prisma__SchoolProgramImageClient<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolProgramImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramImageFindFirstOrThrowArgs} args - Arguments to find a SchoolProgramImage
     * @example
     * // Get one SchoolProgramImage
     * const schoolProgramImage = await prisma.schoolProgramImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolProgramImageFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolProgramImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolProgramImageClient<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolProgramImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolProgramImages
     * const schoolProgramImages = await prisma.schoolProgramImage.findMany()
     * 
     * // Get first 10 SchoolProgramImages
     * const schoolProgramImages = await prisma.schoolProgramImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolProgramImageWithIdOnly = await prisma.schoolProgramImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolProgramImageFindManyArgs>(args?: SelectSubset<T, SchoolProgramImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolProgramImage.
     * @param {SchoolProgramImageCreateArgs} args - Arguments to create a SchoolProgramImage.
     * @example
     * // Create one SchoolProgramImage
     * const SchoolProgramImage = await prisma.schoolProgramImage.create({
     *   data: {
     *     // ... data to create a SchoolProgramImage
     *   }
     * })
     * 
     */
    create<T extends SchoolProgramImageCreateArgs>(args: SelectSubset<T, SchoolProgramImageCreateArgs<ExtArgs>>): Prisma__SchoolProgramImageClient<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolProgramImages.
     * @param {SchoolProgramImageCreateManyArgs} args - Arguments to create many SchoolProgramImages.
     * @example
     * // Create many SchoolProgramImages
     * const schoolProgramImage = await prisma.schoolProgramImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolProgramImageCreateManyArgs>(args?: SelectSubset<T, SchoolProgramImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolProgramImages and returns the data saved in the database.
     * @param {SchoolProgramImageCreateManyAndReturnArgs} args - Arguments to create many SchoolProgramImages.
     * @example
     * // Create many SchoolProgramImages
     * const schoolProgramImage = await prisma.schoolProgramImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolProgramImages and only return the `id`
     * const schoolProgramImageWithIdOnly = await prisma.schoolProgramImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolProgramImageCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolProgramImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolProgramImage.
     * @param {SchoolProgramImageDeleteArgs} args - Arguments to delete one SchoolProgramImage.
     * @example
     * // Delete one SchoolProgramImage
     * const SchoolProgramImage = await prisma.schoolProgramImage.delete({
     *   where: {
     *     // ... filter to delete one SchoolProgramImage
     *   }
     * })
     * 
     */
    delete<T extends SchoolProgramImageDeleteArgs>(args: SelectSubset<T, SchoolProgramImageDeleteArgs<ExtArgs>>): Prisma__SchoolProgramImageClient<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolProgramImage.
     * @param {SchoolProgramImageUpdateArgs} args - Arguments to update one SchoolProgramImage.
     * @example
     * // Update one SchoolProgramImage
     * const schoolProgramImage = await prisma.schoolProgramImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolProgramImageUpdateArgs>(args: SelectSubset<T, SchoolProgramImageUpdateArgs<ExtArgs>>): Prisma__SchoolProgramImageClient<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolProgramImages.
     * @param {SchoolProgramImageDeleteManyArgs} args - Arguments to filter SchoolProgramImages to delete.
     * @example
     * // Delete a few SchoolProgramImages
     * const { count } = await prisma.schoolProgramImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolProgramImageDeleteManyArgs>(args?: SelectSubset<T, SchoolProgramImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolProgramImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolProgramImages
     * const schoolProgramImage = await prisma.schoolProgramImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolProgramImageUpdateManyArgs>(args: SelectSubset<T, SchoolProgramImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolProgramImage.
     * @param {SchoolProgramImageUpsertArgs} args - Arguments to update or create a SchoolProgramImage.
     * @example
     * // Update or create a SchoolProgramImage
     * const schoolProgramImage = await prisma.schoolProgramImage.upsert({
     *   create: {
     *     // ... data to create a SchoolProgramImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolProgramImage we want to update
     *   }
     * })
     */
    upsert<T extends SchoolProgramImageUpsertArgs>(args: SelectSubset<T, SchoolProgramImageUpsertArgs<ExtArgs>>): Prisma__SchoolProgramImageClient<$Result.GetResult<Prisma.$SchoolProgramImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolProgramImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramImageCountArgs} args - Arguments to filter SchoolProgramImages to count.
     * @example
     * // Count the number of SchoolProgramImages
     * const count = await prisma.schoolProgramImage.count({
     *   where: {
     *     // ... the filter for the SchoolProgramImages we want to count
     *   }
     * })
    **/
    count<T extends SchoolProgramImageCountArgs>(
      args?: Subset<T, SchoolProgramImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolProgramImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolProgramImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolProgramImageAggregateArgs>(args: Subset<T, SchoolProgramImageAggregateArgs>): Prisma.PrismaPromise<GetSchoolProgramImageAggregateType<T>>

    /**
     * Group by SchoolProgramImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolProgramImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolProgramImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolProgramImageGroupByArgs['orderBy'] }
        : { orderBy?: SchoolProgramImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolProgramImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolProgramImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolProgramImage model
   */
  readonly fields: SchoolProgramImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolProgramImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolProgramImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends SchoolProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolProgramDefaultArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolProgramImage model
   */ 
  interface SchoolProgramImageFieldRefs {
    readonly id: FieldRef<"SchoolProgramImage", 'String'>
    readonly url: FieldRef<"SchoolProgramImage", 'String'>
    readonly programId: FieldRef<"SchoolProgramImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SchoolProgramImage findUnique
   */
  export type SchoolProgramImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolProgramImage to fetch.
     */
    where: SchoolProgramImageWhereUniqueInput
  }

  /**
   * SchoolProgramImage findUniqueOrThrow
   */
  export type SchoolProgramImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolProgramImage to fetch.
     */
    where: SchoolProgramImageWhereUniqueInput
  }

  /**
   * SchoolProgramImage findFirst
   */
  export type SchoolProgramImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolProgramImage to fetch.
     */
    where?: SchoolProgramImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolProgramImages to fetch.
     */
    orderBy?: SchoolProgramImageOrderByWithRelationInput | SchoolProgramImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolProgramImages.
     */
    cursor?: SchoolProgramImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolProgramImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolProgramImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolProgramImages.
     */
    distinct?: SchoolProgramImageScalarFieldEnum | SchoolProgramImageScalarFieldEnum[]
  }

  /**
   * SchoolProgramImage findFirstOrThrow
   */
  export type SchoolProgramImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolProgramImage to fetch.
     */
    where?: SchoolProgramImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolProgramImages to fetch.
     */
    orderBy?: SchoolProgramImageOrderByWithRelationInput | SchoolProgramImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolProgramImages.
     */
    cursor?: SchoolProgramImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolProgramImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolProgramImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolProgramImages.
     */
    distinct?: SchoolProgramImageScalarFieldEnum | SchoolProgramImageScalarFieldEnum[]
  }

  /**
   * SchoolProgramImage findMany
   */
  export type SchoolProgramImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    /**
     * Filter, which SchoolProgramImages to fetch.
     */
    where?: SchoolProgramImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolProgramImages to fetch.
     */
    orderBy?: SchoolProgramImageOrderByWithRelationInput | SchoolProgramImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolProgramImages.
     */
    cursor?: SchoolProgramImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolProgramImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolProgramImages.
     */
    skip?: number
    distinct?: SchoolProgramImageScalarFieldEnum | SchoolProgramImageScalarFieldEnum[]
  }

  /**
   * SchoolProgramImage create
   */
  export type SchoolProgramImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolProgramImage.
     */
    data: XOR<SchoolProgramImageCreateInput, SchoolProgramImageUncheckedCreateInput>
  }

  /**
   * SchoolProgramImage createMany
   */
  export type SchoolProgramImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolProgramImages.
     */
    data: SchoolProgramImageCreateManyInput | SchoolProgramImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolProgramImage createManyAndReturn
   */
  export type SchoolProgramImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolProgramImages.
     */
    data: SchoolProgramImageCreateManyInput | SchoolProgramImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolProgramImage update
   */
  export type SchoolProgramImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolProgramImage.
     */
    data: XOR<SchoolProgramImageUpdateInput, SchoolProgramImageUncheckedUpdateInput>
    /**
     * Choose, which SchoolProgramImage to update.
     */
    where: SchoolProgramImageWhereUniqueInput
  }

  /**
   * SchoolProgramImage updateMany
   */
  export type SchoolProgramImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolProgramImages.
     */
    data: XOR<SchoolProgramImageUpdateManyMutationInput, SchoolProgramImageUncheckedUpdateManyInput>
    /**
     * Filter which SchoolProgramImages to update
     */
    where?: SchoolProgramImageWhereInput
  }

  /**
   * SchoolProgramImage upsert
   */
  export type SchoolProgramImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolProgramImage to update in case it exists.
     */
    where: SchoolProgramImageWhereUniqueInput
    /**
     * In case the SchoolProgramImage found by the `where` argument doesn't exist, create a new SchoolProgramImage with this data.
     */
    create: XOR<SchoolProgramImageCreateInput, SchoolProgramImageUncheckedCreateInput>
    /**
     * In case the SchoolProgramImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolProgramImageUpdateInput, SchoolProgramImageUncheckedUpdateInput>
  }

  /**
   * SchoolProgramImage delete
   */
  export type SchoolProgramImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
    /**
     * Filter which SchoolProgramImage to delete.
     */
    where: SchoolProgramImageWhereUniqueInput
  }

  /**
   * SchoolProgramImage deleteMany
   */
  export type SchoolProgramImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolProgramImages to delete
     */
    where?: SchoolProgramImageWhereInput
  }

  /**
   * SchoolProgramImage without action
   */
  export type SchoolProgramImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolProgramImage
     */
    select?: SchoolProgramImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolProgramImageInclude<ExtArgs> | null
  }


  /**
   * Model StudentSchoolProgram
   */

  export type AggregateStudentSchoolProgram = {
    _count: StudentSchoolProgramCountAggregateOutputType | null
    _min: StudentSchoolProgramMinAggregateOutputType | null
    _max: StudentSchoolProgramMaxAggregateOutputType | null
  }

  export type StudentSchoolProgramMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    programId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSchoolProgramMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    programId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSchoolProgramCountAggregateOutputType = {
    id: number
    studentId: number
    programId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentSchoolProgramMinAggregateInputType = {
    id?: true
    studentId?: true
    programId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSchoolProgramMaxAggregateInputType = {
    id?: true
    studentId?: true
    programId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSchoolProgramCountAggregateInputType = {
    id?: true
    studentId?: true
    programId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentSchoolProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSchoolProgram to aggregate.
     */
    where?: StudentSchoolProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolPrograms to fetch.
     */
    orderBy?: StudentSchoolProgramOrderByWithRelationInput | StudentSchoolProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSchoolProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSchoolPrograms
    **/
    _count?: true | StudentSchoolProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSchoolProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSchoolProgramMaxAggregateInputType
  }

  export type GetStudentSchoolProgramAggregateType<T extends StudentSchoolProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSchoolProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSchoolProgram[P]>
      : GetScalarType<T[P], AggregateStudentSchoolProgram[P]>
  }




  export type StudentSchoolProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSchoolProgramWhereInput
    orderBy?: StudentSchoolProgramOrderByWithAggregationInput | StudentSchoolProgramOrderByWithAggregationInput[]
    by: StudentSchoolProgramScalarFieldEnum[] | StudentSchoolProgramScalarFieldEnum
    having?: StudentSchoolProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSchoolProgramCountAggregateInputType | true
    _min?: StudentSchoolProgramMinAggregateInputType
    _max?: StudentSchoolProgramMaxAggregateInputType
  }

  export type StudentSchoolProgramGroupByOutputType = {
    id: string
    studentId: string
    programId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentSchoolProgramCountAggregateOutputType | null
    _min: StudentSchoolProgramMinAggregateOutputType | null
    _max: StudentSchoolProgramMaxAggregateOutputType | null
  }

  type GetStudentSchoolProgramGroupByPayload<T extends StudentSchoolProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSchoolProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSchoolProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSchoolProgramGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSchoolProgramGroupByOutputType[P]>
        }
      >
    >


  export type StudentSchoolProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    programId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    program?: boolean | SchoolProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSchoolProgram"]>

  export type StudentSchoolProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    programId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    program?: boolean | SchoolProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSchoolProgram"]>

  export type StudentSchoolProgramSelectScalar = {
    id?: boolean
    studentId?: boolean
    programId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentSchoolProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    program?: boolean | SchoolProgramDefaultArgs<ExtArgs>
  }
  export type StudentSchoolProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    program?: boolean | SchoolProgramDefaultArgs<ExtArgs>
  }

  export type $StudentSchoolProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSchoolProgram"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      program: Prisma.$SchoolProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      programId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentSchoolProgram"]>
    composites: {}
  }

  type StudentSchoolProgramGetPayload<S extends boolean | null | undefined | StudentSchoolProgramDefaultArgs> = $Result.GetResult<Prisma.$StudentSchoolProgramPayload, S>

  type StudentSchoolProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentSchoolProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentSchoolProgramCountAggregateInputType | true
    }

  export interface StudentSchoolProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSchoolProgram'], meta: { name: 'StudentSchoolProgram' } }
    /**
     * Find zero or one StudentSchoolProgram that matches the filter.
     * @param {StudentSchoolProgramFindUniqueArgs} args - Arguments to find a StudentSchoolProgram
     * @example
     * // Get one StudentSchoolProgram
     * const studentSchoolProgram = await prisma.studentSchoolProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSchoolProgramFindUniqueArgs>(args: SelectSubset<T, StudentSchoolProgramFindUniqueArgs<ExtArgs>>): Prisma__StudentSchoolProgramClient<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentSchoolProgram that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentSchoolProgramFindUniqueOrThrowArgs} args - Arguments to find a StudentSchoolProgram
     * @example
     * // Get one StudentSchoolProgram
     * const studentSchoolProgram = await prisma.studentSchoolProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSchoolProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSchoolProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSchoolProgramClient<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentSchoolProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolProgramFindFirstArgs} args - Arguments to find a StudentSchoolProgram
     * @example
     * // Get one StudentSchoolProgram
     * const studentSchoolProgram = await prisma.studentSchoolProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSchoolProgramFindFirstArgs>(args?: SelectSubset<T, StudentSchoolProgramFindFirstArgs<ExtArgs>>): Prisma__StudentSchoolProgramClient<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentSchoolProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolProgramFindFirstOrThrowArgs} args - Arguments to find a StudentSchoolProgram
     * @example
     * // Get one StudentSchoolProgram
     * const studentSchoolProgram = await prisma.studentSchoolProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSchoolProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSchoolProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSchoolProgramClient<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentSchoolPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSchoolPrograms
     * const studentSchoolPrograms = await prisma.studentSchoolProgram.findMany()
     * 
     * // Get first 10 StudentSchoolPrograms
     * const studentSchoolPrograms = await prisma.studentSchoolProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSchoolProgramWithIdOnly = await prisma.studentSchoolProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSchoolProgramFindManyArgs>(args?: SelectSubset<T, StudentSchoolProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentSchoolProgram.
     * @param {StudentSchoolProgramCreateArgs} args - Arguments to create a StudentSchoolProgram.
     * @example
     * // Create one StudentSchoolProgram
     * const StudentSchoolProgram = await prisma.studentSchoolProgram.create({
     *   data: {
     *     // ... data to create a StudentSchoolProgram
     *   }
     * })
     * 
     */
    create<T extends StudentSchoolProgramCreateArgs>(args: SelectSubset<T, StudentSchoolProgramCreateArgs<ExtArgs>>): Prisma__StudentSchoolProgramClient<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentSchoolPrograms.
     * @param {StudentSchoolProgramCreateManyArgs} args - Arguments to create many StudentSchoolPrograms.
     * @example
     * // Create many StudentSchoolPrograms
     * const studentSchoolProgram = await prisma.studentSchoolProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSchoolProgramCreateManyArgs>(args?: SelectSubset<T, StudentSchoolProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentSchoolPrograms and returns the data saved in the database.
     * @param {StudentSchoolProgramCreateManyAndReturnArgs} args - Arguments to create many StudentSchoolPrograms.
     * @example
     * // Create many StudentSchoolPrograms
     * const studentSchoolProgram = await prisma.studentSchoolProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentSchoolPrograms and only return the `id`
     * const studentSchoolProgramWithIdOnly = await prisma.studentSchoolProgram.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentSchoolProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentSchoolProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentSchoolProgram.
     * @param {StudentSchoolProgramDeleteArgs} args - Arguments to delete one StudentSchoolProgram.
     * @example
     * // Delete one StudentSchoolProgram
     * const StudentSchoolProgram = await prisma.studentSchoolProgram.delete({
     *   where: {
     *     // ... filter to delete one StudentSchoolProgram
     *   }
     * })
     * 
     */
    delete<T extends StudentSchoolProgramDeleteArgs>(args: SelectSubset<T, StudentSchoolProgramDeleteArgs<ExtArgs>>): Prisma__StudentSchoolProgramClient<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentSchoolProgram.
     * @param {StudentSchoolProgramUpdateArgs} args - Arguments to update one StudentSchoolProgram.
     * @example
     * // Update one StudentSchoolProgram
     * const studentSchoolProgram = await prisma.studentSchoolProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSchoolProgramUpdateArgs>(args: SelectSubset<T, StudentSchoolProgramUpdateArgs<ExtArgs>>): Prisma__StudentSchoolProgramClient<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentSchoolPrograms.
     * @param {StudentSchoolProgramDeleteManyArgs} args - Arguments to filter StudentSchoolPrograms to delete.
     * @example
     * // Delete a few StudentSchoolPrograms
     * const { count } = await prisma.studentSchoolProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSchoolProgramDeleteManyArgs>(args?: SelectSubset<T, StudentSchoolProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSchoolPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSchoolPrograms
     * const studentSchoolProgram = await prisma.studentSchoolProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSchoolProgramUpdateManyArgs>(args: SelectSubset<T, StudentSchoolProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSchoolProgram.
     * @param {StudentSchoolProgramUpsertArgs} args - Arguments to update or create a StudentSchoolProgram.
     * @example
     * // Update or create a StudentSchoolProgram
     * const studentSchoolProgram = await prisma.studentSchoolProgram.upsert({
     *   create: {
     *     // ... data to create a StudentSchoolProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSchoolProgram we want to update
     *   }
     * })
     */
    upsert<T extends StudentSchoolProgramUpsertArgs>(args: SelectSubset<T, StudentSchoolProgramUpsertArgs<ExtArgs>>): Prisma__StudentSchoolProgramClient<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentSchoolPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolProgramCountArgs} args - Arguments to filter StudentSchoolPrograms to count.
     * @example
     * // Count the number of StudentSchoolPrograms
     * const count = await prisma.studentSchoolProgram.count({
     *   where: {
     *     // ... the filter for the StudentSchoolPrograms we want to count
     *   }
     * })
    **/
    count<T extends StudentSchoolProgramCountArgs>(
      args?: Subset<T, StudentSchoolProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSchoolProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSchoolProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSchoolProgramAggregateArgs>(args: Subset<T, StudentSchoolProgramAggregateArgs>): Prisma.PrismaPromise<GetStudentSchoolProgramAggregateType<T>>

    /**
     * Group by StudentSchoolProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSchoolProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSchoolProgramGroupByArgs['orderBy'] }
        : { orderBy?: StudentSchoolProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSchoolProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSchoolProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSchoolProgram model
   */
  readonly fields: StudentSchoolProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSchoolProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSchoolProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    program<T extends SchoolProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolProgramDefaultArgs<ExtArgs>>): Prisma__SchoolProgramClient<$Result.GetResult<Prisma.$SchoolProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSchoolProgram model
   */ 
  interface StudentSchoolProgramFieldRefs {
    readonly id: FieldRef<"StudentSchoolProgram", 'String'>
    readonly studentId: FieldRef<"StudentSchoolProgram", 'String'>
    readonly programId: FieldRef<"StudentSchoolProgram", 'String'>
    readonly createdAt: FieldRef<"StudentSchoolProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSchoolProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentSchoolProgram findUnique
   */
  export type StudentSchoolProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolProgram to fetch.
     */
    where: StudentSchoolProgramWhereUniqueInput
  }

  /**
   * StudentSchoolProgram findUniqueOrThrow
   */
  export type StudentSchoolProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolProgram to fetch.
     */
    where: StudentSchoolProgramWhereUniqueInput
  }

  /**
   * StudentSchoolProgram findFirst
   */
  export type StudentSchoolProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolProgram to fetch.
     */
    where?: StudentSchoolProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolPrograms to fetch.
     */
    orderBy?: StudentSchoolProgramOrderByWithRelationInput | StudentSchoolProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSchoolPrograms.
     */
    cursor?: StudentSchoolProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSchoolPrograms.
     */
    distinct?: StudentSchoolProgramScalarFieldEnum | StudentSchoolProgramScalarFieldEnum[]
  }

  /**
   * StudentSchoolProgram findFirstOrThrow
   */
  export type StudentSchoolProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolProgram to fetch.
     */
    where?: StudentSchoolProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolPrograms to fetch.
     */
    orderBy?: StudentSchoolProgramOrderByWithRelationInput | StudentSchoolProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSchoolPrograms.
     */
    cursor?: StudentSchoolProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSchoolPrograms.
     */
    distinct?: StudentSchoolProgramScalarFieldEnum | StudentSchoolProgramScalarFieldEnum[]
  }

  /**
   * StudentSchoolProgram findMany
   */
  export type StudentSchoolProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolPrograms to fetch.
     */
    where?: StudentSchoolProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolPrograms to fetch.
     */
    orderBy?: StudentSchoolProgramOrderByWithRelationInput | StudentSchoolProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSchoolPrograms.
     */
    cursor?: StudentSchoolProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolPrograms.
     */
    skip?: number
    distinct?: StudentSchoolProgramScalarFieldEnum | StudentSchoolProgramScalarFieldEnum[]
  }

  /**
   * StudentSchoolProgram create
   */
  export type StudentSchoolProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSchoolProgram.
     */
    data: XOR<StudentSchoolProgramCreateInput, StudentSchoolProgramUncheckedCreateInput>
  }

  /**
   * StudentSchoolProgram createMany
   */
  export type StudentSchoolProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSchoolPrograms.
     */
    data: StudentSchoolProgramCreateManyInput | StudentSchoolProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSchoolProgram createManyAndReturn
   */
  export type StudentSchoolProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentSchoolPrograms.
     */
    data: StudentSchoolProgramCreateManyInput | StudentSchoolProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSchoolProgram update
   */
  export type StudentSchoolProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSchoolProgram.
     */
    data: XOR<StudentSchoolProgramUpdateInput, StudentSchoolProgramUncheckedUpdateInput>
    /**
     * Choose, which StudentSchoolProgram to update.
     */
    where: StudentSchoolProgramWhereUniqueInput
  }

  /**
   * StudentSchoolProgram updateMany
   */
  export type StudentSchoolProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSchoolPrograms.
     */
    data: XOR<StudentSchoolProgramUpdateManyMutationInput, StudentSchoolProgramUncheckedUpdateManyInput>
    /**
     * Filter which StudentSchoolPrograms to update
     */
    where?: StudentSchoolProgramWhereInput
  }

  /**
   * StudentSchoolProgram upsert
   */
  export type StudentSchoolProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSchoolProgram to update in case it exists.
     */
    where: StudentSchoolProgramWhereUniqueInput
    /**
     * In case the StudentSchoolProgram found by the `where` argument doesn't exist, create a new StudentSchoolProgram with this data.
     */
    create: XOR<StudentSchoolProgramCreateInput, StudentSchoolProgramUncheckedCreateInput>
    /**
     * In case the StudentSchoolProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSchoolProgramUpdateInput, StudentSchoolProgramUncheckedUpdateInput>
  }

  /**
   * StudentSchoolProgram delete
   */
  export type StudentSchoolProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    /**
     * Filter which StudentSchoolProgram to delete.
     */
    where: StudentSchoolProgramWhereUniqueInput
  }

  /**
   * StudentSchoolProgram deleteMany
   */
  export type StudentSchoolProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSchoolPrograms to delete
     */
    where?: StudentSchoolProgramWhereInput
  }

  /**
   * StudentSchoolProgram without action
   */
  export type StudentSchoolProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
  }


  /**
   * Model StudentSchoolLocation
   */

  export type AggregateStudentSchoolLocation = {
    _count: StudentSchoolLocationCountAggregateOutputType | null
    _min: StudentSchoolLocationMinAggregateOutputType | null
    _max: StudentSchoolLocationMaxAggregateOutputType | null
  }

  export type StudentSchoolLocationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSchoolLocationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSchoolLocationCountAggregateOutputType = {
    id: number
    studentId: number
    locationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentSchoolLocationMinAggregateInputType = {
    id?: true
    studentId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSchoolLocationMaxAggregateInputType = {
    id?: true
    studentId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSchoolLocationCountAggregateInputType = {
    id?: true
    studentId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentSchoolLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSchoolLocation to aggregate.
     */
    where?: StudentSchoolLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolLocations to fetch.
     */
    orderBy?: StudentSchoolLocationOrderByWithRelationInput | StudentSchoolLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSchoolLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSchoolLocations
    **/
    _count?: true | StudentSchoolLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSchoolLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSchoolLocationMaxAggregateInputType
  }

  export type GetStudentSchoolLocationAggregateType<T extends StudentSchoolLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSchoolLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSchoolLocation[P]>
      : GetScalarType<T[P], AggregateStudentSchoolLocation[P]>
  }




  export type StudentSchoolLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSchoolLocationWhereInput
    orderBy?: StudentSchoolLocationOrderByWithAggregationInput | StudentSchoolLocationOrderByWithAggregationInput[]
    by: StudentSchoolLocationScalarFieldEnum[] | StudentSchoolLocationScalarFieldEnum
    having?: StudentSchoolLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSchoolLocationCountAggregateInputType | true
    _min?: StudentSchoolLocationMinAggregateInputType
    _max?: StudentSchoolLocationMaxAggregateInputType
  }

  export type StudentSchoolLocationGroupByOutputType = {
    id: string
    studentId: string
    locationId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentSchoolLocationCountAggregateOutputType | null
    _min: StudentSchoolLocationMinAggregateOutputType | null
    _max: StudentSchoolLocationMaxAggregateOutputType | null
  }

  type GetStudentSchoolLocationGroupByPayload<T extends StudentSchoolLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSchoolLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSchoolLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSchoolLocationGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSchoolLocationGroupByOutputType[P]>
        }
      >
    >


  export type StudentSchoolLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSchoolLocation"]>

  export type StudentSchoolLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSchoolLocation"]>

  export type StudentSchoolLocationSelectScalar = {
    id?: boolean
    studentId?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentSchoolLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }
  export type StudentSchoolLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    location?: boolean | SchoolLocationDefaultArgs<ExtArgs>
  }

  export type $StudentSchoolLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSchoolLocation"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      location: Prisma.$SchoolLocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      locationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentSchoolLocation"]>
    composites: {}
  }

  type StudentSchoolLocationGetPayload<S extends boolean | null | undefined | StudentSchoolLocationDefaultArgs> = $Result.GetResult<Prisma.$StudentSchoolLocationPayload, S>

  type StudentSchoolLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentSchoolLocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentSchoolLocationCountAggregateInputType | true
    }

  export interface StudentSchoolLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSchoolLocation'], meta: { name: 'StudentSchoolLocation' } }
    /**
     * Find zero or one StudentSchoolLocation that matches the filter.
     * @param {StudentSchoolLocationFindUniqueArgs} args - Arguments to find a StudentSchoolLocation
     * @example
     * // Get one StudentSchoolLocation
     * const studentSchoolLocation = await prisma.studentSchoolLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSchoolLocationFindUniqueArgs>(args: SelectSubset<T, StudentSchoolLocationFindUniqueArgs<ExtArgs>>): Prisma__StudentSchoolLocationClient<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentSchoolLocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentSchoolLocationFindUniqueOrThrowArgs} args - Arguments to find a StudentSchoolLocation
     * @example
     * // Get one StudentSchoolLocation
     * const studentSchoolLocation = await prisma.studentSchoolLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSchoolLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSchoolLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSchoolLocationClient<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentSchoolLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolLocationFindFirstArgs} args - Arguments to find a StudentSchoolLocation
     * @example
     * // Get one StudentSchoolLocation
     * const studentSchoolLocation = await prisma.studentSchoolLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSchoolLocationFindFirstArgs>(args?: SelectSubset<T, StudentSchoolLocationFindFirstArgs<ExtArgs>>): Prisma__StudentSchoolLocationClient<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentSchoolLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolLocationFindFirstOrThrowArgs} args - Arguments to find a StudentSchoolLocation
     * @example
     * // Get one StudentSchoolLocation
     * const studentSchoolLocation = await prisma.studentSchoolLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSchoolLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSchoolLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSchoolLocationClient<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentSchoolLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSchoolLocations
     * const studentSchoolLocations = await prisma.studentSchoolLocation.findMany()
     * 
     * // Get first 10 StudentSchoolLocations
     * const studentSchoolLocations = await prisma.studentSchoolLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSchoolLocationWithIdOnly = await prisma.studentSchoolLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSchoolLocationFindManyArgs>(args?: SelectSubset<T, StudentSchoolLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentSchoolLocation.
     * @param {StudentSchoolLocationCreateArgs} args - Arguments to create a StudentSchoolLocation.
     * @example
     * // Create one StudentSchoolLocation
     * const StudentSchoolLocation = await prisma.studentSchoolLocation.create({
     *   data: {
     *     // ... data to create a StudentSchoolLocation
     *   }
     * })
     * 
     */
    create<T extends StudentSchoolLocationCreateArgs>(args: SelectSubset<T, StudentSchoolLocationCreateArgs<ExtArgs>>): Prisma__StudentSchoolLocationClient<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentSchoolLocations.
     * @param {StudentSchoolLocationCreateManyArgs} args - Arguments to create many StudentSchoolLocations.
     * @example
     * // Create many StudentSchoolLocations
     * const studentSchoolLocation = await prisma.studentSchoolLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSchoolLocationCreateManyArgs>(args?: SelectSubset<T, StudentSchoolLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentSchoolLocations and returns the data saved in the database.
     * @param {StudentSchoolLocationCreateManyAndReturnArgs} args - Arguments to create many StudentSchoolLocations.
     * @example
     * // Create many StudentSchoolLocations
     * const studentSchoolLocation = await prisma.studentSchoolLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentSchoolLocations and only return the `id`
     * const studentSchoolLocationWithIdOnly = await prisma.studentSchoolLocation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentSchoolLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentSchoolLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentSchoolLocation.
     * @param {StudentSchoolLocationDeleteArgs} args - Arguments to delete one StudentSchoolLocation.
     * @example
     * // Delete one StudentSchoolLocation
     * const StudentSchoolLocation = await prisma.studentSchoolLocation.delete({
     *   where: {
     *     // ... filter to delete one StudentSchoolLocation
     *   }
     * })
     * 
     */
    delete<T extends StudentSchoolLocationDeleteArgs>(args: SelectSubset<T, StudentSchoolLocationDeleteArgs<ExtArgs>>): Prisma__StudentSchoolLocationClient<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentSchoolLocation.
     * @param {StudentSchoolLocationUpdateArgs} args - Arguments to update one StudentSchoolLocation.
     * @example
     * // Update one StudentSchoolLocation
     * const studentSchoolLocation = await prisma.studentSchoolLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSchoolLocationUpdateArgs>(args: SelectSubset<T, StudentSchoolLocationUpdateArgs<ExtArgs>>): Prisma__StudentSchoolLocationClient<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentSchoolLocations.
     * @param {StudentSchoolLocationDeleteManyArgs} args - Arguments to filter StudentSchoolLocations to delete.
     * @example
     * // Delete a few StudentSchoolLocations
     * const { count } = await prisma.studentSchoolLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSchoolLocationDeleteManyArgs>(args?: SelectSubset<T, StudentSchoolLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSchoolLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSchoolLocations
     * const studentSchoolLocation = await prisma.studentSchoolLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSchoolLocationUpdateManyArgs>(args: SelectSubset<T, StudentSchoolLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSchoolLocation.
     * @param {StudentSchoolLocationUpsertArgs} args - Arguments to update or create a StudentSchoolLocation.
     * @example
     * // Update or create a StudentSchoolLocation
     * const studentSchoolLocation = await prisma.studentSchoolLocation.upsert({
     *   create: {
     *     // ... data to create a StudentSchoolLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSchoolLocation we want to update
     *   }
     * })
     */
    upsert<T extends StudentSchoolLocationUpsertArgs>(args: SelectSubset<T, StudentSchoolLocationUpsertArgs<ExtArgs>>): Prisma__StudentSchoolLocationClient<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentSchoolLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolLocationCountArgs} args - Arguments to filter StudentSchoolLocations to count.
     * @example
     * // Count the number of StudentSchoolLocations
     * const count = await prisma.studentSchoolLocation.count({
     *   where: {
     *     // ... the filter for the StudentSchoolLocations we want to count
     *   }
     * })
    **/
    count<T extends StudentSchoolLocationCountArgs>(
      args?: Subset<T, StudentSchoolLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSchoolLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSchoolLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSchoolLocationAggregateArgs>(args: Subset<T, StudentSchoolLocationAggregateArgs>): Prisma.PrismaPromise<GetStudentSchoolLocationAggregateType<T>>

    /**
     * Group by StudentSchoolLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSchoolLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSchoolLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSchoolLocationGroupByArgs['orderBy'] }
        : { orderBy?: StudentSchoolLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSchoolLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSchoolLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSchoolLocation model
   */
  readonly fields: StudentSchoolLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSchoolLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSchoolLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    location<T extends SchoolLocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolLocationDefaultArgs<ExtArgs>>): Prisma__SchoolLocationClient<$Result.GetResult<Prisma.$SchoolLocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSchoolLocation model
   */ 
  interface StudentSchoolLocationFieldRefs {
    readonly id: FieldRef<"StudentSchoolLocation", 'String'>
    readonly studentId: FieldRef<"StudentSchoolLocation", 'String'>
    readonly locationId: FieldRef<"StudentSchoolLocation", 'String'>
    readonly createdAt: FieldRef<"StudentSchoolLocation", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSchoolLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentSchoolLocation findUnique
   */
  export type StudentSchoolLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolLocation to fetch.
     */
    where: StudentSchoolLocationWhereUniqueInput
  }

  /**
   * StudentSchoolLocation findUniqueOrThrow
   */
  export type StudentSchoolLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolLocation to fetch.
     */
    where: StudentSchoolLocationWhereUniqueInput
  }

  /**
   * StudentSchoolLocation findFirst
   */
  export type StudentSchoolLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolLocation to fetch.
     */
    where?: StudentSchoolLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolLocations to fetch.
     */
    orderBy?: StudentSchoolLocationOrderByWithRelationInput | StudentSchoolLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSchoolLocations.
     */
    cursor?: StudentSchoolLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSchoolLocations.
     */
    distinct?: StudentSchoolLocationScalarFieldEnum | StudentSchoolLocationScalarFieldEnum[]
  }

  /**
   * StudentSchoolLocation findFirstOrThrow
   */
  export type StudentSchoolLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolLocation to fetch.
     */
    where?: StudentSchoolLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolLocations to fetch.
     */
    orderBy?: StudentSchoolLocationOrderByWithRelationInput | StudentSchoolLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSchoolLocations.
     */
    cursor?: StudentSchoolLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSchoolLocations.
     */
    distinct?: StudentSchoolLocationScalarFieldEnum | StudentSchoolLocationScalarFieldEnum[]
  }

  /**
   * StudentSchoolLocation findMany
   */
  export type StudentSchoolLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSchoolLocations to fetch.
     */
    where?: StudentSchoolLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSchoolLocations to fetch.
     */
    orderBy?: StudentSchoolLocationOrderByWithRelationInput | StudentSchoolLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSchoolLocations.
     */
    cursor?: StudentSchoolLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSchoolLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSchoolLocations.
     */
    skip?: number
    distinct?: StudentSchoolLocationScalarFieldEnum | StudentSchoolLocationScalarFieldEnum[]
  }

  /**
   * StudentSchoolLocation create
   */
  export type StudentSchoolLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSchoolLocation.
     */
    data: XOR<StudentSchoolLocationCreateInput, StudentSchoolLocationUncheckedCreateInput>
  }

  /**
   * StudentSchoolLocation createMany
   */
  export type StudentSchoolLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSchoolLocations.
     */
    data: StudentSchoolLocationCreateManyInput | StudentSchoolLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSchoolLocation createManyAndReturn
   */
  export type StudentSchoolLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentSchoolLocations.
     */
    data: StudentSchoolLocationCreateManyInput | StudentSchoolLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSchoolLocation update
   */
  export type StudentSchoolLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSchoolLocation.
     */
    data: XOR<StudentSchoolLocationUpdateInput, StudentSchoolLocationUncheckedUpdateInput>
    /**
     * Choose, which StudentSchoolLocation to update.
     */
    where: StudentSchoolLocationWhereUniqueInput
  }

  /**
   * StudentSchoolLocation updateMany
   */
  export type StudentSchoolLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSchoolLocations.
     */
    data: XOR<StudentSchoolLocationUpdateManyMutationInput, StudentSchoolLocationUncheckedUpdateManyInput>
    /**
     * Filter which StudentSchoolLocations to update
     */
    where?: StudentSchoolLocationWhereInput
  }

  /**
   * StudentSchoolLocation upsert
   */
  export type StudentSchoolLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSchoolLocation to update in case it exists.
     */
    where: StudentSchoolLocationWhereUniqueInput
    /**
     * In case the StudentSchoolLocation found by the `where` argument doesn't exist, create a new StudentSchoolLocation with this data.
     */
    create: XOR<StudentSchoolLocationCreateInput, StudentSchoolLocationUncheckedCreateInput>
    /**
     * In case the StudentSchoolLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSchoolLocationUpdateInput, StudentSchoolLocationUncheckedUpdateInput>
  }

  /**
   * StudentSchoolLocation delete
   */
  export type StudentSchoolLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    /**
     * Filter which StudentSchoolLocation to delete.
     */
    where: StudentSchoolLocationWhereUniqueInput
  }

  /**
   * StudentSchoolLocation deleteMany
   */
  export type StudentSchoolLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSchoolLocations to delete
     */
    where?: StudentSchoolLocationWhereInput
  }

  /**
   * StudentSchoolLocation without action
   */
  export type StudentSchoolLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    gradeScore: number | null
  }

  export type StudentSumAggregateOutputType = {
    gradeScore: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    studentCode: string | null
    degreeType: $Enums.DegreeType | null
    certificateType: $Enums.CertificateType | null
    certificateImg: string | null
    gradeType: $Enums.GradeType | null
    gradeScore: number | null
    cover: string | null
    additional: string | null
    status: $Enums.StudentStatus | null
    accountId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    studentCode: string | null
    degreeType: $Enums.DegreeType | null
    certificateType: $Enums.CertificateType | null
    certificateImg: string | null
    gradeType: $Enums.GradeType | null
    gradeScore: number | null
    cover: string | null
    additional: string | null
    status: $Enums.StudentStatus | null
    accountId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    studentCode: number
    degreeType: number
    certificateType: number
    certificateImg: number
    gradeType: number
    gradeScore: number
    cover: number
    additional: number
    status: number
    accountId: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    gradeScore?: true
  }

  export type StudentSumAggregateInputType = {
    gradeScore?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    studentCode?: true
    degreeType?: true
    certificateType?: true
    certificateImg?: true
    gradeType?: true
    gradeScore?: true
    cover?: true
    additional?: true
    status?: true
    accountId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    studentCode?: true
    degreeType?: true
    certificateType?: true
    certificateImg?: true
    gradeType?: true
    gradeScore?: true
    cover?: true
    additional?: true
    status?: true
    accountId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    studentCode?: true
    degreeType?: true
    certificateType?: true
    certificateImg?: true
    gradeType?: true
    gradeScore?: true
    cover?: true
    additional?: true
    status?: true
    accountId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    studentCode: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover: string | null
    additional: string | null
    status: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentCode?: boolean
    degreeType?: boolean
    certificateType?: boolean
    certificateImg?: boolean
    gradeType?: boolean
    gradeScore?: boolean
    cover?: boolean
    additional?: boolean
    status?: boolean
    accountId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    messeages?: boolean | Student$messeagesArgs<ExtArgs>
    chats?: boolean | Student$chatsArgs<ExtArgs>
    profile?: boolean | Student$profileArgs<ExtArgs>
    program?: boolean | Student$programArgs<ExtArgs>
    location?: boolean | Student$locationArgs<ExtArgs>
    scholarship?: boolean | Student$scholarshipArgs<ExtArgs>
    notifications?: boolean | Student$notificationsArgs<ExtArgs>
    ownedNotifications?: boolean | Student$ownedNotificationsArgs<ExtArgs>
    follows?: boolean | Student$followsArgs<ExtArgs>
    followers?: boolean | Student$followersArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentCode?: boolean
    degreeType?: boolean
    certificateType?: boolean
    certificateImg?: boolean
    gradeType?: boolean
    gradeScore?: boolean
    cover?: boolean
    additional?: boolean
    status?: boolean
    accountId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    studentCode?: boolean
    degreeType?: boolean
    certificateType?: boolean
    certificateImg?: boolean
    gradeType?: boolean
    gradeScore?: boolean
    cover?: boolean
    additional?: boolean
    status?: boolean
    accountId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    messeages?: boolean | Student$messeagesArgs<ExtArgs>
    chats?: boolean | Student$chatsArgs<ExtArgs>
    profile?: boolean | Student$profileArgs<ExtArgs>
    program?: boolean | Student$programArgs<ExtArgs>
    location?: boolean | Student$locationArgs<ExtArgs>
    scholarship?: boolean | Student$scholarshipArgs<ExtArgs>
    notifications?: boolean | Student$notificationsArgs<ExtArgs>
    ownedNotifications?: boolean | Student$ownedNotificationsArgs<ExtArgs>
    follows?: boolean | Student$followsArgs<ExtArgs>
    followers?: boolean | Student$followersArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
      messeages: Prisma.$MessagePayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      program: Prisma.$StudentSchoolProgramPayload<ExtArgs> | null
      location: Prisma.$StudentSchoolLocationPayload<ExtArgs> | null
      scholarship: Prisma.$StudentSchoolScholarshipPayload<ExtArgs>[]
      notifications: Prisma.$NewsNotificationPayload<ExtArgs>[]
      ownedNotifications: Prisma.$NewsNotificationPayload<ExtArgs>[]
      follows: Prisma.$StudentFollowPayload<ExtArgs>[]
      followers: Prisma.$StudentFollowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentCode: string | null
      degreeType: $Enums.DegreeType
      certificateType: $Enums.CertificateType
      certificateImg: string
      gradeType: $Enums.GradeType
      gradeScore: number
      cover: string | null
      additional: string | null
      status: $Enums.StudentStatus
      accountId: string
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messeages<T extends Student$messeagesArgs<ExtArgs> = {}>(args?: Subset<T, Student$messeagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    chats<T extends Student$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Student$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends Student$profileArgs<ExtArgs> = {}>(args?: Subset<T, Student$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    program<T extends Student$programArgs<ExtArgs> = {}>(args?: Subset<T, Student$programArgs<ExtArgs>>): Prisma__StudentSchoolProgramClient<$Result.GetResult<Prisma.$StudentSchoolProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    location<T extends Student$locationArgs<ExtArgs> = {}>(args?: Subset<T, Student$locationArgs<ExtArgs>>): Prisma__StudentSchoolLocationClient<$Result.GetResult<Prisma.$StudentSchoolLocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    scholarship<T extends Student$scholarshipArgs<ExtArgs> = {}>(args?: Subset<T, Student$scholarshipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSchoolScholarshipPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Student$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    ownedNotifications<T extends Student$ownedNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$ownedNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    follows<T extends Student$followsArgs<ExtArgs> = {}>(args?: Subset<T, Student$followsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "findMany"> | Null>
    followers<T extends Student$followersArgs<ExtArgs> = {}>(args?: Subset<T, Student$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly studentCode: FieldRef<"Student", 'String'>
    readonly degreeType: FieldRef<"Student", 'DegreeType'>
    readonly certificateType: FieldRef<"Student", 'CertificateType'>
    readonly certificateImg: FieldRef<"Student", 'String'>
    readonly gradeType: FieldRef<"Student", 'GradeType'>
    readonly gradeScore: FieldRef<"Student", 'Float'>
    readonly cover: FieldRef<"Student", 'String'>
    readonly additional: FieldRef<"Student", 'String'>
    readonly status: FieldRef<"Student", 'StudentStatus'>
    readonly accountId: FieldRef<"Student", 'String'>
    readonly schoolId: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.messeages
   */
  export type Student$messeagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Student.chats
   */
  export type Student$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Student.profile
   */
  export type Student$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Student.program
   */
  export type Student$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolProgram
     */
    select?: StudentSchoolProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolProgramInclude<ExtArgs> | null
    where?: StudentSchoolProgramWhereInput
  }

  /**
   * Student.location
   */
  export type Student$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolLocation
     */
    select?: StudentSchoolLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolLocationInclude<ExtArgs> | null
    where?: StudentSchoolLocationWhereInput
  }

  /**
   * Student.scholarship
   */
  export type Student$scholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSchoolScholarship
     */
    select?: StudentSchoolScholarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSchoolScholarshipInclude<ExtArgs> | null
    where?: StudentSchoolScholarshipWhereInput
    orderBy?: StudentSchoolScholarshipOrderByWithRelationInput | StudentSchoolScholarshipOrderByWithRelationInput[]
    cursor?: StudentSchoolScholarshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSchoolScholarshipScalarFieldEnum | StudentSchoolScholarshipScalarFieldEnum[]
  }

  /**
   * Student.notifications
   */
  export type Student$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    where?: NewsNotificationWhereInput
    orderBy?: NewsNotificationOrderByWithRelationInput | NewsNotificationOrderByWithRelationInput[]
    cursor?: NewsNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsNotificationScalarFieldEnum | NewsNotificationScalarFieldEnum[]
  }

  /**
   * Student.ownedNotifications
   */
  export type Student$ownedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    where?: NewsNotificationWhereInput
    orderBy?: NewsNotificationOrderByWithRelationInput | NewsNotificationOrderByWithRelationInput[]
    cursor?: NewsNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsNotificationScalarFieldEnum | NewsNotificationScalarFieldEnum[]
  }

  /**
   * Student.follows
   */
  export type Student$followsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    where?: StudentFollowWhereInput
    orderBy?: StudentFollowOrderByWithRelationInput | StudentFollowOrderByWithRelationInput[]
    cursor?: StudentFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentFollowScalarFieldEnum | StudentFollowScalarFieldEnum[]
  }

  /**
   * Student.followers
   */
  export type Student$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    where?: StudentFollowWhereInput
    orderBy?: StudentFollowOrderByWithRelationInput | StudentFollowOrderByWithRelationInput[]
    cursor?: StudentFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentFollowScalarFieldEnum | StudentFollowScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    name: string | null
    creatAt: Date | null
    updateAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    name: string | null
    creatAt: Date | null
    updateAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    name: number
    creatAt: number
    updateAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    name?: true
    creatAt?: true
    updateAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    name?: true
    creatAt?: true
    updateAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    name?: true
    creatAt?: true
    updateAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    name: string | null
    creatAt: Date
    updateAt: Date
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creatAt?: boolean
    updateAt?: boolean
    messeges?: boolean | Chat$messegesArgs<ExtArgs>
    students?: boolean | Chat$studentsArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creatAt?: boolean
    updateAt?: boolean
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    name?: boolean
    creatAt?: boolean
    updateAt?: boolean
  }

  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messeges?: boolean | Chat$messegesArgs<ExtArgs>
    students?: boolean | Chat$studentsArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      messeges: Prisma.$MessagePayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      creatAt: Date
      updateAt: Date
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messeges<T extends Chat$messegesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messegesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends Chat$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Chat$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly name: FieldRef<"Chat", 'String'>
    readonly creatAt: FieldRef<"Chat", 'DateTime'>
    readonly updateAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
  }

  /**
   * Chat.messeges
   */
  export type Chat$messegesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat.students
   */
  export type Chat$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    createAt: Date | null
    updateAt: Date | null
    studentCode: string | null
    chatId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createAt: Date | null
    updateAt: Date | null
    studentCode: string | null
    chatId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    createAt: number
    updateAt: number
    studentCode: number
    chatId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    createAt?: true
    updateAt?: true
    studentCode?: true
    chatId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    createAt?: true
    updateAt?: true
    studentCode?: true
    chatId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    createAt?: true
    updateAt?: true
    studentCode?: true
    chatId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    createAt: Date
    updateAt: Date
    studentCode: string
    chatId: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createAt?: boolean
    updateAt?: boolean
    studentCode?: boolean
    chatId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createAt?: boolean
    updateAt?: boolean
    studentCode?: boolean
    chatId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    createAt?: boolean
    updateAt?: boolean
    studentCode?: boolean
    chatId?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      chat: Prisma.$ChatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createAt: Date
      updateAt: Date
      studentCode: string
      chatId: string
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createAt: FieldRef<"Message", 'DateTime'>
    readonly updateAt: FieldRef<"Message", 'DateTime'>
    readonly studentCode: FieldRef<"Message", 'String'>
    readonly chatId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    hostId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    hostId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    hostId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    hostId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    hostId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    hostId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    hostId: string
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    hostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    host?: boolean | ProfileDefaultArgs<ExtArgs>
    participants?: boolean | Event$participantsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    hostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    host?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    hostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | ProfileDefaultArgs<ExtArgs>
    participants?: boolean | Event$participantsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      host: Prisma.$ProfilePayload<ExtArgs>
      participants: Prisma.$EventProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      hostId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    host<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participants<T extends Event$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Event$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly hostId: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.participants
   */
  export type Event$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    where?: EventProfileWhereInput
    orderBy?: EventProfileOrderByWithRelationInput | EventProfileOrderByWithRelationInput[]
    cursor?: EventProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventProfileScalarFieldEnum | EventProfileScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventProfile
   */

  export type AggregateEventProfile = {
    _count: EventProfileCountAggregateOutputType | null
    _min: EventProfileMinAggregateOutputType | null
    _max: EventProfileMaxAggregateOutputType | null
  }

  export type EventProfileMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventProfileMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventProfileCountAggregateOutputType = {
    id: number
    eventId: number
    profileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventProfileMinAggregateInputType = {
    id?: true
    eventId?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventProfileMaxAggregateInputType = {
    id?: true
    eventId?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventProfileCountAggregateInputType = {
    id?: true
    eventId?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventProfile to aggregate.
     */
    where?: EventProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventProfiles to fetch.
     */
    orderBy?: EventProfileOrderByWithRelationInput | EventProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventProfiles
    **/
    _count?: true | EventProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventProfileMaxAggregateInputType
  }

  export type GetEventProfileAggregateType<T extends EventProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateEventProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventProfile[P]>
      : GetScalarType<T[P], AggregateEventProfile[P]>
  }




  export type EventProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventProfileWhereInput
    orderBy?: EventProfileOrderByWithAggregationInput | EventProfileOrderByWithAggregationInput[]
    by: EventProfileScalarFieldEnum[] | EventProfileScalarFieldEnum
    having?: EventProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventProfileCountAggregateInputType | true
    _min?: EventProfileMinAggregateInputType
    _max?: EventProfileMaxAggregateInputType
  }

  export type EventProfileGroupByOutputType = {
    id: string
    eventId: string
    profileId: string
    createdAt: Date
    updatedAt: Date
    _count: EventProfileCountAggregateOutputType | null
    _min: EventProfileMinAggregateOutputType | null
    _max: EventProfileMaxAggregateOutputType | null
  }

  type GetEventProfileGroupByPayload<T extends EventProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventProfileGroupByOutputType[P]>
            : GetScalarType<T[P], EventProfileGroupByOutputType[P]>
        }
      >
    >


  export type EventProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventProfile"]>

  export type EventProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventProfile"]>

  export type EventProfileSelectScalar = {
    id?: boolean
    eventId?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type EventProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $EventProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventProfile"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      profileId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eventProfile"]>
    composites: {}
  }

  type EventProfileGetPayload<S extends boolean | null | undefined | EventProfileDefaultArgs> = $Result.GetResult<Prisma.$EventProfilePayload, S>

  type EventProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventProfileCountAggregateInputType | true
    }

  export interface EventProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventProfile'], meta: { name: 'EventProfile' } }
    /**
     * Find zero or one EventProfile that matches the filter.
     * @param {EventProfileFindUniqueArgs} args - Arguments to find a EventProfile
     * @example
     * // Get one EventProfile
     * const eventProfile = await prisma.eventProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventProfileFindUniqueArgs>(args: SelectSubset<T, EventProfileFindUniqueArgs<ExtArgs>>): Prisma__EventProfileClient<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventProfileFindUniqueOrThrowArgs} args - Arguments to find a EventProfile
     * @example
     * // Get one EventProfile
     * const eventProfile = await prisma.eventProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, EventProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventProfileClient<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventProfileFindFirstArgs} args - Arguments to find a EventProfile
     * @example
     * // Get one EventProfile
     * const eventProfile = await prisma.eventProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventProfileFindFirstArgs>(args?: SelectSubset<T, EventProfileFindFirstArgs<ExtArgs>>): Prisma__EventProfileClient<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventProfileFindFirstOrThrowArgs} args - Arguments to find a EventProfile
     * @example
     * // Get one EventProfile
     * const eventProfile = await prisma.eventProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, EventProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventProfileClient<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventProfiles
     * const eventProfiles = await prisma.eventProfile.findMany()
     * 
     * // Get first 10 EventProfiles
     * const eventProfiles = await prisma.eventProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventProfileWithIdOnly = await prisma.eventProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventProfileFindManyArgs>(args?: SelectSubset<T, EventProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventProfile.
     * @param {EventProfileCreateArgs} args - Arguments to create a EventProfile.
     * @example
     * // Create one EventProfile
     * const EventProfile = await prisma.eventProfile.create({
     *   data: {
     *     // ... data to create a EventProfile
     *   }
     * })
     * 
     */
    create<T extends EventProfileCreateArgs>(args: SelectSubset<T, EventProfileCreateArgs<ExtArgs>>): Prisma__EventProfileClient<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventProfiles.
     * @param {EventProfileCreateManyArgs} args - Arguments to create many EventProfiles.
     * @example
     * // Create many EventProfiles
     * const eventProfile = await prisma.eventProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventProfileCreateManyArgs>(args?: SelectSubset<T, EventProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventProfiles and returns the data saved in the database.
     * @param {EventProfileCreateManyAndReturnArgs} args - Arguments to create many EventProfiles.
     * @example
     * // Create many EventProfiles
     * const eventProfile = await prisma.eventProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventProfiles and only return the `id`
     * const eventProfileWithIdOnly = await prisma.eventProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, EventProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventProfile.
     * @param {EventProfileDeleteArgs} args - Arguments to delete one EventProfile.
     * @example
     * // Delete one EventProfile
     * const EventProfile = await prisma.eventProfile.delete({
     *   where: {
     *     // ... filter to delete one EventProfile
     *   }
     * })
     * 
     */
    delete<T extends EventProfileDeleteArgs>(args: SelectSubset<T, EventProfileDeleteArgs<ExtArgs>>): Prisma__EventProfileClient<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventProfile.
     * @param {EventProfileUpdateArgs} args - Arguments to update one EventProfile.
     * @example
     * // Update one EventProfile
     * const eventProfile = await prisma.eventProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventProfileUpdateArgs>(args: SelectSubset<T, EventProfileUpdateArgs<ExtArgs>>): Prisma__EventProfileClient<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventProfiles.
     * @param {EventProfileDeleteManyArgs} args - Arguments to filter EventProfiles to delete.
     * @example
     * // Delete a few EventProfiles
     * const { count } = await prisma.eventProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventProfileDeleteManyArgs>(args?: SelectSubset<T, EventProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventProfiles
     * const eventProfile = await prisma.eventProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventProfileUpdateManyArgs>(args: SelectSubset<T, EventProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventProfile.
     * @param {EventProfileUpsertArgs} args - Arguments to update or create a EventProfile.
     * @example
     * // Update or create a EventProfile
     * const eventProfile = await prisma.eventProfile.upsert({
     *   create: {
     *     // ... data to create a EventProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventProfile we want to update
     *   }
     * })
     */
    upsert<T extends EventProfileUpsertArgs>(args: SelectSubset<T, EventProfileUpsertArgs<ExtArgs>>): Prisma__EventProfileClient<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventProfileCountArgs} args - Arguments to filter EventProfiles to count.
     * @example
     * // Count the number of EventProfiles
     * const count = await prisma.eventProfile.count({
     *   where: {
     *     // ... the filter for the EventProfiles we want to count
     *   }
     * })
    **/
    count<T extends EventProfileCountArgs>(
      args?: Subset<T, EventProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventProfileAggregateArgs>(args: Subset<T, EventProfileAggregateArgs>): Prisma.PrismaPromise<GetEventProfileAggregateType<T>>

    /**
     * Group by EventProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventProfileGroupByArgs['orderBy'] }
        : { orderBy?: EventProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventProfile model
   */
  readonly fields: EventProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventProfile model
   */ 
  interface EventProfileFieldRefs {
    readonly id: FieldRef<"EventProfile", 'String'>
    readonly eventId: FieldRef<"EventProfile", 'String'>
    readonly profileId: FieldRef<"EventProfile", 'String'>
    readonly createdAt: FieldRef<"EventProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"EventProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventProfile findUnique
   */
  export type EventProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    /**
     * Filter, which EventProfile to fetch.
     */
    where: EventProfileWhereUniqueInput
  }

  /**
   * EventProfile findUniqueOrThrow
   */
  export type EventProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    /**
     * Filter, which EventProfile to fetch.
     */
    where: EventProfileWhereUniqueInput
  }

  /**
   * EventProfile findFirst
   */
  export type EventProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    /**
     * Filter, which EventProfile to fetch.
     */
    where?: EventProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventProfiles to fetch.
     */
    orderBy?: EventProfileOrderByWithRelationInput | EventProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventProfiles.
     */
    cursor?: EventProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventProfiles.
     */
    distinct?: EventProfileScalarFieldEnum | EventProfileScalarFieldEnum[]
  }

  /**
   * EventProfile findFirstOrThrow
   */
  export type EventProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    /**
     * Filter, which EventProfile to fetch.
     */
    where?: EventProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventProfiles to fetch.
     */
    orderBy?: EventProfileOrderByWithRelationInput | EventProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventProfiles.
     */
    cursor?: EventProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventProfiles.
     */
    distinct?: EventProfileScalarFieldEnum | EventProfileScalarFieldEnum[]
  }

  /**
   * EventProfile findMany
   */
  export type EventProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    /**
     * Filter, which EventProfiles to fetch.
     */
    where?: EventProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventProfiles to fetch.
     */
    orderBy?: EventProfileOrderByWithRelationInput | EventProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventProfiles.
     */
    cursor?: EventProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventProfiles.
     */
    skip?: number
    distinct?: EventProfileScalarFieldEnum | EventProfileScalarFieldEnum[]
  }

  /**
   * EventProfile create
   */
  export type EventProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a EventProfile.
     */
    data: XOR<EventProfileCreateInput, EventProfileUncheckedCreateInput>
  }

  /**
   * EventProfile createMany
   */
  export type EventProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventProfiles.
     */
    data: EventProfileCreateManyInput | EventProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventProfile createManyAndReturn
   */
  export type EventProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventProfiles.
     */
    data: EventProfileCreateManyInput | EventProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventProfile update
   */
  export type EventProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a EventProfile.
     */
    data: XOR<EventProfileUpdateInput, EventProfileUncheckedUpdateInput>
    /**
     * Choose, which EventProfile to update.
     */
    where: EventProfileWhereUniqueInput
  }

  /**
   * EventProfile updateMany
   */
  export type EventProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventProfiles.
     */
    data: XOR<EventProfileUpdateManyMutationInput, EventProfileUncheckedUpdateManyInput>
    /**
     * Filter which EventProfiles to update
     */
    where?: EventProfileWhereInput
  }

  /**
   * EventProfile upsert
   */
  export type EventProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the EventProfile to update in case it exists.
     */
    where: EventProfileWhereUniqueInput
    /**
     * In case the EventProfile found by the `where` argument doesn't exist, create a new EventProfile with this data.
     */
    create: XOR<EventProfileCreateInput, EventProfileUncheckedCreateInput>
    /**
     * In case the EventProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventProfileUpdateInput, EventProfileUncheckedUpdateInput>
  }

  /**
   * EventProfile delete
   */
  export type EventProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    /**
     * Filter which EventProfile to delete.
     */
    where: EventProfileWhereUniqueInput
  }

  /**
   * EventProfile deleteMany
   */
  export type EventProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventProfiles to delete
     */
    where?: EventProfileWhereInput
  }

  /**
   * EventProfile without action
   */
  export type EventProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    status: $Enums.ProfileStatus | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    status: $Enums.ProfileStatus | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    status: number
    studentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    status?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    status?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    status?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    status: $Enums.ProfileStatus
    studentId: string
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    hostedEvents?: boolean | Profile$hostedEventsArgs<ExtArgs>
    participatedEvents?: boolean | Profile$participatedEventsArgs<ExtArgs>
    posts?: boolean | Profile$postsArgs<ExtArgs>
    biography?: boolean | Profile$biographyArgs<ExtArgs>
    friendRequests?: boolean | Profile$friendRequestsArgs<ExtArgs>
    friendReceived?: boolean | Profile$friendReceivedArgs<ExtArgs>
    ownedGroups?: boolean | Profile$ownedGroupsArgs<ExtArgs>
    groups?: boolean | Profile$groupsArgs<ExtArgs>
    blogs?: boolean | Profile$blogsArgs<ExtArgs>
    postComments?: boolean | Profile$postCommentsArgs<ExtArgs>
    postCommentLikes?: boolean | Profile$postCommentLikesArgs<ExtArgs>
    postLikes?: boolean | Profile$postLikesArgs<ExtArgs>
    postShares?: boolean | Profile$postSharesArgs<ExtArgs>
    postSaved?: boolean | Profile$postSavedArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    status?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    hostedEvents?: boolean | Profile$hostedEventsArgs<ExtArgs>
    participatedEvents?: boolean | Profile$participatedEventsArgs<ExtArgs>
    posts?: boolean | Profile$postsArgs<ExtArgs>
    biography?: boolean | Profile$biographyArgs<ExtArgs>
    friendRequests?: boolean | Profile$friendRequestsArgs<ExtArgs>
    friendReceived?: boolean | Profile$friendReceivedArgs<ExtArgs>
    ownedGroups?: boolean | Profile$ownedGroupsArgs<ExtArgs>
    groups?: boolean | Profile$groupsArgs<ExtArgs>
    blogs?: boolean | Profile$blogsArgs<ExtArgs>
    postComments?: boolean | Profile$postCommentsArgs<ExtArgs>
    postCommentLikes?: boolean | Profile$postCommentLikesArgs<ExtArgs>
    postLikes?: boolean | Profile$postLikesArgs<ExtArgs>
    postShares?: boolean | Profile$postSharesArgs<ExtArgs>
    postSaved?: boolean | Profile$postSavedArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      hostedEvents: Prisma.$EventPayload<ExtArgs>[]
      participatedEvents: Prisma.$EventProfilePayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      biography: Prisma.$ProfileBiographyPayload<ExtArgs> | null
      friendRequests: Prisma.$ProfileFriendPayload<ExtArgs>[]
      friendReceived: Prisma.$ProfileFriendPayload<ExtArgs>[]
      ownedGroups: Prisma.$GroupPayload<ExtArgs>[]
      groups: Prisma.$ProfileGroupPayload<ExtArgs>[]
      blogs: Prisma.$ProfileBlogPayload<ExtArgs>[]
      postComments: Prisma.$PostCommentPayload<ExtArgs>[]
      postCommentLikes: Prisma.$PostCommentLikePayload<ExtArgs>[]
      postLikes: Prisma.$PostLikePayload<ExtArgs>[]
      postShares: Prisma.$PostSharePayload<ExtArgs>[]
      postSaved: Prisma.$PostSavePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.ProfileStatus
      studentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hostedEvents<T extends Profile$hostedEventsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$hostedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    participatedEvents<T extends Profile$participatedEventsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$participatedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventProfilePayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Profile$postsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    biography<T extends Profile$biographyArgs<ExtArgs> = {}>(args?: Subset<T, Profile$biographyArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    friendRequests<T extends Profile$friendRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$friendRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "findMany"> | Null>
    friendReceived<T extends Profile$friendReceivedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$friendReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "findMany"> | Null>
    ownedGroups<T extends Profile$ownedGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$ownedGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany"> | Null>
    groups<T extends Profile$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "findMany"> | Null>
    blogs<T extends Profile$blogsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$blogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "findMany"> | Null>
    postComments<T extends Profile$postCommentsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findMany"> | Null>
    postCommentLikes<T extends Profile$postCommentLikesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postCommentLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "findMany"> | Null>
    postLikes<T extends Profile$postLikesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany"> | Null>
    postShares<T extends Profile$postSharesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "findMany"> | Null>
    postSaved<T extends Profile$postSavedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postSavedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly status: FieldRef<"Profile", 'ProfileStatus'>
    readonly studentId: FieldRef<"Profile", 'String'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile.hostedEvents
   */
  export type Profile$hostedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Profile.participatedEvents
   */
  export type Profile$participatedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventProfile
     */
    select?: EventProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventProfileInclude<ExtArgs> | null
    where?: EventProfileWhereInput
    orderBy?: EventProfileOrderByWithRelationInput | EventProfileOrderByWithRelationInput[]
    cursor?: EventProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventProfileScalarFieldEnum | EventProfileScalarFieldEnum[]
  }

  /**
   * Profile.posts
   */
  export type Profile$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Profile.biography
   */
  export type Profile$biographyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    where?: ProfileBiographyWhereInput
  }

  /**
   * Profile.friendRequests
   */
  export type Profile$friendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    where?: ProfileFriendWhereInput
    orderBy?: ProfileFriendOrderByWithRelationInput | ProfileFriendOrderByWithRelationInput[]
    cursor?: ProfileFriendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileFriendScalarFieldEnum | ProfileFriendScalarFieldEnum[]
  }

  /**
   * Profile.friendReceived
   */
  export type Profile$friendReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    where?: ProfileFriendWhereInput
    orderBy?: ProfileFriendOrderByWithRelationInput | ProfileFriendOrderByWithRelationInput[]
    cursor?: ProfileFriendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileFriendScalarFieldEnum | ProfileFriendScalarFieldEnum[]
  }

  /**
   * Profile.ownedGroups
   */
  export type Profile$ownedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Profile.groups
   */
  export type Profile$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    where?: ProfileGroupWhereInput
    orderBy?: ProfileGroupOrderByWithRelationInput | ProfileGroupOrderByWithRelationInput[]
    cursor?: ProfileGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileGroupScalarFieldEnum | ProfileGroupScalarFieldEnum[]
  }

  /**
   * Profile.blogs
   */
  export type Profile$blogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    where?: ProfileBlogWhereInput
    orderBy?: ProfileBlogOrderByWithRelationInput | ProfileBlogOrderByWithRelationInput[]
    cursor?: ProfileBlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileBlogScalarFieldEnum | ProfileBlogScalarFieldEnum[]
  }

  /**
   * Profile.postComments
   */
  export type Profile$postCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    where?: PostCommentWhereInput
    orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
    cursor?: PostCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
  }

  /**
   * Profile.postCommentLikes
   */
  export type Profile$postCommentLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    where?: PostCommentLikeWhereInput
    orderBy?: PostCommentLikeOrderByWithRelationInput | PostCommentLikeOrderByWithRelationInput[]
    cursor?: PostCommentLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostCommentLikeScalarFieldEnum | PostCommentLikeScalarFieldEnum[]
  }

  /**
   * Profile.postLikes
   */
  export type Profile$postLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    cursor?: PostLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * Profile.postShares
   */
  export type Profile$postSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    where?: PostShareWhereInput
    orderBy?: PostShareOrderByWithRelationInput | PostShareOrderByWithRelationInput[]
    cursor?: PostShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostShareScalarFieldEnum | PostShareScalarFieldEnum[]
  }

  /**
   * Profile.postSaved
   */
  export type Profile$postSavedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    where?: PostSaveWhereInput
    orderBy?: PostSaveOrderByWithRelationInput | PostSaveOrderByWithRelationInput[]
    cursor?: PostSaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostSaveScalarFieldEnum | PostSaveScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model ProfileFriend
   */

  export type AggregateProfileFriend = {
    _count: ProfileFriendCountAggregateOutputType | null
    _min: ProfileFriendMinAggregateOutputType | null
    _max: ProfileFriendMaxAggregateOutputType | null
  }

  export type ProfileFriendMinAggregateOutputType = {
    id: string | null
    isActive: boolean | null
    profileIdOne: string | null
    profileIdTwo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileFriendMaxAggregateOutputType = {
    id: string | null
    isActive: boolean | null
    profileIdOne: string | null
    profileIdTwo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileFriendCountAggregateOutputType = {
    id: number
    isActive: number
    profileIdOne: number
    profileIdTwo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileFriendMinAggregateInputType = {
    id?: true
    isActive?: true
    profileIdOne?: true
    profileIdTwo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileFriendMaxAggregateInputType = {
    id?: true
    isActive?: true
    profileIdOne?: true
    profileIdTwo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileFriendCountAggregateInputType = {
    id?: true
    isActive?: true
    profileIdOne?: true
    profileIdTwo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileFriendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileFriend to aggregate.
     */
    where?: ProfileFriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileFriends to fetch.
     */
    orderBy?: ProfileFriendOrderByWithRelationInput | ProfileFriendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileFriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileFriends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileFriends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileFriends
    **/
    _count?: true | ProfileFriendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileFriendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileFriendMaxAggregateInputType
  }

  export type GetProfileFriendAggregateType<T extends ProfileFriendAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileFriend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileFriend[P]>
      : GetScalarType<T[P], AggregateProfileFriend[P]>
  }




  export type ProfileFriendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileFriendWhereInput
    orderBy?: ProfileFriendOrderByWithAggregationInput | ProfileFriendOrderByWithAggregationInput[]
    by: ProfileFriendScalarFieldEnum[] | ProfileFriendScalarFieldEnum
    having?: ProfileFriendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileFriendCountAggregateInputType | true
    _min?: ProfileFriendMinAggregateInputType
    _max?: ProfileFriendMaxAggregateInputType
  }

  export type ProfileFriendGroupByOutputType = {
    id: string
    isActive: boolean
    profileIdOne: string
    profileIdTwo: string
    createdAt: Date
    updatedAt: Date
    _count: ProfileFriendCountAggregateOutputType | null
    _min: ProfileFriendMinAggregateOutputType | null
    _max: ProfileFriendMaxAggregateOutputType | null
  }

  type GetProfileFriendGroupByPayload<T extends ProfileFriendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileFriendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileFriendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileFriendGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileFriendGroupByOutputType[P]>
        }
      >
    >


  export type ProfileFriendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isActive?: boolean
    profileIdOne?: boolean
    profileIdTwo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileOne?: boolean | ProfileDefaultArgs<ExtArgs>
    profileTwo?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileFriend"]>

  export type ProfileFriendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isActive?: boolean
    profileIdOne?: boolean
    profileIdTwo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileOne?: boolean | ProfileDefaultArgs<ExtArgs>
    profileTwo?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileFriend"]>

  export type ProfileFriendSelectScalar = {
    id?: boolean
    isActive?: boolean
    profileIdOne?: boolean
    profileIdTwo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileFriendInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileOne?: boolean | ProfileDefaultArgs<ExtArgs>
    profileTwo?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileFriendIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileOne?: boolean | ProfileDefaultArgs<ExtArgs>
    profileTwo?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfileFriendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileFriend"
    objects: {
      profileOne: Prisma.$ProfilePayload<ExtArgs>
      profileTwo: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isActive: boolean
      profileIdOne: string
      profileIdTwo: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profileFriend"]>
    composites: {}
  }

  type ProfileFriendGetPayload<S extends boolean | null | undefined | ProfileFriendDefaultArgs> = $Result.GetResult<Prisma.$ProfileFriendPayload, S>

  type ProfileFriendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFriendFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileFriendCountAggregateInputType | true
    }

  export interface ProfileFriendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileFriend'], meta: { name: 'ProfileFriend' } }
    /**
     * Find zero or one ProfileFriend that matches the filter.
     * @param {ProfileFriendFindUniqueArgs} args - Arguments to find a ProfileFriend
     * @example
     * // Get one ProfileFriend
     * const profileFriend = await prisma.profileFriend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFriendFindUniqueArgs>(args: SelectSubset<T, ProfileFriendFindUniqueArgs<ExtArgs>>): Prisma__ProfileFriendClient<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileFriend that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFriendFindUniqueOrThrowArgs} args - Arguments to find a ProfileFriend
     * @example
     * // Get one ProfileFriend
     * const profileFriend = await prisma.profileFriend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFriendFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFriendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileFriendClient<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileFriend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFriendFindFirstArgs} args - Arguments to find a ProfileFriend
     * @example
     * // Get one ProfileFriend
     * const profileFriend = await prisma.profileFriend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFriendFindFirstArgs>(args?: SelectSubset<T, ProfileFriendFindFirstArgs<ExtArgs>>): Prisma__ProfileFriendClient<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileFriend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFriendFindFirstOrThrowArgs} args - Arguments to find a ProfileFriend
     * @example
     * // Get one ProfileFriend
     * const profileFriend = await prisma.profileFriend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFriendFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFriendFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileFriendClient<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileFriends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFriendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileFriends
     * const profileFriends = await prisma.profileFriend.findMany()
     * 
     * // Get first 10 ProfileFriends
     * const profileFriends = await prisma.profileFriend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileFriendWithIdOnly = await prisma.profileFriend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFriendFindManyArgs>(args?: SelectSubset<T, ProfileFriendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileFriend.
     * @param {ProfileFriendCreateArgs} args - Arguments to create a ProfileFriend.
     * @example
     * // Create one ProfileFriend
     * const ProfileFriend = await prisma.profileFriend.create({
     *   data: {
     *     // ... data to create a ProfileFriend
     *   }
     * })
     * 
     */
    create<T extends ProfileFriendCreateArgs>(args: SelectSubset<T, ProfileFriendCreateArgs<ExtArgs>>): Prisma__ProfileFriendClient<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileFriends.
     * @param {ProfileFriendCreateManyArgs} args - Arguments to create many ProfileFriends.
     * @example
     * // Create many ProfileFriends
     * const profileFriend = await prisma.profileFriend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileFriendCreateManyArgs>(args?: SelectSubset<T, ProfileFriendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileFriends and returns the data saved in the database.
     * @param {ProfileFriendCreateManyAndReturnArgs} args - Arguments to create many ProfileFriends.
     * @example
     * // Create many ProfileFriends
     * const profileFriend = await prisma.profileFriend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileFriends and only return the `id`
     * const profileFriendWithIdOnly = await prisma.profileFriend.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileFriendCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileFriendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileFriend.
     * @param {ProfileFriendDeleteArgs} args - Arguments to delete one ProfileFriend.
     * @example
     * // Delete one ProfileFriend
     * const ProfileFriend = await prisma.profileFriend.delete({
     *   where: {
     *     // ... filter to delete one ProfileFriend
     *   }
     * })
     * 
     */
    delete<T extends ProfileFriendDeleteArgs>(args: SelectSubset<T, ProfileFriendDeleteArgs<ExtArgs>>): Prisma__ProfileFriendClient<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileFriend.
     * @param {ProfileFriendUpdateArgs} args - Arguments to update one ProfileFriend.
     * @example
     * // Update one ProfileFriend
     * const profileFriend = await prisma.profileFriend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileFriendUpdateArgs>(args: SelectSubset<T, ProfileFriendUpdateArgs<ExtArgs>>): Prisma__ProfileFriendClient<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileFriends.
     * @param {ProfileFriendDeleteManyArgs} args - Arguments to filter ProfileFriends to delete.
     * @example
     * // Delete a few ProfileFriends
     * const { count } = await prisma.profileFriend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileFriendDeleteManyArgs>(args?: SelectSubset<T, ProfileFriendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileFriends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFriendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileFriends
     * const profileFriend = await prisma.profileFriend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileFriendUpdateManyArgs>(args: SelectSubset<T, ProfileFriendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileFriend.
     * @param {ProfileFriendUpsertArgs} args - Arguments to update or create a ProfileFriend.
     * @example
     * // Update or create a ProfileFriend
     * const profileFriend = await prisma.profileFriend.upsert({
     *   create: {
     *     // ... data to create a ProfileFriend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileFriend we want to update
     *   }
     * })
     */
    upsert<T extends ProfileFriendUpsertArgs>(args: SelectSubset<T, ProfileFriendUpsertArgs<ExtArgs>>): Prisma__ProfileFriendClient<$Result.GetResult<Prisma.$ProfileFriendPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileFriends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFriendCountArgs} args - Arguments to filter ProfileFriends to count.
     * @example
     * // Count the number of ProfileFriends
     * const count = await prisma.profileFriend.count({
     *   where: {
     *     // ... the filter for the ProfileFriends we want to count
     *   }
     * })
    **/
    count<T extends ProfileFriendCountArgs>(
      args?: Subset<T, ProfileFriendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileFriendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileFriend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFriendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileFriendAggregateArgs>(args: Subset<T, ProfileFriendAggregateArgs>): Prisma.PrismaPromise<GetProfileFriendAggregateType<T>>

    /**
     * Group by ProfileFriend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFriendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileFriendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileFriendGroupByArgs['orderBy'] }
        : { orderBy?: ProfileFriendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileFriendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileFriendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileFriend model
   */
  readonly fields: ProfileFriendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileFriend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileFriendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profileOne<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profileTwo<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileFriend model
   */ 
  interface ProfileFriendFieldRefs {
    readonly id: FieldRef<"ProfileFriend", 'String'>
    readonly isActive: FieldRef<"ProfileFriend", 'Boolean'>
    readonly profileIdOne: FieldRef<"ProfileFriend", 'String'>
    readonly profileIdTwo: FieldRef<"ProfileFriend", 'String'>
    readonly createdAt: FieldRef<"ProfileFriend", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfileFriend", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileFriend findUnique
   */
  export type ProfileFriendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    /**
     * Filter, which ProfileFriend to fetch.
     */
    where: ProfileFriendWhereUniqueInput
  }

  /**
   * ProfileFriend findUniqueOrThrow
   */
  export type ProfileFriendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    /**
     * Filter, which ProfileFriend to fetch.
     */
    where: ProfileFriendWhereUniqueInput
  }

  /**
   * ProfileFriend findFirst
   */
  export type ProfileFriendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    /**
     * Filter, which ProfileFriend to fetch.
     */
    where?: ProfileFriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileFriends to fetch.
     */
    orderBy?: ProfileFriendOrderByWithRelationInput | ProfileFriendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileFriends.
     */
    cursor?: ProfileFriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileFriends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileFriends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileFriends.
     */
    distinct?: ProfileFriendScalarFieldEnum | ProfileFriendScalarFieldEnum[]
  }

  /**
   * ProfileFriend findFirstOrThrow
   */
  export type ProfileFriendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    /**
     * Filter, which ProfileFriend to fetch.
     */
    where?: ProfileFriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileFriends to fetch.
     */
    orderBy?: ProfileFriendOrderByWithRelationInput | ProfileFriendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileFriends.
     */
    cursor?: ProfileFriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileFriends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileFriends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileFriends.
     */
    distinct?: ProfileFriendScalarFieldEnum | ProfileFriendScalarFieldEnum[]
  }

  /**
   * ProfileFriend findMany
   */
  export type ProfileFriendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    /**
     * Filter, which ProfileFriends to fetch.
     */
    where?: ProfileFriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileFriends to fetch.
     */
    orderBy?: ProfileFriendOrderByWithRelationInput | ProfileFriendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileFriends.
     */
    cursor?: ProfileFriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileFriends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileFriends.
     */
    skip?: number
    distinct?: ProfileFriendScalarFieldEnum | ProfileFriendScalarFieldEnum[]
  }

  /**
   * ProfileFriend create
   */
  export type ProfileFriendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileFriend.
     */
    data: XOR<ProfileFriendCreateInput, ProfileFriendUncheckedCreateInput>
  }

  /**
   * ProfileFriend createMany
   */
  export type ProfileFriendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileFriends.
     */
    data: ProfileFriendCreateManyInput | ProfileFriendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileFriend createManyAndReturn
   */
  export type ProfileFriendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileFriends.
     */
    data: ProfileFriendCreateManyInput | ProfileFriendCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileFriend update
   */
  export type ProfileFriendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileFriend.
     */
    data: XOR<ProfileFriendUpdateInput, ProfileFriendUncheckedUpdateInput>
    /**
     * Choose, which ProfileFriend to update.
     */
    where: ProfileFriendWhereUniqueInput
  }

  /**
   * ProfileFriend updateMany
   */
  export type ProfileFriendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileFriends.
     */
    data: XOR<ProfileFriendUpdateManyMutationInput, ProfileFriendUncheckedUpdateManyInput>
    /**
     * Filter which ProfileFriends to update
     */
    where?: ProfileFriendWhereInput
  }

  /**
   * ProfileFriend upsert
   */
  export type ProfileFriendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileFriend to update in case it exists.
     */
    where: ProfileFriendWhereUniqueInput
    /**
     * In case the ProfileFriend found by the `where` argument doesn't exist, create a new ProfileFriend with this data.
     */
    create: XOR<ProfileFriendCreateInput, ProfileFriendUncheckedCreateInput>
    /**
     * In case the ProfileFriend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileFriendUpdateInput, ProfileFriendUncheckedUpdateInput>
  }

  /**
   * ProfileFriend delete
   */
  export type ProfileFriendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
    /**
     * Filter which ProfileFriend to delete.
     */
    where: ProfileFriendWhereUniqueInput
  }

  /**
   * ProfileFriend deleteMany
   */
  export type ProfileFriendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileFriends to delete
     */
    where?: ProfileFriendWhereInput
  }

  /**
   * ProfileFriend without action
   */
  export type ProfileFriendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileFriend
     */
    select?: ProfileFriendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileFriendInclude<ExtArgs> | null
  }


  /**
   * Model Area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  export type AreaMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AreaMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AreaMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area to aggregate.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }




  export type AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithAggregationInput | AreaOrderByWithAggregationInput[]
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum
    having?: AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaCountAggregateInputType | true
    _min?: AreaMinAggregateInputType
    _max?: AreaMaxAggregateInputType
  }

  export type AreaGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: AreaCountAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  type GetAreaGroupByPayload<T extends AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaGroupByOutputType[P]>
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
        }
      >
    >


  export type AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    biographies?: boolean | Area$biographiesArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["area"]>

  export type AreaSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    biographies?: boolean | Area$biographiesArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area"
    objects: {
      biographies: Prisma.$ProfileBiographyAreaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["area"]>
    composites: {}
  }

  type AreaGetPayload<S extends boolean | null | undefined | AreaDefaultArgs> = $Result.GetResult<Prisma.$AreaPayload, S>

  type AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AreaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AreaCountAggregateInputType | true
    }

  export interface AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area'], meta: { name: 'Area' } }
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaFindUniqueArgs>(args: SelectSubset<T, AreaFindUniqueArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Area that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AreaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaFindFirstArgs>(args?: SelectSubset<T, AreaFindFirstArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaFindManyArgs>(args?: SelectSubset<T, AreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
     */
    create<T extends AreaCreateArgs>(args: SelectSubset<T, AreaCreateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Areas.
     * @param {AreaCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaCreateManyArgs>(args?: SelectSubset<T, AreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Areas and returns the data saved in the database.
     * @param {AreaCreateManyAndReturnArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreaCreateManyAndReturnArgs>(args?: SelectSubset<T, AreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
     */
    delete<T extends AreaDeleteArgs>(args: SelectSubset<T, AreaDeleteArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaUpdateArgs>(args: SelectSubset<T, AreaUpdateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaDeleteManyArgs>(args?: SelectSubset<T, AreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaUpdateManyArgs>(args: SelectSubset<T, AreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
     */
    upsert<T extends AreaUpsertArgs>(args: SelectSubset<T, AreaUpsertArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): Prisma.PrismaPromise<GetAreaAggregateType<T>>

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaGroupByArgs['orderBy'] }
        : { orderBy?: AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area model
   */
  readonly fields: AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    biographies<T extends Area$biographiesArgs<ExtArgs> = {}>(args?: Subset<T, Area$biographiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Area model
   */ 
  interface AreaFieldRefs {
    readonly id: FieldRef<"Area", 'String'>
    readonly title: FieldRef<"Area", 'String'>
    readonly createdAt: FieldRef<"Area", 'DateTime'>
    readonly updatedAt: FieldRef<"Area", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findUniqueOrThrow
   */
  export type AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findFirstOrThrow
   */
  export type AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findMany
   */
  export type AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area create
   */
  export type AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area.
     */
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }

  /**
   * Area createMany
   */
  export type AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area createManyAndReturn
   */
  export type AreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area update
   */
  export type AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area.
     */
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
  }

  /**
   * Area upsert
   */
  export type AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area to update in case it exists.
     */
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
     */
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }

  /**
   * Area delete
   */
  export type AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter which Area to delete.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreaWhereInput
  }

  /**
   * Area.biographies
   */
  export type Area$biographiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    where?: ProfileBiographyAreaWhereInput
    orderBy?: ProfileBiographyAreaOrderByWithRelationInput | ProfileBiographyAreaOrderByWithRelationInput[]
    cursor?: ProfileBiographyAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileBiographyAreaScalarFieldEnum | ProfileBiographyAreaScalarFieldEnum[]
  }

  /**
   * Area without action
   */
  export type AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
  }


  /**
   * Model ProfileBiography
   */

  export type AggregateProfileBiography = {
    _count: ProfileBiographyCountAggregateOutputType | null
    _min: ProfileBiographyMinAggregateOutputType | null
    _max: ProfileBiographyMaxAggregateOutputType | null
  }

  export type ProfileBiographyMinAggregateOutputType = {
    id: string | null
    content: string | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileBiographyMaxAggregateOutputType = {
    id: string | null
    content: string | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileBiographyCountAggregateOutputType = {
    id: number
    content: number
    profileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileBiographyMinAggregateInputType = {
    id?: true
    content?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileBiographyMaxAggregateInputType = {
    id?: true
    content?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileBiographyCountAggregateInputType = {
    id?: true
    content?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileBiographyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBiography to aggregate.
     */
    where?: ProfileBiographyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographies to fetch.
     */
    orderBy?: ProfileBiographyOrderByWithRelationInput | ProfileBiographyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileBiographyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileBiographies
    **/
    _count?: true | ProfileBiographyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileBiographyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileBiographyMaxAggregateInputType
  }

  export type GetProfileBiographyAggregateType<T extends ProfileBiographyAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileBiography]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileBiography[P]>
      : GetScalarType<T[P], AggregateProfileBiography[P]>
  }




  export type ProfileBiographyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBiographyWhereInput
    orderBy?: ProfileBiographyOrderByWithAggregationInput | ProfileBiographyOrderByWithAggregationInput[]
    by: ProfileBiographyScalarFieldEnum[] | ProfileBiographyScalarFieldEnum
    having?: ProfileBiographyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileBiographyCountAggregateInputType | true
    _min?: ProfileBiographyMinAggregateInputType
    _max?: ProfileBiographyMaxAggregateInputType
  }

  export type ProfileBiographyGroupByOutputType = {
    id: string
    content: string
    profileId: string
    createdAt: Date
    updatedAt: Date
    _count: ProfileBiographyCountAggregateOutputType | null
    _min: ProfileBiographyMinAggregateOutputType | null
    _max: ProfileBiographyMaxAggregateOutputType | null
  }

  type GetProfileBiographyGroupByPayload<T extends ProfileBiographyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileBiographyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileBiographyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileBiographyGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileBiographyGroupByOutputType[P]>
        }
      >
    >


  export type ProfileBiographySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    areas?: boolean | ProfileBiography$areasArgs<ExtArgs>
    socials?: boolean | ProfileBiography$socialsArgs<ExtArgs>
    _count?: boolean | ProfileBiographyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBiography"]>

  export type ProfileBiographySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBiography"]>

  export type ProfileBiographySelectScalar = {
    id?: boolean
    content?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileBiographyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    areas?: boolean | ProfileBiography$areasArgs<ExtArgs>
    socials?: boolean | ProfileBiography$socialsArgs<ExtArgs>
    _count?: boolean | ProfileBiographyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileBiographyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfileBiographyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileBiography"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      areas: Prisma.$ProfileBiographyAreaPayload<ExtArgs>[]
      socials: Prisma.$ProfileBiographySocialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      profileId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profileBiography"]>
    composites: {}
  }

  type ProfileBiographyGetPayload<S extends boolean | null | undefined | ProfileBiographyDefaultArgs> = $Result.GetResult<Prisma.$ProfileBiographyPayload, S>

  type ProfileBiographyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileBiographyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileBiographyCountAggregateInputType | true
    }

  export interface ProfileBiographyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileBiography'], meta: { name: 'ProfileBiography' } }
    /**
     * Find zero or one ProfileBiography that matches the filter.
     * @param {ProfileBiographyFindUniqueArgs} args - Arguments to find a ProfileBiography
     * @example
     * // Get one ProfileBiography
     * const profileBiography = await prisma.profileBiography.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileBiographyFindUniqueArgs>(args: SelectSubset<T, ProfileBiographyFindUniqueArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileBiography that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileBiographyFindUniqueOrThrowArgs} args - Arguments to find a ProfileBiography
     * @example
     * // Get one ProfileBiography
     * const profileBiography = await prisma.profileBiography.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileBiographyFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileBiographyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileBiography that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyFindFirstArgs} args - Arguments to find a ProfileBiography
     * @example
     * // Get one ProfileBiography
     * const profileBiography = await prisma.profileBiography.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileBiographyFindFirstArgs>(args?: SelectSubset<T, ProfileBiographyFindFirstArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileBiography that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyFindFirstOrThrowArgs} args - Arguments to find a ProfileBiography
     * @example
     * // Get one ProfileBiography
     * const profileBiography = await prisma.profileBiography.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileBiographyFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileBiographyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileBiographies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileBiographies
     * const profileBiographies = await prisma.profileBiography.findMany()
     * 
     * // Get first 10 ProfileBiographies
     * const profileBiographies = await prisma.profileBiography.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileBiographyWithIdOnly = await prisma.profileBiography.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileBiographyFindManyArgs>(args?: SelectSubset<T, ProfileBiographyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileBiography.
     * @param {ProfileBiographyCreateArgs} args - Arguments to create a ProfileBiography.
     * @example
     * // Create one ProfileBiography
     * const ProfileBiography = await prisma.profileBiography.create({
     *   data: {
     *     // ... data to create a ProfileBiography
     *   }
     * })
     * 
     */
    create<T extends ProfileBiographyCreateArgs>(args: SelectSubset<T, ProfileBiographyCreateArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileBiographies.
     * @param {ProfileBiographyCreateManyArgs} args - Arguments to create many ProfileBiographies.
     * @example
     * // Create many ProfileBiographies
     * const profileBiography = await prisma.profileBiography.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileBiographyCreateManyArgs>(args?: SelectSubset<T, ProfileBiographyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileBiographies and returns the data saved in the database.
     * @param {ProfileBiographyCreateManyAndReturnArgs} args - Arguments to create many ProfileBiographies.
     * @example
     * // Create many ProfileBiographies
     * const profileBiography = await prisma.profileBiography.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileBiographies and only return the `id`
     * const profileBiographyWithIdOnly = await prisma.profileBiography.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileBiographyCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileBiographyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileBiography.
     * @param {ProfileBiographyDeleteArgs} args - Arguments to delete one ProfileBiography.
     * @example
     * // Delete one ProfileBiography
     * const ProfileBiography = await prisma.profileBiography.delete({
     *   where: {
     *     // ... filter to delete one ProfileBiography
     *   }
     * })
     * 
     */
    delete<T extends ProfileBiographyDeleteArgs>(args: SelectSubset<T, ProfileBiographyDeleteArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileBiography.
     * @param {ProfileBiographyUpdateArgs} args - Arguments to update one ProfileBiography.
     * @example
     * // Update one ProfileBiography
     * const profileBiography = await prisma.profileBiography.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileBiographyUpdateArgs>(args: SelectSubset<T, ProfileBiographyUpdateArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileBiographies.
     * @param {ProfileBiographyDeleteManyArgs} args - Arguments to filter ProfileBiographies to delete.
     * @example
     * // Delete a few ProfileBiographies
     * const { count } = await prisma.profileBiography.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileBiographyDeleteManyArgs>(args?: SelectSubset<T, ProfileBiographyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileBiographies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileBiographies
     * const profileBiography = await prisma.profileBiography.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileBiographyUpdateManyArgs>(args: SelectSubset<T, ProfileBiographyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileBiography.
     * @param {ProfileBiographyUpsertArgs} args - Arguments to update or create a ProfileBiography.
     * @example
     * // Update or create a ProfileBiography
     * const profileBiography = await prisma.profileBiography.upsert({
     *   create: {
     *     // ... data to create a ProfileBiography
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileBiography we want to update
     *   }
     * })
     */
    upsert<T extends ProfileBiographyUpsertArgs>(args: SelectSubset<T, ProfileBiographyUpsertArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileBiographies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyCountArgs} args - Arguments to filter ProfileBiographies to count.
     * @example
     * // Count the number of ProfileBiographies
     * const count = await prisma.profileBiography.count({
     *   where: {
     *     // ... the filter for the ProfileBiographies we want to count
     *   }
     * })
    **/
    count<T extends ProfileBiographyCountArgs>(
      args?: Subset<T, ProfileBiographyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileBiographyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileBiography.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileBiographyAggregateArgs>(args: Subset<T, ProfileBiographyAggregateArgs>): Prisma.PrismaPromise<GetProfileBiographyAggregateType<T>>

    /**
     * Group by ProfileBiography.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileBiographyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileBiographyGroupByArgs['orderBy'] }
        : { orderBy?: ProfileBiographyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileBiographyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileBiographyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileBiography model
   */
  readonly fields: ProfileBiographyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileBiography.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileBiographyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    areas<T extends ProfileBiography$areasArgs<ExtArgs> = {}>(args?: Subset<T, ProfileBiography$areasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "findMany"> | Null>
    socials<T extends ProfileBiography$socialsArgs<ExtArgs> = {}>(args?: Subset<T, ProfileBiography$socialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileBiography model
   */ 
  interface ProfileBiographyFieldRefs {
    readonly id: FieldRef<"ProfileBiography", 'String'>
    readonly content: FieldRef<"ProfileBiography", 'String'>
    readonly profileId: FieldRef<"ProfileBiography", 'String'>
    readonly createdAt: FieldRef<"ProfileBiography", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfileBiography", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileBiography findUnique
   */
  export type ProfileBiographyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiography to fetch.
     */
    where: ProfileBiographyWhereUniqueInput
  }

  /**
   * ProfileBiography findUniqueOrThrow
   */
  export type ProfileBiographyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiography to fetch.
     */
    where: ProfileBiographyWhereUniqueInput
  }

  /**
   * ProfileBiography findFirst
   */
  export type ProfileBiographyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiography to fetch.
     */
    where?: ProfileBiographyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographies to fetch.
     */
    orderBy?: ProfileBiographyOrderByWithRelationInput | ProfileBiographyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBiographies.
     */
    cursor?: ProfileBiographyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBiographies.
     */
    distinct?: ProfileBiographyScalarFieldEnum | ProfileBiographyScalarFieldEnum[]
  }

  /**
   * ProfileBiography findFirstOrThrow
   */
  export type ProfileBiographyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiography to fetch.
     */
    where?: ProfileBiographyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographies to fetch.
     */
    orderBy?: ProfileBiographyOrderByWithRelationInput | ProfileBiographyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBiographies.
     */
    cursor?: ProfileBiographyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBiographies.
     */
    distinct?: ProfileBiographyScalarFieldEnum | ProfileBiographyScalarFieldEnum[]
  }

  /**
   * ProfileBiography findMany
   */
  export type ProfileBiographyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographies to fetch.
     */
    where?: ProfileBiographyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographies to fetch.
     */
    orderBy?: ProfileBiographyOrderByWithRelationInput | ProfileBiographyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileBiographies.
     */
    cursor?: ProfileBiographyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographies.
     */
    skip?: number
    distinct?: ProfileBiographyScalarFieldEnum | ProfileBiographyScalarFieldEnum[]
  }

  /**
   * ProfileBiography create
   */
  export type ProfileBiographyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileBiography.
     */
    data: XOR<ProfileBiographyCreateInput, ProfileBiographyUncheckedCreateInput>
  }

  /**
   * ProfileBiography createMany
   */
  export type ProfileBiographyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileBiographies.
     */
    data: ProfileBiographyCreateManyInput | ProfileBiographyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileBiography createManyAndReturn
   */
  export type ProfileBiographyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileBiographies.
     */
    data: ProfileBiographyCreateManyInput | ProfileBiographyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileBiography update
   */
  export type ProfileBiographyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileBiography.
     */
    data: XOR<ProfileBiographyUpdateInput, ProfileBiographyUncheckedUpdateInput>
    /**
     * Choose, which ProfileBiography to update.
     */
    where: ProfileBiographyWhereUniqueInput
  }

  /**
   * ProfileBiography updateMany
   */
  export type ProfileBiographyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileBiographies.
     */
    data: XOR<ProfileBiographyUpdateManyMutationInput, ProfileBiographyUncheckedUpdateManyInput>
    /**
     * Filter which ProfileBiographies to update
     */
    where?: ProfileBiographyWhereInput
  }

  /**
   * ProfileBiography upsert
   */
  export type ProfileBiographyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileBiography to update in case it exists.
     */
    where: ProfileBiographyWhereUniqueInput
    /**
     * In case the ProfileBiography found by the `where` argument doesn't exist, create a new ProfileBiography with this data.
     */
    create: XOR<ProfileBiographyCreateInput, ProfileBiographyUncheckedCreateInput>
    /**
     * In case the ProfileBiography was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileBiographyUpdateInput, ProfileBiographyUncheckedUpdateInput>
  }

  /**
   * ProfileBiography delete
   */
  export type ProfileBiographyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
    /**
     * Filter which ProfileBiography to delete.
     */
    where: ProfileBiographyWhereUniqueInput
  }

  /**
   * ProfileBiography deleteMany
   */
  export type ProfileBiographyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBiographies to delete
     */
    where?: ProfileBiographyWhereInput
  }

  /**
   * ProfileBiography.areas
   */
  export type ProfileBiography$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    where?: ProfileBiographyAreaWhereInput
    orderBy?: ProfileBiographyAreaOrderByWithRelationInput | ProfileBiographyAreaOrderByWithRelationInput[]
    cursor?: ProfileBiographyAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileBiographyAreaScalarFieldEnum | ProfileBiographyAreaScalarFieldEnum[]
  }

  /**
   * ProfileBiography.socials
   */
  export type ProfileBiography$socialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    where?: ProfileBiographySocialWhereInput
    orderBy?: ProfileBiographySocialOrderByWithRelationInput | ProfileBiographySocialOrderByWithRelationInput[]
    cursor?: ProfileBiographySocialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileBiographySocialScalarFieldEnum | ProfileBiographySocialScalarFieldEnum[]
  }

  /**
   * ProfileBiography without action
   */
  export type ProfileBiographyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiography
     */
    select?: ProfileBiographySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyInclude<ExtArgs> | null
  }


  /**
   * Model ProfileBiographyArea
   */

  export type AggregateProfileBiographyArea = {
    _count: ProfileBiographyAreaCountAggregateOutputType | null
    _min: ProfileBiographyAreaMinAggregateOutputType | null
    _max: ProfileBiographyAreaMaxAggregateOutputType | null
  }

  export type ProfileBiographyAreaMinAggregateOutputType = {
    id: string | null
    biographyId: string | null
    areaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileBiographyAreaMaxAggregateOutputType = {
    id: string | null
    biographyId: string | null
    areaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileBiographyAreaCountAggregateOutputType = {
    id: number
    biographyId: number
    areaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileBiographyAreaMinAggregateInputType = {
    id?: true
    biographyId?: true
    areaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileBiographyAreaMaxAggregateInputType = {
    id?: true
    biographyId?: true
    areaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileBiographyAreaCountAggregateInputType = {
    id?: true
    biographyId?: true
    areaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileBiographyAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBiographyArea to aggregate.
     */
    where?: ProfileBiographyAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographyAreas to fetch.
     */
    orderBy?: ProfileBiographyAreaOrderByWithRelationInput | ProfileBiographyAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileBiographyAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographyAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographyAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileBiographyAreas
    **/
    _count?: true | ProfileBiographyAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileBiographyAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileBiographyAreaMaxAggregateInputType
  }

  export type GetProfileBiographyAreaAggregateType<T extends ProfileBiographyAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileBiographyArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileBiographyArea[P]>
      : GetScalarType<T[P], AggregateProfileBiographyArea[P]>
  }




  export type ProfileBiographyAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBiographyAreaWhereInput
    orderBy?: ProfileBiographyAreaOrderByWithAggregationInput | ProfileBiographyAreaOrderByWithAggregationInput[]
    by: ProfileBiographyAreaScalarFieldEnum[] | ProfileBiographyAreaScalarFieldEnum
    having?: ProfileBiographyAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileBiographyAreaCountAggregateInputType | true
    _min?: ProfileBiographyAreaMinAggregateInputType
    _max?: ProfileBiographyAreaMaxAggregateInputType
  }

  export type ProfileBiographyAreaGroupByOutputType = {
    id: string
    biographyId: string
    areaId: string
    createdAt: Date
    updatedAt: Date
    _count: ProfileBiographyAreaCountAggregateOutputType | null
    _min: ProfileBiographyAreaMinAggregateOutputType | null
    _max: ProfileBiographyAreaMaxAggregateOutputType | null
  }

  type GetProfileBiographyAreaGroupByPayload<T extends ProfileBiographyAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileBiographyAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileBiographyAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileBiographyAreaGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileBiographyAreaGroupByOutputType[P]>
        }
      >
    >


  export type ProfileBiographyAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    biographyId?: boolean
    areaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    biography?: boolean | ProfileBiographyDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBiographyArea"]>

  export type ProfileBiographyAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    biographyId?: boolean
    areaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    biography?: boolean | ProfileBiographyDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBiographyArea"]>

  export type ProfileBiographyAreaSelectScalar = {
    id?: boolean
    biographyId?: boolean
    areaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileBiographyAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    biography?: boolean | ProfileBiographyDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }
  export type ProfileBiographyAreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    biography?: boolean | ProfileBiographyDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }

  export type $ProfileBiographyAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileBiographyArea"
    objects: {
      biography: Prisma.$ProfileBiographyPayload<ExtArgs>
      area: Prisma.$AreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      biographyId: string
      areaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profileBiographyArea"]>
    composites: {}
  }

  type ProfileBiographyAreaGetPayload<S extends boolean | null | undefined | ProfileBiographyAreaDefaultArgs> = $Result.GetResult<Prisma.$ProfileBiographyAreaPayload, S>

  type ProfileBiographyAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileBiographyAreaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileBiographyAreaCountAggregateInputType | true
    }

  export interface ProfileBiographyAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileBiographyArea'], meta: { name: 'ProfileBiographyArea' } }
    /**
     * Find zero or one ProfileBiographyArea that matches the filter.
     * @param {ProfileBiographyAreaFindUniqueArgs} args - Arguments to find a ProfileBiographyArea
     * @example
     * // Get one ProfileBiographyArea
     * const profileBiographyArea = await prisma.profileBiographyArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileBiographyAreaFindUniqueArgs>(args: SelectSubset<T, ProfileBiographyAreaFindUniqueArgs<ExtArgs>>): Prisma__ProfileBiographyAreaClient<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileBiographyArea that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileBiographyAreaFindUniqueOrThrowArgs} args - Arguments to find a ProfileBiographyArea
     * @example
     * // Get one ProfileBiographyArea
     * const profileBiographyArea = await prisma.profileBiographyArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileBiographyAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileBiographyAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileBiographyAreaClient<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileBiographyArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyAreaFindFirstArgs} args - Arguments to find a ProfileBiographyArea
     * @example
     * // Get one ProfileBiographyArea
     * const profileBiographyArea = await prisma.profileBiographyArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileBiographyAreaFindFirstArgs>(args?: SelectSubset<T, ProfileBiographyAreaFindFirstArgs<ExtArgs>>): Prisma__ProfileBiographyAreaClient<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileBiographyArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyAreaFindFirstOrThrowArgs} args - Arguments to find a ProfileBiographyArea
     * @example
     * // Get one ProfileBiographyArea
     * const profileBiographyArea = await prisma.profileBiographyArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileBiographyAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileBiographyAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileBiographyAreaClient<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileBiographyAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileBiographyAreas
     * const profileBiographyAreas = await prisma.profileBiographyArea.findMany()
     * 
     * // Get first 10 ProfileBiographyAreas
     * const profileBiographyAreas = await prisma.profileBiographyArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileBiographyAreaWithIdOnly = await prisma.profileBiographyArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileBiographyAreaFindManyArgs>(args?: SelectSubset<T, ProfileBiographyAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileBiographyArea.
     * @param {ProfileBiographyAreaCreateArgs} args - Arguments to create a ProfileBiographyArea.
     * @example
     * // Create one ProfileBiographyArea
     * const ProfileBiographyArea = await prisma.profileBiographyArea.create({
     *   data: {
     *     // ... data to create a ProfileBiographyArea
     *   }
     * })
     * 
     */
    create<T extends ProfileBiographyAreaCreateArgs>(args: SelectSubset<T, ProfileBiographyAreaCreateArgs<ExtArgs>>): Prisma__ProfileBiographyAreaClient<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileBiographyAreas.
     * @param {ProfileBiographyAreaCreateManyArgs} args - Arguments to create many ProfileBiographyAreas.
     * @example
     * // Create many ProfileBiographyAreas
     * const profileBiographyArea = await prisma.profileBiographyArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileBiographyAreaCreateManyArgs>(args?: SelectSubset<T, ProfileBiographyAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileBiographyAreas and returns the data saved in the database.
     * @param {ProfileBiographyAreaCreateManyAndReturnArgs} args - Arguments to create many ProfileBiographyAreas.
     * @example
     * // Create many ProfileBiographyAreas
     * const profileBiographyArea = await prisma.profileBiographyArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileBiographyAreas and only return the `id`
     * const profileBiographyAreaWithIdOnly = await prisma.profileBiographyArea.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileBiographyAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileBiographyAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileBiographyArea.
     * @param {ProfileBiographyAreaDeleteArgs} args - Arguments to delete one ProfileBiographyArea.
     * @example
     * // Delete one ProfileBiographyArea
     * const ProfileBiographyArea = await prisma.profileBiographyArea.delete({
     *   where: {
     *     // ... filter to delete one ProfileBiographyArea
     *   }
     * })
     * 
     */
    delete<T extends ProfileBiographyAreaDeleteArgs>(args: SelectSubset<T, ProfileBiographyAreaDeleteArgs<ExtArgs>>): Prisma__ProfileBiographyAreaClient<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileBiographyArea.
     * @param {ProfileBiographyAreaUpdateArgs} args - Arguments to update one ProfileBiographyArea.
     * @example
     * // Update one ProfileBiographyArea
     * const profileBiographyArea = await prisma.profileBiographyArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileBiographyAreaUpdateArgs>(args: SelectSubset<T, ProfileBiographyAreaUpdateArgs<ExtArgs>>): Prisma__ProfileBiographyAreaClient<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileBiographyAreas.
     * @param {ProfileBiographyAreaDeleteManyArgs} args - Arguments to filter ProfileBiographyAreas to delete.
     * @example
     * // Delete a few ProfileBiographyAreas
     * const { count } = await prisma.profileBiographyArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileBiographyAreaDeleteManyArgs>(args?: SelectSubset<T, ProfileBiographyAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileBiographyAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileBiographyAreas
     * const profileBiographyArea = await prisma.profileBiographyArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileBiographyAreaUpdateManyArgs>(args: SelectSubset<T, ProfileBiographyAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileBiographyArea.
     * @param {ProfileBiographyAreaUpsertArgs} args - Arguments to update or create a ProfileBiographyArea.
     * @example
     * // Update or create a ProfileBiographyArea
     * const profileBiographyArea = await prisma.profileBiographyArea.upsert({
     *   create: {
     *     // ... data to create a ProfileBiographyArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileBiographyArea we want to update
     *   }
     * })
     */
    upsert<T extends ProfileBiographyAreaUpsertArgs>(args: SelectSubset<T, ProfileBiographyAreaUpsertArgs<ExtArgs>>): Prisma__ProfileBiographyAreaClient<$Result.GetResult<Prisma.$ProfileBiographyAreaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileBiographyAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyAreaCountArgs} args - Arguments to filter ProfileBiographyAreas to count.
     * @example
     * // Count the number of ProfileBiographyAreas
     * const count = await prisma.profileBiographyArea.count({
     *   where: {
     *     // ... the filter for the ProfileBiographyAreas we want to count
     *   }
     * })
    **/
    count<T extends ProfileBiographyAreaCountArgs>(
      args?: Subset<T, ProfileBiographyAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileBiographyAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileBiographyArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileBiographyAreaAggregateArgs>(args: Subset<T, ProfileBiographyAreaAggregateArgs>): Prisma.PrismaPromise<GetProfileBiographyAreaAggregateType<T>>

    /**
     * Group by ProfileBiographyArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographyAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileBiographyAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileBiographyAreaGroupByArgs['orderBy'] }
        : { orderBy?: ProfileBiographyAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileBiographyAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileBiographyAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileBiographyArea model
   */
  readonly fields: ProfileBiographyAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileBiographyArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileBiographyAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    biography<T extends ProfileBiographyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileBiographyDefaultArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileBiographyArea model
   */ 
  interface ProfileBiographyAreaFieldRefs {
    readonly id: FieldRef<"ProfileBiographyArea", 'String'>
    readonly biographyId: FieldRef<"ProfileBiographyArea", 'String'>
    readonly areaId: FieldRef<"ProfileBiographyArea", 'String'>
    readonly createdAt: FieldRef<"ProfileBiographyArea", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfileBiographyArea", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileBiographyArea findUnique
   */
  export type ProfileBiographyAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographyArea to fetch.
     */
    where: ProfileBiographyAreaWhereUniqueInput
  }

  /**
   * ProfileBiographyArea findUniqueOrThrow
   */
  export type ProfileBiographyAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographyArea to fetch.
     */
    where: ProfileBiographyAreaWhereUniqueInput
  }

  /**
   * ProfileBiographyArea findFirst
   */
  export type ProfileBiographyAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographyArea to fetch.
     */
    where?: ProfileBiographyAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographyAreas to fetch.
     */
    orderBy?: ProfileBiographyAreaOrderByWithRelationInput | ProfileBiographyAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBiographyAreas.
     */
    cursor?: ProfileBiographyAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographyAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographyAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBiographyAreas.
     */
    distinct?: ProfileBiographyAreaScalarFieldEnum | ProfileBiographyAreaScalarFieldEnum[]
  }

  /**
   * ProfileBiographyArea findFirstOrThrow
   */
  export type ProfileBiographyAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographyArea to fetch.
     */
    where?: ProfileBiographyAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographyAreas to fetch.
     */
    orderBy?: ProfileBiographyAreaOrderByWithRelationInput | ProfileBiographyAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBiographyAreas.
     */
    cursor?: ProfileBiographyAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographyAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographyAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBiographyAreas.
     */
    distinct?: ProfileBiographyAreaScalarFieldEnum | ProfileBiographyAreaScalarFieldEnum[]
  }

  /**
   * ProfileBiographyArea findMany
   */
  export type ProfileBiographyAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographyAreas to fetch.
     */
    where?: ProfileBiographyAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographyAreas to fetch.
     */
    orderBy?: ProfileBiographyAreaOrderByWithRelationInput | ProfileBiographyAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileBiographyAreas.
     */
    cursor?: ProfileBiographyAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographyAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographyAreas.
     */
    skip?: number
    distinct?: ProfileBiographyAreaScalarFieldEnum | ProfileBiographyAreaScalarFieldEnum[]
  }

  /**
   * ProfileBiographyArea create
   */
  export type ProfileBiographyAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileBiographyArea.
     */
    data: XOR<ProfileBiographyAreaCreateInput, ProfileBiographyAreaUncheckedCreateInput>
  }

  /**
   * ProfileBiographyArea createMany
   */
  export type ProfileBiographyAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileBiographyAreas.
     */
    data: ProfileBiographyAreaCreateManyInput | ProfileBiographyAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileBiographyArea createManyAndReturn
   */
  export type ProfileBiographyAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileBiographyAreas.
     */
    data: ProfileBiographyAreaCreateManyInput | ProfileBiographyAreaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileBiographyArea update
   */
  export type ProfileBiographyAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileBiographyArea.
     */
    data: XOR<ProfileBiographyAreaUpdateInput, ProfileBiographyAreaUncheckedUpdateInput>
    /**
     * Choose, which ProfileBiographyArea to update.
     */
    where: ProfileBiographyAreaWhereUniqueInput
  }

  /**
   * ProfileBiographyArea updateMany
   */
  export type ProfileBiographyAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileBiographyAreas.
     */
    data: XOR<ProfileBiographyAreaUpdateManyMutationInput, ProfileBiographyAreaUncheckedUpdateManyInput>
    /**
     * Filter which ProfileBiographyAreas to update
     */
    where?: ProfileBiographyAreaWhereInput
  }

  /**
   * ProfileBiographyArea upsert
   */
  export type ProfileBiographyAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileBiographyArea to update in case it exists.
     */
    where: ProfileBiographyAreaWhereUniqueInput
    /**
     * In case the ProfileBiographyArea found by the `where` argument doesn't exist, create a new ProfileBiographyArea with this data.
     */
    create: XOR<ProfileBiographyAreaCreateInput, ProfileBiographyAreaUncheckedCreateInput>
    /**
     * In case the ProfileBiographyArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileBiographyAreaUpdateInput, ProfileBiographyAreaUncheckedUpdateInput>
  }

  /**
   * ProfileBiographyArea delete
   */
  export type ProfileBiographyAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
    /**
     * Filter which ProfileBiographyArea to delete.
     */
    where: ProfileBiographyAreaWhereUniqueInput
  }

  /**
   * ProfileBiographyArea deleteMany
   */
  export type ProfileBiographyAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBiographyAreas to delete
     */
    where?: ProfileBiographyAreaWhereInput
  }

  /**
   * ProfileBiographyArea without action
   */
  export type ProfileBiographyAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographyArea
     */
    select?: ProfileBiographyAreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographyAreaInclude<ExtArgs> | null
  }


  /**
   * Model ProfileBiographySocial
   */

  export type AggregateProfileBiographySocial = {
    _count: ProfileBiographySocialCountAggregateOutputType | null
    _min: ProfileBiographySocialMinAggregateOutputType | null
    _max: ProfileBiographySocialMaxAggregateOutputType | null
  }

  export type ProfileBiographySocialMinAggregateOutputType = {
    id: string | null
    type: $Enums.SocialType | null
    href: string | null
    profileBiographyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileBiographySocialMaxAggregateOutputType = {
    id: string | null
    type: $Enums.SocialType | null
    href: string | null
    profileBiographyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileBiographySocialCountAggregateOutputType = {
    id: number
    type: number
    href: number
    profileBiographyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileBiographySocialMinAggregateInputType = {
    id?: true
    type?: true
    href?: true
    profileBiographyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileBiographySocialMaxAggregateInputType = {
    id?: true
    type?: true
    href?: true
    profileBiographyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileBiographySocialCountAggregateInputType = {
    id?: true
    type?: true
    href?: true
    profileBiographyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileBiographySocialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBiographySocial to aggregate.
     */
    where?: ProfileBiographySocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographySocials to fetch.
     */
    orderBy?: ProfileBiographySocialOrderByWithRelationInput | ProfileBiographySocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileBiographySocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographySocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographySocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileBiographySocials
    **/
    _count?: true | ProfileBiographySocialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileBiographySocialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileBiographySocialMaxAggregateInputType
  }

  export type GetProfileBiographySocialAggregateType<T extends ProfileBiographySocialAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileBiographySocial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileBiographySocial[P]>
      : GetScalarType<T[P], AggregateProfileBiographySocial[P]>
  }




  export type ProfileBiographySocialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBiographySocialWhereInput
    orderBy?: ProfileBiographySocialOrderByWithAggregationInput | ProfileBiographySocialOrderByWithAggregationInput[]
    by: ProfileBiographySocialScalarFieldEnum[] | ProfileBiographySocialScalarFieldEnum
    having?: ProfileBiographySocialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileBiographySocialCountAggregateInputType | true
    _min?: ProfileBiographySocialMinAggregateInputType
    _max?: ProfileBiographySocialMaxAggregateInputType
  }

  export type ProfileBiographySocialGroupByOutputType = {
    id: string
    type: $Enums.SocialType
    href: string
    profileBiographyId: string
    createdAt: Date
    updatedAt: Date
    _count: ProfileBiographySocialCountAggregateOutputType | null
    _min: ProfileBiographySocialMinAggregateOutputType | null
    _max: ProfileBiographySocialMaxAggregateOutputType | null
  }

  type GetProfileBiographySocialGroupByPayload<T extends ProfileBiographySocialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileBiographySocialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileBiographySocialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileBiographySocialGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileBiographySocialGroupByOutputType[P]>
        }
      >
    >


  export type ProfileBiographySocialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    href?: boolean
    profileBiographyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileBiography?: boolean | ProfileBiographyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBiographySocial"]>

  export type ProfileBiographySocialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    href?: boolean
    profileBiographyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileBiography?: boolean | ProfileBiographyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBiographySocial"]>

  export type ProfileBiographySocialSelectScalar = {
    id?: boolean
    type?: boolean
    href?: boolean
    profileBiographyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileBiographySocialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileBiography?: boolean | ProfileBiographyDefaultArgs<ExtArgs>
  }
  export type ProfileBiographySocialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileBiography?: boolean | ProfileBiographyDefaultArgs<ExtArgs>
  }

  export type $ProfileBiographySocialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileBiographySocial"
    objects: {
      profileBiography: Prisma.$ProfileBiographyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.SocialType
      href: string
      profileBiographyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profileBiographySocial"]>
    composites: {}
  }

  type ProfileBiographySocialGetPayload<S extends boolean | null | undefined | ProfileBiographySocialDefaultArgs> = $Result.GetResult<Prisma.$ProfileBiographySocialPayload, S>

  type ProfileBiographySocialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileBiographySocialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileBiographySocialCountAggregateInputType | true
    }

  export interface ProfileBiographySocialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileBiographySocial'], meta: { name: 'ProfileBiographySocial' } }
    /**
     * Find zero or one ProfileBiographySocial that matches the filter.
     * @param {ProfileBiographySocialFindUniqueArgs} args - Arguments to find a ProfileBiographySocial
     * @example
     * // Get one ProfileBiographySocial
     * const profileBiographySocial = await prisma.profileBiographySocial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileBiographySocialFindUniqueArgs>(args: SelectSubset<T, ProfileBiographySocialFindUniqueArgs<ExtArgs>>): Prisma__ProfileBiographySocialClient<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileBiographySocial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileBiographySocialFindUniqueOrThrowArgs} args - Arguments to find a ProfileBiographySocial
     * @example
     * // Get one ProfileBiographySocial
     * const profileBiographySocial = await prisma.profileBiographySocial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileBiographySocialFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileBiographySocialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileBiographySocialClient<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileBiographySocial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographySocialFindFirstArgs} args - Arguments to find a ProfileBiographySocial
     * @example
     * // Get one ProfileBiographySocial
     * const profileBiographySocial = await prisma.profileBiographySocial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileBiographySocialFindFirstArgs>(args?: SelectSubset<T, ProfileBiographySocialFindFirstArgs<ExtArgs>>): Prisma__ProfileBiographySocialClient<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileBiographySocial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographySocialFindFirstOrThrowArgs} args - Arguments to find a ProfileBiographySocial
     * @example
     * // Get one ProfileBiographySocial
     * const profileBiographySocial = await prisma.profileBiographySocial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileBiographySocialFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileBiographySocialFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileBiographySocialClient<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileBiographySocials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographySocialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileBiographySocials
     * const profileBiographySocials = await prisma.profileBiographySocial.findMany()
     * 
     * // Get first 10 ProfileBiographySocials
     * const profileBiographySocials = await prisma.profileBiographySocial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileBiographySocialWithIdOnly = await prisma.profileBiographySocial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileBiographySocialFindManyArgs>(args?: SelectSubset<T, ProfileBiographySocialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileBiographySocial.
     * @param {ProfileBiographySocialCreateArgs} args - Arguments to create a ProfileBiographySocial.
     * @example
     * // Create one ProfileBiographySocial
     * const ProfileBiographySocial = await prisma.profileBiographySocial.create({
     *   data: {
     *     // ... data to create a ProfileBiographySocial
     *   }
     * })
     * 
     */
    create<T extends ProfileBiographySocialCreateArgs>(args: SelectSubset<T, ProfileBiographySocialCreateArgs<ExtArgs>>): Prisma__ProfileBiographySocialClient<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileBiographySocials.
     * @param {ProfileBiographySocialCreateManyArgs} args - Arguments to create many ProfileBiographySocials.
     * @example
     * // Create many ProfileBiographySocials
     * const profileBiographySocial = await prisma.profileBiographySocial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileBiographySocialCreateManyArgs>(args?: SelectSubset<T, ProfileBiographySocialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileBiographySocials and returns the data saved in the database.
     * @param {ProfileBiographySocialCreateManyAndReturnArgs} args - Arguments to create many ProfileBiographySocials.
     * @example
     * // Create many ProfileBiographySocials
     * const profileBiographySocial = await prisma.profileBiographySocial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileBiographySocials and only return the `id`
     * const profileBiographySocialWithIdOnly = await prisma.profileBiographySocial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileBiographySocialCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileBiographySocialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileBiographySocial.
     * @param {ProfileBiographySocialDeleteArgs} args - Arguments to delete one ProfileBiographySocial.
     * @example
     * // Delete one ProfileBiographySocial
     * const ProfileBiographySocial = await prisma.profileBiographySocial.delete({
     *   where: {
     *     // ... filter to delete one ProfileBiographySocial
     *   }
     * })
     * 
     */
    delete<T extends ProfileBiographySocialDeleteArgs>(args: SelectSubset<T, ProfileBiographySocialDeleteArgs<ExtArgs>>): Prisma__ProfileBiographySocialClient<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileBiographySocial.
     * @param {ProfileBiographySocialUpdateArgs} args - Arguments to update one ProfileBiographySocial.
     * @example
     * // Update one ProfileBiographySocial
     * const profileBiographySocial = await prisma.profileBiographySocial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileBiographySocialUpdateArgs>(args: SelectSubset<T, ProfileBiographySocialUpdateArgs<ExtArgs>>): Prisma__ProfileBiographySocialClient<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileBiographySocials.
     * @param {ProfileBiographySocialDeleteManyArgs} args - Arguments to filter ProfileBiographySocials to delete.
     * @example
     * // Delete a few ProfileBiographySocials
     * const { count } = await prisma.profileBiographySocial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileBiographySocialDeleteManyArgs>(args?: SelectSubset<T, ProfileBiographySocialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileBiographySocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographySocialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileBiographySocials
     * const profileBiographySocial = await prisma.profileBiographySocial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileBiographySocialUpdateManyArgs>(args: SelectSubset<T, ProfileBiographySocialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileBiographySocial.
     * @param {ProfileBiographySocialUpsertArgs} args - Arguments to update or create a ProfileBiographySocial.
     * @example
     * // Update or create a ProfileBiographySocial
     * const profileBiographySocial = await prisma.profileBiographySocial.upsert({
     *   create: {
     *     // ... data to create a ProfileBiographySocial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileBiographySocial we want to update
     *   }
     * })
     */
    upsert<T extends ProfileBiographySocialUpsertArgs>(args: SelectSubset<T, ProfileBiographySocialUpsertArgs<ExtArgs>>): Prisma__ProfileBiographySocialClient<$Result.GetResult<Prisma.$ProfileBiographySocialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileBiographySocials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographySocialCountArgs} args - Arguments to filter ProfileBiographySocials to count.
     * @example
     * // Count the number of ProfileBiographySocials
     * const count = await prisma.profileBiographySocial.count({
     *   where: {
     *     // ... the filter for the ProfileBiographySocials we want to count
     *   }
     * })
    **/
    count<T extends ProfileBiographySocialCountArgs>(
      args?: Subset<T, ProfileBiographySocialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileBiographySocialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileBiographySocial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographySocialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileBiographySocialAggregateArgs>(args: Subset<T, ProfileBiographySocialAggregateArgs>): Prisma.PrismaPromise<GetProfileBiographySocialAggregateType<T>>

    /**
     * Group by ProfileBiographySocial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBiographySocialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileBiographySocialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileBiographySocialGroupByArgs['orderBy'] }
        : { orderBy?: ProfileBiographySocialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileBiographySocialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileBiographySocialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileBiographySocial model
   */
  readonly fields: ProfileBiographySocialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileBiographySocial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileBiographySocialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profileBiography<T extends ProfileBiographyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileBiographyDefaultArgs<ExtArgs>>): Prisma__ProfileBiographyClient<$Result.GetResult<Prisma.$ProfileBiographyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileBiographySocial model
   */ 
  interface ProfileBiographySocialFieldRefs {
    readonly id: FieldRef<"ProfileBiographySocial", 'String'>
    readonly type: FieldRef<"ProfileBiographySocial", 'SocialType'>
    readonly href: FieldRef<"ProfileBiographySocial", 'String'>
    readonly profileBiographyId: FieldRef<"ProfileBiographySocial", 'String'>
    readonly createdAt: FieldRef<"ProfileBiographySocial", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfileBiographySocial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileBiographySocial findUnique
   */
  export type ProfileBiographySocialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographySocial to fetch.
     */
    where: ProfileBiographySocialWhereUniqueInput
  }

  /**
   * ProfileBiographySocial findUniqueOrThrow
   */
  export type ProfileBiographySocialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographySocial to fetch.
     */
    where: ProfileBiographySocialWhereUniqueInput
  }

  /**
   * ProfileBiographySocial findFirst
   */
  export type ProfileBiographySocialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographySocial to fetch.
     */
    where?: ProfileBiographySocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographySocials to fetch.
     */
    orderBy?: ProfileBiographySocialOrderByWithRelationInput | ProfileBiographySocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBiographySocials.
     */
    cursor?: ProfileBiographySocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographySocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographySocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBiographySocials.
     */
    distinct?: ProfileBiographySocialScalarFieldEnum | ProfileBiographySocialScalarFieldEnum[]
  }

  /**
   * ProfileBiographySocial findFirstOrThrow
   */
  export type ProfileBiographySocialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographySocial to fetch.
     */
    where?: ProfileBiographySocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographySocials to fetch.
     */
    orderBy?: ProfileBiographySocialOrderByWithRelationInput | ProfileBiographySocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBiographySocials.
     */
    cursor?: ProfileBiographySocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographySocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographySocials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBiographySocials.
     */
    distinct?: ProfileBiographySocialScalarFieldEnum | ProfileBiographySocialScalarFieldEnum[]
  }

  /**
   * ProfileBiographySocial findMany
   */
  export type ProfileBiographySocialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBiographySocials to fetch.
     */
    where?: ProfileBiographySocialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBiographySocials to fetch.
     */
    orderBy?: ProfileBiographySocialOrderByWithRelationInput | ProfileBiographySocialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileBiographySocials.
     */
    cursor?: ProfileBiographySocialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBiographySocials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBiographySocials.
     */
    skip?: number
    distinct?: ProfileBiographySocialScalarFieldEnum | ProfileBiographySocialScalarFieldEnum[]
  }

  /**
   * ProfileBiographySocial create
   */
  export type ProfileBiographySocialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileBiographySocial.
     */
    data: XOR<ProfileBiographySocialCreateInput, ProfileBiographySocialUncheckedCreateInput>
  }

  /**
   * ProfileBiographySocial createMany
   */
  export type ProfileBiographySocialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileBiographySocials.
     */
    data: ProfileBiographySocialCreateManyInput | ProfileBiographySocialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileBiographySocial createManyAndReturn
   */
  export type ProfileBiographySocialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileBiographySocials.
     */
    data: ProfileBiographySocialCreateManyInput | ProfileBiographySocialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileBiographySocial update
   */
  export type ProfileBiographySocialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileBiographySocial.
     */
    data: XOR<ProfileBiographySocialUpdateInput, ProfileBiographySocialUncheckedUpdateInput>
    /**
     * Choose, which ProfileBiographySocial to update.
     */
    where: ProfileBiographySocialWhereUniqueInput
  }

  /**
   * ProfileBiographySocial updateMany
   */
  export type ProfileBiographySocialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileBiographySocials.
     */
    data: XOR<ProfileBiographySocialUpdateManyMutationInput, ProfileBiographySocialUncheckedUpdateManyInput>
    /**
     * Filter which ProfileBiographySocials to update
     */
    where?: ProfileBiographySocialWhereInput
  }

  /**
   * ProfileBiographySocial upsert
   */
  export type ProfileBiographySocialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileBiographySocial to update in case it exists.
     */
    where: ProfileBiographySocialWhereUniqueInput
    /**
     * In case the ProfileBiographySocial found by the `where` argument doesn't exist, create a new ProfileBiographySocial with this data.
     */
    create: XOR<ProfileBiographySocialCreateInput, ProfileBiographySocialUncheckedCreateInput>
    /**
     * In case the ProfileBiographySocial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileBiographySocialUpdateInput, ProfileBiographySocialUncheckedUpdateInput>
  }

  /**
   * ProfileBiographySocial delete
   */
  export type ProfileBiographySocialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
    /**
     * Filter which ProfileBiographySocial to delete.
     */
    where: ProfileBiographySocialWhereUniqueInput
  }

  /**
   * ProfileBiographySocial deleteMany
   */
  export type ProfileBiographySocialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBiographySocials to delete
     */
    where?: ProfileBiographySocialWhereInput
  }

  /**
   * ProfileBiographySocial without action
   */
  export type ProfileBiographySocialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBiographySocial
     */
    select?: ProfileBiographySocialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBiographySocialInclude<ExtArgs> | null
  }


  /**
   * Model ProfileBlog
   */

  export type AggregateProfileBlog = {
    _count: ProfileBlogCountAggregateOutputType | null
    _min: ProfileBlogMinAggregateOutputType | null
    _max: ProfileBlogMaxAggregateOutputType | null
  }

  export type ProfileBlogMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileBlogMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileBlogCountAggregateOutputType = {
    id: number
    title: number
    content: number
    profileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileBlogMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileBlogMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileBlogCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileBlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBlog to aggregate.
     */
    where?: ProfileBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBlogs to fetch.
     */
    orderBy?: ProfileBlogOrderByWithRelationInput | ProfileBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileBlogs
    **/
    _count?: true | ProfileBlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileBlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileBlogMaxAggregateInputType
  }

  export type GetProfileBlogAggregateType<T extends ProfileBlogAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileBlog[P]>
      : GetScalarType<T[P], AggregateProfileBlog[P]>
  }




  export type ProfileBlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBlogWhereInput
    orderBy?: ProfileBlogOrderByWithAggregationInput | ProfileBlogOrderByWithAggregationInput[]
    by: ProfileBlogScalarFieldEnum[] | ProfileBlogScalarFieldEnum
    having?: ProfileBlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileBlogCountAggregateInputType | true
    _min?: ProfileBlogMinAggregateInputType
    _max?: ProfileBlogMaxAggregateInputType
  }

  export type ProfileBlogGroupByOutputType = {
    id: string
    title: string
    content: string | null
    profileId: string
    createdAt: Date
    updatedAt: Date
    _count: ProfileBlogCountAggregateOutputType | null
    _min: ProfileBlogMinAggregateOutputType | null
    _max: ProfileBlogMaxAggregateOutputType | null
  }

  type GetProfileBlogGroupByPayload<T extends ProfileBlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileBlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileBlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileBlogGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileBlogGroupByOutputType[P]>
        }
      >
    >


  export type ProfileBlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | ProfileBlog$imagesArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    _count?: boolean | ProfileBlogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBlog"]>

  export type ProfileBlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBlog"]>

  export type ProfileBlogSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileBlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ProfileBlog$imagesArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    _count?: boolean | ProfileBlogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileBlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfileBlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileBlog"
    objects: {
      images: Prisma.$ProfileBlogImagePayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string | null
      profileId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profileBlog"]>
    composites: {}
  }

  type ProfileBlogGetPayload<S extends boolean | null | undefined | ProfileBlogDefaultArgs> = $Result.GetResult<Prisma.$ProfileBlogPayload, S>

  type ProfileBlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileBlogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileBlogCountAggregateInputType | true
    }

  export interface ProfileBlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileBlog'], meta: { name: 'ProfileBlog' } }
    /**
     * Find zero or one ProfileBlog that matches the filter.
     * @param {ProfileBlogFindUniqueArgs} args - Arguments to find a ProfileBlog
     * @example
     * // Get one ProfileBlog
     * const profileBlog = await prisma.profileBlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileBlogFindUniqueArgs>(args: SelectSubset<T, ProfileBlogFindUniqueArgs<ExtArgs>>): Prisma__ProfileBlogClient<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileBlog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileBlogFindUniqueOrThrowArgs} args - Arguments to find a ProfileBlog
     * @example
     * // Get one ProfileBlog
     * const profileBlog = await prisma.profileBlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileBlogFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileBlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileBlogClient<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileBlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogFindFirstArgs} args - Arguments to find a ProfileBlog
     * @example
     * // Get one ProfileBlog
     * const profileBlog = await prisma.profileBlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileBlogFindFirstArgs>(args?: SelectSubset<T, ProfileBlogFindFirstArgs<ExtArgs>>): Prisma__ProfileBlogClient<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileBlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogFindFirstOrThrowArgs} args - Arguments to find a ProfileBlog
     * @example
     * // Get one ProfileBlog
     * const profileBlog = await prisma.profileBlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileBlogFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileBlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileBlogClient<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileBlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileBlogs
     * const profileBlogs = await prisma.profileBlog.findMany()
     * 
     * // Get first 10 ProfileBlogs
     * const profileBlogs = await prisma.profileBlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileBlogWithIdOnly = await prisma.profileBlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileBlogFindManyArgs>(args?: SelectSubset<T, ProfileBlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileBlog.
     * @param {ProfileBlogCreateArgs} args - Arguments to create a ProfileBlog.
     * @example
     * // Create one ProfileBlog
     * const ProfileBlog = await prisma.profileBlog.create({
     *   data: {
     *     // ... data to create a ProfileBlog
     *   }
     * })
     * 
     */
    create<T extends ProfileBlogCreateArgs>(args: SelectSubset<T, ProfileBlogCreateArgs<ExtArgs>>): Prisma__ProfileBlogClient<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileBlogs.
     * @param {ProfileBlogCreateManyArgs} args - Arguments to create many ProfileBlogs.
     * @example
     * // Create many ProfileBlogs
     * const profileBlog = await prisma.profileBlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileBlogCreateManyArgs>(args?: SelectSubset<T, ProfileBlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileBlogs and returns the data saved in the database.
     * @param {ProfileBlogCreateManyAndReturnArgs} args - Arguments to create many ProfileBlogs.
     * @example
     * // Create many ProfileBlogs
     * const profileBlog = await prisma.profileBlog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileBlogs and only return the `id`
     * const profileBlogWithIdOnly = await prisma.profileBlog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileBlogCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileBlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileBlog.
     * @param {ProfileBlogDeleteArgs} args - Arguments to delete one ProfileBlog.
     * @example
     * // Delete one ProfileBlog
     * const ProfileBlog = await prisma.profileBlog.delete({
     *   where: {
     *     // ... filter to delete one ProfileBlog
     *   }
     * })
     * 
     */
    delete<T extends ProfileBlogDeleteArgs>(args: SelectSubset<T, ProfileBlogDeleteArgs<ExtArgs>>): Prisma__ProfileBlogClient<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileBlog.
     * @param {ProfileBlogUpdateArgs} args - Arguments to update one ProfileBlog.
     * @example
     * // Update one ProfileBlog
     * const profileBlog = await prisma.profileBlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileBlogUpdateArgs>(args: SelectSubset<T, ProfileBlogUpdateArgs<ExtArgs>>): Prisma__ProfileBlogClient<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileBlogs.
     * @param {ProfileBlogDeleteManyArgs} args - Arguments to filter ProfileBlogs to delete.
     * @example
     * // Delete a few ProfileBlogs
     * const { count } = await prisma.profileBlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileBlogDeleteManyArgs>(args?: SelectSubset<T, ProfileBlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileBlogs
     * const profileBlog = await prisma.profileBlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileBlogUpdateManyArgs>(args: SelectSubset<T, ProfileBlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileBlog.
     * @param {ProfileBlogUpsertArgs} args - Arguments to update or create a ProfileBlog.
     * @example
     * // Update or create a ProfileBlog
     * const profileBlog = await prisma.profileBlog.upsert({
     *   create: {
     *     // ... data to create a ProfileBlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileBlog we want to update
     *   }
     * })
     */
    upsert<T extends ProfileBlogUpsertArgs>(args: SelectSubset<T, ProfileBlogUpsertArgs<ExtArgs>>): Prisma__ProfileBlogClient<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogCountArgs} args - Arguments to filter ProfileBlogs to count.
     * @example
     * // Count the number of ProfileBlogs
     * const count = await prisma.profileBlog.count({
     *   where: {
     *     // ... the filter for the ProfileBlogs we want to count
     *   }
     * })
    **/
    count<T extends ProfileBlogCountArgs>(
      args?: Subset<T, ProfileBlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileBlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileBlogAggregateArgs>(args: Subset<T, ProfileBlogAggregateArgs>): Prisma.PrismaPromise<GetProfileBlogAggregateType<T>>

    /**
     * Group by ProfileBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileBlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileBlogGroupByArgs['orderBy'] }
        : { orderBy?: ProfileBlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileBlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileBlog model
   */
  readonly fields: ProfileBlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileBlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileBlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends ProfileBlog$imagesArgs<ExtArgs> = {}>(args?: Subset<T, ProfileBlog$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileBlog model
   */ 
  interface ProfileBlogFieldRefs {
    readonly id: FieldRef<"ProfileBlog", 'String'>
    readonly title: FieldRef<"ProfileBlog", 'String'>
    readonly content: FieldRef<"ProfileBlog", 'String'>
    readonly profileId: FieldRef<"ProfileBlog", 'String'>
    readonly createdAt: FieldRef<"ProfileBlog", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfileBlog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileBlog findUnique
   */
  export type ProfileBlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlog to fetch.
     */
    where: ProfileBlogWhereUniqueInput
  }

  /**
   * ProfileBlog findUniqueOrThrow
   */
  export type ProfileBlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlog to fetch.
     */
    where: ProfileBlogWhereUniqueInput
  }

  /**
   * ProfileBlog findFirst
   */
  export type ProfileBlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlog to fetch.
     */
    where?: ProfileBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBlogs to fetch.
     */
    orderBy?: ProfileBlogOrderByWithRelationInput | ProfileBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBlogs.
     */
    cursor?: ProfileBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBlogs.
     */
    distinct?: ProfileBlogScalarFieldEnum | ProfileBlogScalarFieldEnum[]
  }

  /**
   * ProfileBlog findFirstOrThrow
   */
  export type ProfileBlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlog to fetch.
     */
    where?: ProfileBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBlogs to fetch.
     */
    orderBy?: ProfileBlogOrderByWithRelationInput | ProfileBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBlogs.
     */
    cursor?: ProfileBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBlogs.
     */
    distinct?: ProfileBlogScalarFieldEnum | ProfileBlogScalarFieldEnum[]
  }

  /**
   * ProfileBlog findMany
   */
  export type ProfileBlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlogs to fetch.
     */
    where?: ProfileBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBlogs to fetch.
     */
    orderBy?: ProfileBlogOrderByWithRelationInput | ProfileBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileBlogs.
     */
    cursor?: ProfileBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBlogs.
     */
    skip?: number
    distinct?: ProfileBlogScalarFieldEnum | ProfileBlogScalarFieldEnum[]
  }

  /**
   * ProfileBlog create
   */
  export type ProfileBlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileBlog.
     */
    data: XOR<ProfileBlogCreateInput, ProfileBlogUncheckedCreateInput>
  }

  /**
   * ProfileBlog createMany
   */
  export type ProfileBlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileBlogs.
     */
    data: ProfileBlogCreateManyInput | ProfileBlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileBlog createManyAndReturn
   */
  export type ProfileBlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileBlogs.
     */
    data: ProfileBlogCreateManyInput | ProfileBlogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileBlog update
   */
  export type ProfileBlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileBlog.
     */
    data: XOR<ProfileBlogUpdateInput, ProfileBlogUncheckedUpdateInput>
    /**
     * Choose, which ProfileBlog to update.
     */
    where: ProfileBlogWhereUniqueInput
  }

  /**
   * ProfileBlog updateMany
   */
  export type ProfileBlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileBlogs.
     */
    data: XOR<ProfileBlogUpdateManyMutationInput, ProfileBlogUncheckedUpdateManyInput>
    /**
     * Filter which ProfileBlogs to update
     */
    where?: ProfileBlogWhereInput
  }

  /**
   * ProfileBlog upsert
   */
  export type ProfileBlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileBlog to update in case it exists.
     */
    where: ProfileBlogWhereUniqueInput
    /**
     * In case the ProfileBlog found by the `where` argument doesn't exist, create a new ProfileBlog with this data.
     */
    create: XOR<ProfileBlogCreateInput, ProfileBlogUncheckedCreateInput>
    /**
     * In case the ProfileBlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileBlogUpdateInput, ProfileBlogUncheckedUpdateInput>
  }

  /**
   * ProfileBlog delete
   */
  export type ProfileBlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
    /**
     * Filter which ProfileBlog to delete.
     */
    where: ProfileBlogWhereUniqueInput
  }

  /**
   * ProfileBlog deleteMany
   */
  export type ProfileBlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBlogs to delete
     */
    where?: ProfileBlogWhereInput
  }

  /**
   * ProfileBlog.images
   */
  export type ProfileBlog$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    where?: ProfileBlogImageWhereInput
    orderBy?: ProfileBlogImageOrderByWithRelationInput | ProfileBlogImageOrderByWithRelationInput[]
    cursor?: ProfileBlogImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileBlogImageScalarFieldEnum | ProfileBlogImageScalarFieldEnum[]
  }

  /**
   * ProfileBlog without action
   */
  export type ProfileBlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlog
     */
    select?: ProfileBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogInclude<ExtArgs> | null
  }


  /**
   * Model ProfileBlogImage
   */

  export type AggregateProfileBlogImage = {
    _count: ProfileBlogImageCountAggregateOutputType | null
    _min: ProfileBlogImageMinAggregateOutputType | null
    _max: ProfileBlogImageMaxAggregateOutputType | null
  }

  export type ProfileBlogImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    profileBlogId: string | null
  }

  export type ProfileBlogImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    profileBlogId: string | null
  }

  export type ProfileBlogImageCountAggregateOutputType = {
    id: number
    url: number
    profileBlogId: number
    _all: number
  }


  export type ProfileBlogImageMinAggregateInputType = {
    id?: true
    url?: true
    profileBlogId?: true
  }

  export type ProfileBlogImageMaxAggregateInputType = {
    id?: true
    url?: true
    profileBlogId?: true
  }

  export type ProfileBlogImageCountAggregateInputType = {
    id?: true
    url?: true
    profileBlogId?: true
    _all?: true
  }

  export type ProfileBlogImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBlogImage to aggregate.
     */
    where?: ProfileBlogImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBlogImages to fetch.
     */
    orderBy?: ProfileBlogImageOrderByWithRelationInput | ProfileBlogImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileBlogImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBlogImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBlogImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileBlogImages
    **/
    _count?: true | ProfileBlogImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileBlogImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileBlogImageMaxAggregateInputType
  }

  export type GetProfileBlogImageAggregateType<T extends ProfileBlogImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileBlogImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileBlogImage[P]>
      : GetScalarType<T[P], AggregateProfileBlogImage[P]>
  }




  export type ProfileBlogImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileBlogImageWhereInput
    orderBy?: ProfileBlogImageOrderByWithAggregationInput | ProfileBlogImageOrderByWithAggregationInput[]
    by: ProfileBlogImageScalarFieldEnum[] | ProfileBlogImageScalarFieldEnum
    having?: ProfileBlogImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileBlogImageCountAggregateInputType | true
    _min?: ProfileBlogImageMinAggregateInputType
    _max?: ProfileBlogImageMaxAggregateInputType
  }

  export type ProfileBlogImageGroupByOutputType = {
    id: string
    url: string
    profileBlogId: string
    _count: ProfileBlogImageCountAggregateOutputType | null
    _min: ProfileBlogImageMinAggregateOutputType | null
    _max: ProfileBlogImageMaxAggregateOutputType | null
  }

  type GetProfileBlogImageGroupByPayload<T extends ProfileBlogImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileBlogImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileBlogImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileBlogImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileBlogImageGroupByOutputType[P]>
        }
      >
    >


  export type ProfileBlogImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    profileBlogId?: boolean
    profileBlog?: boolean | ProfileBlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBlogImage"]>

  export type ProfileBlogImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    profileBlogId?: boolean
    profileBlog?: boolean | ProfileBlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileBlogImage"]>

  export type ProfileBlogImageSelectScalar = {
    id?: boolean
    url?: boolean
    profileBlogId?: boolean
  }

  export type ProfileBlogImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileBlog?: boolean | ProfileBlogDefaultArgs<ExtArgs>
  }
  export type ProfileBlogImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileBlog?: boolean | ProfileBlogDefaultArgs<ExtArgs>
  }

  export type $ProfileBlogImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileBlogImage"
    objects: {
      profileBlog: Prisma.$ProfileBlogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      profileBlogId: string
    }, ExtArgs["result"]["profileBlogImage"]>
    composites: {}
  }

  type ProfileBlogImageGetPayload<S extends boolean | null | undefined | ProfileBlogImageDefaultArgs> = $Result.GetResult<Prisma.$ProfileBlogImagePayload, S>

  type ProfileBlogImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileBlogImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileBlogImageCountAggregateInputType | true
    }

  export interface ProfileBlogImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileBlogImage'], meta: { name: 'ProfileBlogImage' } }
    /**
     * Find zero or one ProfileBlogImage that matches the filter.
     * @param {ProfileBlogImageFindUniqueArgs} args - Arguments to find a ProfileBlogImage
     * @example
     * // Get one ProfileBlogImage
     * const profileBlogImage = await prisma.profileBlogImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileBlogImageFindUniqueArgs>(args: SelectSubset<T, ProfileBlogImageFindUniqueArgs<ExtArgs>>): Prisma__ProfileBlogImageClient<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileBlogImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileBlogImageFindUniqueOrThrowArgs} args - Arguments to find a ProfileBlogImage
     * @example
     * // Get one ProfileBlogImage
     * const profileBlogImage = await prisma.profileBlogImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileBlogImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileBlogImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileBlogImageClient<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileBlogImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogImageFindFirstArgs} args - Arguments to find a ProfileBlogImage
     * @example
     * // Get one ProfileBlogImage
     * const profileBlogImage = await prisma.profileBlogImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileBlogImageFindFirstArgs>(args?: SelectSubset<T, ProfileBlogImageFindFirstArgs<ExtArgs>>): Prisma__ProfileBlogImageClient<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileBlogImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogImageFindFirstOrThrowArgs} args - Arguments to find a ProfileBlogImage
     * @example
     * // Get one ProfileBlogImage
     * const profileBlogImage = await prisma.profileBlogImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileBlogImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileBlogImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileBlogImageClient<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileBlogImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileBlogImages
     * const profileBlogImages = await prisma.profileBlogImage.findMany()
     * 
     * // Get first 10 ProfileBlogImages
     * const profileBlogImages = await prisma.profileBlogImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileBlogImageWithIdOnly = await prisma.profileBlogImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileBlogImageFindManyArgs>(args?: SelectSubset<T, ProfileBlogImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileBlogImage.
     * @param {ProfileBlogImageCreateArgs} args - Arguments to create a ProfileBlogImage.
     * @example
     * // Create one ProfileBlogImage
     * const ProfileBlogImage = await prisma.profileBlogImage.create({
     *   data: {
     *     // ... data to create a ProfileBlogImage
     *   }
     * })
     * 
     */
    create<T extends ProfileBlogImageCreateArgs>(args: SelectSubset<T, ProfileBlogImageCreateArgs<ExtArgs>>): Prisma__ProfileBlogImageClient<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileBlogImages.
     * @param {ProfileBlogImageCreateManyArgs} args - Arguments to create many ProfileBlogImages.
     * @example
     * // Create many ProfileBlogImages
     * const profileBlogImage = await prisma.profileBlogImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileBlogImageCreateManyArgs>(args?: SelectSubset<T, ProfileBlogImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileBlogImages and returns the data saved in the database.
     * @param {ProfileBlogImageCreateManyAndReturnArgs} args - Arguments to create many ProfileBlogImages.
     * @example
     * // Create many ProfileBlogImages
     * const profileBlogImage = await prisma.profileBlogImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileBlogImages and only return the `id`
     * const profileBlogImageWithIdOnly = await prisma.profileBlogImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileBlogImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileBlogImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileBlogImage.
     * @param {ProfileBlogImageDeleteArgs} args - Arguments to delete one ProfileBlogImage.
     * @example
     * // Delete one ProfileBlogImage
     * const ProfileBlogImage = await prisma.profileBlogImage.delete({
     *   where: {
     *     // ... filter to delete one ProfileBlogImage
     *   }
     * })
     * 
     */
    delete<T extends ProfileBlogImageDeleteArgs>(args: SelectSubset<T, ProfileBlogImageDeleteArgs<ExtArgs>>): Prisma__ProfileBlogImageClient<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileBlogImage.
     * @param {ProfileBlogImageUpdateArgs} args - Arguments to update one ProfileBlogImage.
     * @example
     * // Update one ProfileBlogImage
     * const profileBlogImage = await prisma.profileBlogImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileBlogImageUpdateArgs>(args: SelectSubset<T, ProfileBlogImageUpdateArgs<ExtArgs>>): Prisma__ProfileBlogImageClient<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileBlogImages.
     * @param {ProfileBlogImageDeleteManyArgs} args - Arguments to filter ProfileBlogImages to delete.
     * @example
     * // Delete a few ProfileBlogImages
     * const { count } = await prisma.profileBlogImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileBlogImageDeleteManyArgs>(args?: SelectSubset<T, ProfileBlogImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileBlogImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileBlogImages
     * const profileBlogImage = await prisma.profileBlogImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileBlogImageUpdateManyArgs>(args: SelectSubset<T, ProfileBlogImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileBlogImage.
     * @param {ProfileBlogImageUpsertArgs} args - Arguments to update or create a ProfileBlogImage.
     * @example
     * // Update or create a ProfileBlogImage
     * const profileBlogImage = await prisma.profileBlogImage.upsert({
     *   create: {
     *     // ... data to create a ProfileBlogImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileBlogImage we want to update
     *   }
     * })
     */
    upsert<T extends ProfileBlogImageUpsertArgs>(args: SelectSubset<T, ProfileBlogImageUpsertArgs<ExtArgs>>): Prisma__ProfileBlogImageClient<$Result.GetResult<Prisma.$ProfileBlogImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileBlogImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogImageCountArgs} args - Arguments to filter ProfileBlogImages to count.
     * @example
     * // Count the number of ProfileBlogImages
     * const count = await prisma.profileBlogImage.count({
     *   where: {
     *     // ... the filter for the ProfileBlogImages we want to count
     *   }
     * })
    **/
    count<T extends ProfileBlogImageCountArgs>(
      args?: Subset<T, ProfileBlogImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileBlogImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileBlogImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileBlogImageAggregateArgs>(args: Subset<T, ProfileBlogImageAggregateArgs>): Prisma.PrismaPromise<GetProfileBlogImageAggregateType<T>>

    /**
     * Group by ProfileBlogImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileBlogImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileBlogImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileBlogImageGroupByArgs['orderBy'] }
        : { orderBy?: ProfileBlogImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileBlogImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileBlogImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileBlogImage model
   */
  readonly fields: ProfileBlogImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileBlogImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileBlogImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profileBlog<T extends ProfileBlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileBlogDefaultArgs<ExtArgs>>): Prisma__ProfileBlogClient<$Result.GetResult<Prisma.$ProfileBlogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileBlogImage model
   */ 
  interface ProfileBlogImageFieldRefs {
    readonly id: FieldRef<"ProfileBlogImage", 'String'>
    readonly url: FieldRef<"ProfileBlogImage", 'String'>
    readonly profileBlogId: FieldRef<"ProfileBlogImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProfileBlogImage findUnique
   */
  export type ProfileBlogImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlogImage to fetch.
     */
    where: ProfileBlogImageWhereUniqueInput
  }

  /**
   * ProfileBlogImage findUniqueOrThrow
   */
  export type ProfileBlogImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlogImage to fetch.
     */
    where: ProfileBlogImageWhereUniqueInput
  }

  /**
   * ProfileBlogImage findFirst
   */
  export type ProfileBlogImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlogImage to fetch.
     */
    where?: ProfileBlogImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBlogImages to fetch.
     */
    orderBy?: ProfileBlogImageOrderByWithRelationInput | ProfileBlogImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBlogImages.
     */
    cursor?: ProfileBlogImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBlogImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBlogImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBlogImages.
     */
    distinct?: ProfileBlogImageScalarFieldEnum | ProfileBlogImageScalarFieldEnum[]
  }

  /**
   * ProfileBlogImage findFirstOrThrow
   */
  export type ProfileBlogImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlogImage to fetch.
     */
    where?: ProfileBlogImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBlogImages to fetch.
     */
    orderBy?: ProfileBlogImageOrderByWithRelationInput | ProfileBlogImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileBlogImages.
     */
    cursor?: ProfileBlogImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBlogImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBlogImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileBlogImages.
     */
    distinct?: ProfileBlogImageScalarFieldEnum | ProfileBlogImageScalarFieldEnum[]
  }

  /**
   * ProfileBlogImage findMany
   */
  export type ProfileBlogImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    /**
     * Filter, which ProfileBlogImages to fetch.
     */
    where?: ProfileBlogImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileBlogImages to fetch.
     */
    orderBy?: ProfileBlogImageOrderByWithRelationInput | ProfileBlogImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileBlogImages.
     */
    cursor?: ProfileBlogImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileBlogImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileBlogImages.
     */
    skip?: number
    distinct?: ProfileBlogImageScalarFieldEnum | ProfileBlogImageScalarFieldEnum[]
  }

  /**
   * ProfileBlogImage create
   */
  export type ProfileBlogImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileBlogImage.
     */
    data: XOR<ProfileBlogImageCreateInput, ProfileBlogImageUncheckedCreateInput>
  }

  /**
   * ProfileBlogImage createMany
   */
  export type ProfileBlogImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileBlogImages.
     */
    data: ProfileBlogImageCreateManyInput | ProfileBlogImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileBlogImage createManyAndReturn
   */
  export type ProfileBlogImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileBlogImages.
     */
    data: ProfileBlogImageCreateManyInput | ProfileBlogImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileBlogImage update
   */
  export type ProfileBlogImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileBlogImage.
     */
    data: XOR<ProfileBlogImageUpdateInput, ProfileBlogImageUncheckedUpdateInput>
    /**
     * Choose, which ProfileBlogImage to update.
     */
    where: ProfileBlogImageWhereUniqueInput
  }

  /**
   * ProfileBlogImage updateMany
   */
  export type ProfileBlogImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileBlogImages.
     */
    data: XOR<ProfileBlogImageUpdateManyMutationInput, ProfileBlogImageUncheckedUpdateManyInput>
    /**
     * Filter which ProfileBlogImages to update
     */
    where?: ProfileBlogImageWhereInput
  }

  /**
   * ProfileBlogImage upsert
   */
  export type ProfileBlogImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileBlogImage to update in case it exists.
     */
    where: ProfileBlogImageWhereUniqueInput
    /**
     * In case the ProfileBlogImage found by the `where` argument doesn't exist, create a new ProfileBlogImage with this data.
     */
    create: XOR<ProfileBlogImageCreateInput, ProfileBlogImageUncheckedCreateInput>
    /**
     * In case the ProfileBlogImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileBlogImageUpdateInput, ProfileBlogImageUncheckedUpdateInput>
  }

  /**
   * ProfileBlogImage delete
   */
  export type ProfileBlogImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
    /**
     * Filter which ProfileBlogImage to delete.
     */
    where: ProfileBlogImageWhereUniqueInput
  }

  /**
   * ProfileBlogImage deleteMany
   */
  export type ProfileBlogImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileBlogImages to delete
     */
    where?: ProfileBlogImageWhereInput
  }

  /**
   * ProfileBlogImage without action
   */
  export type ProfileBlogImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileBlogImage
     */
    select?: ProfileBlogImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileBlogImageInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    content: string | null
    status: $Enums.PostStatus | null
    isArchived: boolean | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    content: string | null
    status: $Enums.PostStatus | null
    isArchived: boolean | null
    profileId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    content: number
    status: number
    isArchived: number
    profileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    content?: true
    status?: true
    isArchived?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    content?: true
    status?: true
    isArchived?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    content?: true
    status?: true
    isArchived?: true
    profileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    content: string | null
    status: $Enums.PostStatus
    isArchived: boolean
    profileId: string
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    status?: boolean
    isArchived?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    images?: boolean | Post$imagesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    shares?: boolean | Post$sharesArgs<ExtArgs>
    saves?: boolean | Post$savesArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    status?: boolean
    isArchived?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    content?: boolean
    status?: boolean
    isArchived?: boolean
    profileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    images?: boolean | Post$imagesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    shares?: boolean | Post$sharesArgs<ExtArgs>
    saves?: boolean | Post$savesArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      images: Prisma.$PostImagePayload<ExtArgs>[]
      comments: Prisma.$PostCommentPayload<ExtArgs>[]
      likes: Prisma.$PostLikePayload<ExtArgs>[]
      shares: Prisma.$PostSharePayload<ExtArgs>[]
      saves: Prisma.$PostSavePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string | null
      status: $Enums.PostStatus
      isArchived: boolean
      profileId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    images<T extends Post$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Post$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends Post$likesArgs<ExtArgs> = {}>(args?: Subset<T, Post$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany"> | Null>
    shares<T extends Post$sharesArgs<ExtArgs> = {}>(args?: Subset<T, Post$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "findMany"> | Null>
    saves<T extends Post$savesArgs<ExtArgs> = {}>(args?: Subset<T, Post$savesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly status: FieldRef<"Post", 'PostStatus'>
    readonly isArchived: FieldRef<"Post", 'Boolean'>
    readonly profileId: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }

  /**
   * Post.images
   */
  export type Post$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    where?: PostImageWhereInput
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    cursor?: PostImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    where?: PostCommentWhereInput
    orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
    cursor?: PostCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
  }

  /**
   * Post.likes
   */
  export type Post$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    cursor?: PostLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * Post.shares
   */
  export type Post$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    where?: PostShareWhereInput
    orderBy?: PostShareOrderByWithRelationInput | PostShareOrderByWithRelationInput[]
    cursor?: PostShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostShareScalarFieldEnum | PostShareScalarFieldEnum[]
  }

  /**
   * Post.saves
   */
  export type Post$savesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    where?: PostSaveWhereInput
    orderBy?: PostSaveOrderByWithRelationInput | PostSaveOrderByWithRelationInput[]
    cursor?: PostSaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostSaveScalarFieldEnum | PostSaveScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model PostImage
   */

  export type AggregatePostImage = {
    _count: PostImageCountAggregateOutputType | null
    _min: PostImageMinAggregateOutputType | null
    _max: PostImageMaxAggregateOutputType | null
  }

  export type PostImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    postId: string | null
  }

  export type PostImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    postId: string | null
  }

  export type PostImageCountAggregateOutputType = {
    id: number
    url: number
    postId: number
    _all: number
  }


  export type PostImageMinAggregateInputType = {
    id?: true
    url?: true
    postId?: true
  }

  export type PostImageMaxAggregateInputType = {
    id?: true
    url?: true
    postId?: true
  }

  export type PostImageCountAggregateInputType = {
    id?: true
    url?: true
    postId?: true
    _all?: true
  }

  export type PostImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostImage to aggregate.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostImages
    **/
    _count?: true | PostImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostImageMaxAggregateInputType
  }

  export type GetPostImageAggregateType<T extends PostImageAggregateArgs> = {
        [P in keyof T & keyof AggregatePostImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostImage[P]>
      : GetScalarType<T[P], AggregatePostImage[P]>
  }




  export type PostImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostImageWhereInput
    orderBy?: PostImageOrderByWithAggregationInput | PostImageOrderByWithAggregationInput[]
    by: PostImageScalarFieldEnum[] | PostImageScalarFieldEnum
    having?: PostImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostImageCountAggregateInputType | true
    _min?: PostImageMinAggregateInputType
    _max?: PostImageMaxAggregateInputType
  }

  export type PostImageGroupByOutputType = {
    id: string
    url: string
    postId: string
    _count: PostImageCountAggregateOutputType | null
    _min: PostImageMinAggregateOutputType | null
    _max: PostImageMaxAggregateOutputType | null
  }

  type GetPostImageGroupByPayload<T extends PostImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostImageGroupByOutputType[P]>
            : GetScalarType<T[P], PostImageGroupByOutputType[P]>
        }
      >
    >


  export type PostImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    postId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postImage"]>

  export type PostImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    postId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postImage"]>

  export type PostImageSelectScalar = {
    id?: boolean
    url?: boolean
    postId?: boolean
  }

  export type PostImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $PostImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostImage"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      postId: string
    }, ExtArgs["result"]["postImage"]>
    composites: {}
  }

  type PostImageGetPayload<S extends boolean | null | undefined | PostImageDefaultArgs> = $Result.GetResult<Prisma.$PostImagePayload, S>

  type PostImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostImageCountAggregateInputType | true
    }

  export interface PostImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostImage'], meta: { name: 'PostImage' } }
    /**
     * Find zero or one PostImage that matches the filter.
     * @param {PostImageFindUniqueArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostImageFindUniqueArgs>(args: SelectSubset<T, PostImageFindUniqueArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostImageFindUniqueOrThrowArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostImageFindUniqueOrThrowArgs>(args: SelectSubset<T, PostImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageFindFirstArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostImageFindFirstArgs>(args?: SelectSubset<T, PostImageFindFirstArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageFindFirstOrThrowArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostImageFindFirstOrThrowArgs>(args?: SelectSubset<T, PostImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostImages
     * const postImages = await prisma.postImage.findMany()
     * 
     * // Get first 10 PostImages
     * const postImages = await prisma.postImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postImageWithIdOnly = await prisma.postImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostImageFindManyArgs>(args?: SelectSubset<T, PostImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostImage.
     * @param {PostImageCreateArgs} args - Arguments to create a PostImage.
     * @example
     * // Create one PostImage
     * const PostImage = await prisma.postImage.create({
     *   data: {
     *     // ... data to create a PostImage
     *   }
     * })
     * 
     */
    create<T extends PostImageCreateArgs>(args: SelectSubset<T, PostImageCreateArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostImages.
     * @param {PostImageCreateManyArgs} args - Arguments to create many PostImages.
     * @example
     * // Create many PostImages
     * const postImage = await prisma.postImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostImageCreateManyArgs>(args?: SelectSubset<T, PostImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostImages and returns the data saved in the database.
     * @param {PostImageCreateManyAndReturnArgs} args - Arguments to create many PostImages.
     * @example
     * // Create many PostImages
     * const postImage = await prisma.postImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostImages and only return the `id`
     * const postImageWithIdOnly = await prisma.postImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostImageCreateManyAndReturnArgs>(args?: SelectSubset<T, PostImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostImage.
     * @param {PostImageDeleteArgs} args - Arguments to delete one PostImage.
     * @example
     * // Delete one PostImage
     * const PostImage = await prisma.postImage.delete({
     *   where: {
     *     // ... filter to delete one PostImage
     *   }
     * })
     * 
     */
    delete<T extends PostImageDeleteArgs>(args: SelectSubset<T, PostImageDeleteArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostImage.
     * @param {PostImageUpdateArgs} args - Arguments to update one PostImage.
     * @example
     * // Update one PostImage
     * const postImage = await prisma.postImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostImageUpdateArgs>(args: SelectSubset<T, PostImageUpdateArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostImages.
     * @param {PostImageDeleteManyArgs} args - Arguments to filter PostImages to delete.
     * @example
     * // Delete a few PostImages
     * const { count } = await prisma.postImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostImageDeleteManyArgs>(args?: SelectSubset<T, PostImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostImages
     * const postImage = await prisma.postImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostImageUpdateManyArgs>(args: SelectSubset<T, PostImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostImage.
     * @param {PostImageUpsertArgs} args - Arguments to update or create a PostImage.
     * @example
     * // Update or create a PostImage
     * const postImage = await prisma.postImage.upsert({
     *   create: {
     *     // ... data to create a PostImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostImage we want to update
     *   }
     * })
     */
    upsert<T extends PostImageUpsertArgs>(args: SelectSubset<T, PostImageUpsertArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageCountArgs} args - Arguments to filter PostImages to count.
     * @example
     * // Count the number of PostImages
     * const count = await prisma.postImage.count({
     *   where: {
     *     // ... the filter for the PostImages we want to count
     *   }
     * })
    **/
    count<T extends PostImageCountArgs>(
      args?: Subset<T, PostImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostImageAggregateArgs>(args: Subset<T, PostImageAggregateArgs>): Prisma.PrismaPromise<GetPostImageAggregateType<T>>

    /**
     * Group by PostImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostImageGroupByArgs['orderBy'] }
        : { orderBy?: PostImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostImage model
   */
  readonly fields: PostImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostImage model
   */ 
  interface PostImageFieldRefs {
    readonly id: FieldRef<"PostImage", 'String'>
    readonly url: FieldRef<"PostImage", 'String'>
    readonly postId: FieldRef<"PostImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostImage findUnique
   */
  export type PostImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage findUniqueOrThrow
   */
  export type PostImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage findFirst
   */
  export type PostImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostImages.
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostImages.
     */
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * PostImage findFirstOrThrow
   */
  export type PostImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostImages.
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostImages.
     */
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * PostImage findMany
   */
  export type PostImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImages to fetch.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostImages.
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * PostImage create
   */
  export type PostImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * The data needed to create a PostImage.
     */
    data: XOR<PostImageCreateInput, PostImageUncheckedCreateInput>
  }

  /**
   * PostImage createMany
   */
  export type PostImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostImages.
     */
    data: PostImageCreateManyInput | PostImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostImage createManyAndReturn
   */
  export type PostImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostImages.
     */
    data: PostImageCreateManyInput | PostImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostImage update
   */
  export type PostImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * The data needed to update a PostImage.
     */
    data: XOR<PostImageUpdateInput, PostImageUncheckedUpdateInput>
    /**
     * Choose, which PostImage to update.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage updateMany
   */
  export type PostImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostImages.
     */
    data: XOR<PostImageUpdateManyMutationInput, PostImageUncheckedUpdateManyInput>
    /**
     * Filter which PostImages to update
     */
    where?: PostImageWhereInput
  }

  /**
   * PostImage upsert
   */
  export type PostImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * The filter to search for the PostImage to update in case it exists.
     */
    where: PostImageWhereUniqueInput
    /**
     * In case the PostImage found by the `where` argument doesn't exist, create a new PostImage with this data.
     */
    create: XOR<PostImageCreateInput, PostImageUncheckedCreateInput>
    /**
     * In case the PostImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostImageUpdateInput, PostImageUncheckedUpdateInput>
  }

  /**
   * PostImage delete
   */
  export type PostImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter which PostImage to delete.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage deleteMany
   */
  export type PostImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostImages to delete
     */
    where?: PostImageWhereInput
  }

  /**
   * PostImage without action
   */
  export type PostImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
  }


  /**
   * Model PostLike
   */

  export type AggregatePostLike = {
    _count: PostLikeCountAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  export type PostLikeMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    postId: string | null
  }

  export type PostLikeMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    postId: string | null
  }

  export type PostLikeCountAggregateOutputType = {
    id: number
    profileId: number
    postId: number
    _all: number
  }


  export type PostLikeMinAggregateInputType = {
    id?: true
    profileId?: true
    postId?: true
  }

  export type PostLikeMaxAggregateInputType = {
    id?: true
    profileId?: true
    postId?: true
  }

  export type PostLikeCountAggregateInputType = {
    id?: true
    profileId?: true
    postId?: true
    _all?: true
  }

  export type PostLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostLike to aggregate.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostLikes
    **/
    _count?: true | PostLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostLikeMaxAggregateInputType
  }

  export type GetPostLikeAggregateType<T extends PostLikeAggregateArgs> = {
        [P in keyof T & keyof AggregatePostLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostLike[P]>
      : GetScalarType<T[P], AggregatePostLike[P]>
  }




  export type PostLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithAggregationInput | PostLikeOrderByWithAggregationInput[]
    by: PostLikeScalarFieldEnum[] | PostLikeScalarFieldEnum
    having?: PostLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostLikeCountAggregateInputType | true
    _min?: PostLikeMinAggregateInputType
    _max?: PostLikeMaxAggregateInputType
  }

  export type PostLikeGroupByOutputType = {
    id: string
    profileId: string
    postId: string
    _count: PostLikeCountAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  type GetPostLikeGroupByPayload<T extends PostLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
            : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
        }
      >
    >


  export type PostLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    postId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postLike"]>

  export type PostLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    postId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postLike"]>

  export type PostLikeSelectScalar = {
    id?: boolean
    profileId?: boolean
    postId?: boolean
  }

  export type PostLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $PostLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostLike"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      postId: string
    }, ExtArgs["result"]["postLike"]>
    composites: {}
  }

  type PostLikeGetPayload<S extends boolean | null | undefined | PostLikeDefaultArgs> = $Result.GetResult<Prisma.$PostLikePayload, S>

  type PostLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostLikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostLikeCountAggregateInputType | true
    }

  export interface PostLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostLike'], meta: { name: 'PostLike' } }
    /**
     * Find zero or one PostLike that matches the filter.
     * @param {PostLikeFindUniqueArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostLikeFindUniqueArgs>(args: SelectSubset<T, PostLikeFindUniqueArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostLike that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostLikeFindUniqueOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, PostLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostLikeFindFirstArgs>(args?: SelectSubset<T, PostLikeFindFirstArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, PostLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostLikes
     * const postLikes = await prisma.postLike.findMany()
     * 
     * // Get first 10 PostLikes
     * const postLikes = await prisma.postLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postLikeWithIdOnly = await prisma.postLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostLikeFindManyArgs>(args?: SelectSubset<T, PostLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostLike.
     * @param {PostLikeCreateArgs} args - Arguments to create a PostLike.
     * @example
     * // Create one PostLike
     * const PostLike = await prisma.postLike.create({
     *   data: {
     *     // ... data to create a PostLike
     *   }
     * })
     * 
     */
    create<T extends PostLikeCreateArgs>(args: SelectSubset<T, PostLikeCreateArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostLikes.
     * @param {PostLikeCreateManyArgs} args - Arguments to create many PostLikes.
     * @example
     * // Create many PostLikes
     * const postLike = await prisma.postLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostLikeCreateManyArgs>(args?: SelectSubset<T, PostLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostLikes and returns the data saved in the database.
     * @param {PostLikeCreateManyAndReturnArgs} args - Arguments to create many PostLikes.
     * @example
     * // Create many PostLikes
     * const postLike = await prisma.postLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostLikes and only return the `id`
     * const postLikeWithIdOnly = await prisma.postLike.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, PostLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostLike.
     * @param {PostLikeDeleteArgs} args - Arguments to delete one PostLike.
     * @example
     * // Delete one PostLike
     * const PostLike = await prisma.postLike.delete({
     *   where: {
     *     // ... filter to delete one PostLike
     *   }
     * })
     * 
     */
    delete<T extends PostLikeDeleteArgs>(args: SelectSubset<T, PostLikeDeleteArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostLike.
     * @param {PostLikeUpdateArgs} args - Arguments to update one PostLike.
     * @example
     * // Update one PostLike
     * const postLike = await prisma.postLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostLikeUpdateArgs>(args: SelectSubset<T, PostLikeUpdateArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostLikes.
     * @param {PostLikeDeleteManyArgs} args - Arguments to filter PostLikes to delete.
     * @example
     * // Delete a few PostLikes
     * const { count } = await prisma.postLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostLikeDeleteManyArgs>(args?: SelectSubset<T, PostLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostLikes
     * const postLike = await prisma.postLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostLikeUpdateManyArgs>(args: SelectSubset<T, PostLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostLike.
     * @param {PostLikeUpsertArgs} args - Arguments to update or create a PostLike.
     * @example
     * // Update or create a PostLike
     * const postLike = await prisma.postLike.upsert({
     *   create: {
     *     // ... data to create a PostLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostLike we want to update
     *   }
     * })
     */
    upsert<T extends PostLikeUpsertArgs>(args: SelectSubset<T, PostLikeUpsertArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeCountArgs} args - Arguments to filter PostLikes to count.
     * @example
     * // Count the number of PostLikes
     * const count = await prisma.postLike.count({
     *   where: {
     *     // ... the filter for the PostLikes we want to count
     *   }
     * })
    **/
    count<T extends PostLikeCountArgs>(
      args?: Subset<T, PostLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostLikeAggregateArgs>(args: Subset<T, PostLikeAggregateArgs>): Prisma.PrismaPromise<GetPostLikeAggregateType<T>>

    /**
     * Group by PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostLikeGroupByArgs['orderBy'] }
        : { orderBy?: PostLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostLike model
   */
  readonly fields: PostLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostLike model
   */ 
  interface PostLikeFieldRefs {
    readonly id: FieldRef<"PostLike", 'String'>
    readonly profileId: FieldRef<"PostLike", 'String'>
    readonly postId: FieldRef<"PostLike", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostLike findUnique
   */
  export type PostLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike findUniqueOrThrow
   */
  export type PostLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike findFirst
   */
  export type PostLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike findFirstOrThrow
   */
  export type PostLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike findMany
   */
  export type PostLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLikes to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike create
   */
  export type PostLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a PostLike.
     */
    data: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
  }

  /**
   * PostLike createMany
   */
  export type PostLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostLikes.
     */
    data: PostLikeCreateManyInput | PostLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostLike createManyAndReturn
   */
  export type PostLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostLikes.
     */
    data: PostLikeCreateManyInput | PostLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostLike update
   */
  export type PostLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a PostLike.
     */
    data: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
    /**
     * Choose, which PostLike to update.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike updateMany
   */
  export type PostLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostLikes.
     */
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyInput>
    /**
     * Filter which PostLikes to update
     */
    where?: PostLikeWhereInput
  }

  /**
   * PostLike upsert
   */
  export type PostLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the PostLike to update in case it exists.
     */
    where: PostLikeWhereUniqueInput
    /**
     * In case the PostLike found by the `where` argument doesn't exist, create a new PostLike with this data.
     */
    create: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
    /**
     * In case the PostLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
  }

  /**
   * PostLike delete
   */
  export type PostLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter which PostLike to delete.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike deleteMany
   */
  export type PostLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostLikes to delete
     */
    where?: PostLikeWhereInput
  }

  /**
   * PostLike without action
   */
  export type PostLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
  }


  /**
   * Model PostShare
   */

  export type AggregatePostShare = {
    _count: PostShareCountAggregateOutputType | null
    _min: PostShareMinAggregateOutputType | null
    _max: PostShareMaxAggregateOutputType | null
  }

  export type PostShareMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    postId: string | null
  }

  export type PostShareMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    postId: string | null
  }

  export type PostShareCountAggregateOutputType = {
    id: number
    profileId: number
    postId: number
    _all: number
  }


  export type PostShareMinAggregateInputType = {
    id?: true
    profileId?: true
    postId?: true
  }

  export type PostShareMaxAggregateInputType = {
    id?: true
    profileId?: true
    postId?: true
  }

  export type PostShareCountAggregateInputType = {
    id?: true
    profileId?: true
    postId?: true
    _all?: true
  }

  export type PostShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostShare to aggregate.
     */
    where?: PostShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostShares to fetch.
     */
    orderBy?: PostShareOrderByWithRelationInput | PostShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostShares
    **/
    _count?: true | PostShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostShareMaxAggregateInputType
  }

  export type GetPostShareAggregateType<T extends PostShareAggregateArgs> = {
        [P in keyof T & keyof AggregatePostShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostShare[P]>
      : GetScalarType<T[P], AggregatePostShare[P]>
  }




  export type PostShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostShareWhereInput
    orderBy?: PostShareOrderByWithAggregationInput | PostShareOrderByWithAggregationInput[]
    by: PostShareScalarFieldEnum[] | PostShareScalarFieldEnum
    having?: PostShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostShareCountAggregateInputType | true
    _min?: PostShareMinAggregateInputType
    _max?: PostShareMaxAggregateInputType
  }

  export type PostShareGroupByOutputType = {
    id: string
    profileId: string
    postId: string
    _count: PostShareCountAggregateOutputType | null
    _min: PostShareMinAggregateOutputType | null
    _max: PostShareMaxAggregateOutputType | null
  }

  type GetPostShareGroupByPayload<T extends PostShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostShareGroupByOutputType[P]>
            : GetScalarType<T[P], PostShareGroupByOutputType[P]>
        }
      >
    >


  export type PostShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    postId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postShare"]>

  export type PostShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    postId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postShare"]>

  export type PostShareSelectScalar = {
    id?: boolean
    profileId?: boolean
    postId?: boolean
  }

  export type PostShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $PostSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostShare"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      postId: string
    }, ExtArgs["result"]["postShare"]>
    composites: {}
  }

  type PostShareGetPayload<S extends boolean | null | undefined | PostShareDefaultArgs> = $Result.GetResult<Prisma.$PostSharePayload, S>

  type PostShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostShareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostShareCountAggregateInputType | true
    }

  export interface PostShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostShare'], meta: { name: 'PostShare' } }
    /**
     * Find zero or one PostShare that matches the filter.
     * @param {PostShareFindUniqueArgs} args - Arguments to find a PostShare
     * @example
     * // Get one PostShare
     * const postShare = await prisma.postShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostShareFindUniqueArgs>(args: SelectSubset<T, PostShareFindUniqueArgs<ExtArgs>>): Prisma__PostShareClient<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostShare that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostShareFindUniqueOrThrowArgs} args - Arguments to find a PostShare
     * @example
     * // Get one PostShare
     * const postShare = await prisma.postShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostShareFindUniqueOrThrowArgs>(args: SelectSubset<T, PostShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostShareClient<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostShareFindFirstArgs} args - Arguments to find a PostShare
     * @example
     * // Get one PostShare
     * const postShare = await prisma.postShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostShareFindFirstArgs>(args?: SelectSubset<T, PostShareFindFirstArgs<ExtArgs>>): Prisma__PostShareClient<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostShareFindFirstOrThrowArgs} args - Arguments to find a PostShare
     * @example
     * // Get one PostShare
     * const postShare = await prisma.postShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostShareFindFirstOrThrowArgs>(args?: SelectSubset<T, PostShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostShareClient<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostShares
     * const postShares = await prisma.postShare.findMany()
     * 
     * // Get first 10 PostShares
     * const postShares = await prisma.postShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postShareWithIdOnly = await prisma.postShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostShareFindManyArgs>(args?: SelectSubset<T, PostShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostShare.
     * @param {PostShareCreateArgs} args - Arguments to create a PostShare.
     * @example
     * // Create one PostShare
     * const PostShare = await prisma.postShare.create({
     *   data: {
     *     // ... data to create a PostShare
     *   }
     * })
     * 
     */
    create<T extends PostShareCreateArgs>(args: SelectSubset<T, PostShareCreateArgs<ExtArgs>>): Prisma__PostShareClient<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostShares.
     * @param {PostShareCreateManyArgs} args - Arguments to create many PostShares.
     * @example
     * // Create many PostShares
     * const postShare = await prisma.postShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostShareCreateManyArgs>(args?: SelectSubset<T, PostShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostShares and returns the data saved in the database.
     * @param {PostShareCreateManyAndReturnArgs} args - Arguments to create many PostShares.
     * @example
     * // Create many PostShares
     * const postShare = await prisma.postShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostShares and only return the `id`
     * const postShareWithIdOnly = await prisma.postShare.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostShareCreateManyAndReturnArgs>(args?: SelectSubset<T, PostShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostShare.
     * @param {PostShareDeleteArgs} args - Arguments to delete one PostShare.
     * @example
     * // Delete one PostShare
     * const PostShare = await prisma.postShare.delete({
     *   where: {
     *     // ... filter to delete one PostShare
     *   }
     * })
     * 
     */
    delete<T extends PostShareDeleteArgs>(args: SelectSubset<T, PostShareDeleteArgs<ExtArgs>>): Prisma__PostShareClient<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostShare.
     * @param {PostShareUpdateArgs} args - Arguments to update one PostShare.
     * @example
     * // Update one PostShare
     * const postShare = await prisma.postShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostShareUpdateArgs>(args: SelectSubset<T, PostShareUpdateArgs<ExtArgs>>): Prisma__PostShareClient<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostShares.
     * @param {PostShareDeleteManyArgs} args - Arguments to filter PostShares to delete.
     * @example
     * // Delete a few PostShares
     * const { count } = await prisma.postShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostShareDeleteManyArgs>(args?: SelectSubset<T, PostShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostShares
     * const postShare = await prisma.postShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostShareUpdateManyArgs>(args: SelectSubset<T, PostShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostShare.
     * @param {PostShareUpsertArgs} args - Arguments to update or create a PostShare.
     * @example
     * // Update or create a PostShare
     * const postShare = await prisma.postShare.upsert({
     *   create: {
     *     // ... data to create a PostShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostShare we want to update
     *   }
     * })
     */
    upsert<T extends PostShareUpsertArgs>(args: SelectSubset<T, PostShareUpsertArgs<ExtArgs>>): Prisma__PostShareClient<$Result.GetResult<Prisma.$PostSharePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostShareCountArgs} args - Arguments to filter PostShares to count.
     * @example
     * // Count the number of PostShares
     * const count = await prisma.postShare.count({
     *   where: {
     *     // ... the filter for the PostShares we want to count
     *   }
     * })
    **/
    count<T extends PostShareCountArgs>(
      args?: Subset<T, PostShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostShareAggregateArgs>(args: Subset<T, PostShareAggregateArgs>): Prisma.PrismaPromise<GetPostShareAggregateType<T>>

    /**
     * Group by PostShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostShareGroupByArgs['orderBy'] }
        : { orderBy?: PostShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostShare model
   */
  readonly fields: PostShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostShare model
   */ 
  interface PostShareFieldRefs {
    readonly id: FieldRef<"PostShare", 'String'>
    readonly profileId: FieldRef<"PostShare", 'String'>
    readonly postId: FieldRef<"PostShare", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostShare findUnique
   */
  export type PostShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    /**
     * Filter, which PostShare to fetch.
     */
    where: PostShareWhereUniqueInput
  }

  /**
   * PostShare findUniqueOrThrow
   */
  export type PostShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    /**
     * Filter, which PostShare to fetch.
     */
    where: PostShareWhereUniqueInput
  }

  /**
   * PostShare findFirst
   */
  export type PostShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    /**
     * Filter, which PostShare to fetch.
     */
    where?: PostShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostShares to fetch.
     */
    orderBy?: PostShareOrderByWithRelationInput | PostShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostShares.
     */
    cursor?: PostShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostShares.
     */
    distinct?: PostShareScalarFieldEnum | PostShareScalarFieldEnum[]
  }

  /**
   * PostShare findFirstOrThrow
   */
  export type PostShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    /**
     * Filter, which PostShare to fetch.
     */
    where?: PostShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostShares to fetch.
     */
    orderBy?: PostShareOrderByWithRelationInput | PostShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostShares.
     */
    cursor?: PostShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostShares.
     */
    distinct?: PostShareScalarFieldEnum | PostShareScalarFieldEnum[]
  }

  /**
   * PostShare findMany
   */
  export type PostShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    /**
     * Filter, which PostShares to fetch.
     */
    where?: PostShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostShares to fetch.
     */
    orderBy?: PostShareOrderByWithRelationInput | PostShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostShares.
     */
    cursor?: PostShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostShares.
     */
    skip?: number
    distinct?: PostShareScalarFieldEnum | PostShareScalarFieldEnum[]
  }

  /**
   * PostShare create
   */
  export type PostShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    /**
     * The data needed to create a PostShare.
     */
    data: XOR<PostShareCreateInput, PostShareUncheckedCreateInput>
  }

  /**
   * PostShare createMany
   */
  export type PostShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostShares.
     */
    data: PostShareCreateManyInput | PostShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostShare createManyAndReturn
   */
  export type PostShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostShares.
     */
    data: PostShareCreateManyInput | PostShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostShare update
   */
  export type PostShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    /**
     * The data needed to update a PostShare.
     */
    data: XOR<PostShareUpdateInput, PostShareUncheckedUpdateInput>
    /**
     * Choose, which PostShare to update.
     */
    where: PostShareWhereUniqueInput
  }

  /**
   * PostShare updateMany
   */
  export type PostShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostShares.
     */
    data: XOR<PostShareUpdateManyMutationInput, PostShareUncheckedUpdateManyInput>
    /**
     * Filter which PostShares to update
     */
    where?: PostShareWhereInput
  }

  /**
   * PostShare upsert
   */
  export type PostShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    /**
     * The filter to search for the PostShare to update in case it exists.
     */
    where: PostShareWhereUniqueInput
    /**
     * In case the PostShare found by the `where` argument doesn't exist, create a new PostShare with this data.
     */
    create: XOR<PostShareCreateInput, PostShareUncheckedCreateInput>
    /**
     * In case the PostShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostShareUpdateInput, PostShareUncheckedUpdateInput>
  }

  /**
   * PostShare delete
   */
  export type PostShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
    /**
     * Filter which PostShare to delete.
     */
    where: PostShareWhereUniqueInput
  }

  /**
   * PostShare deleteMany
   */
  export type PostShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostShares to delete
     */
    where?: PostShareWhereInput
  }

  /**
   * PostShare without action
   */
  export type PostShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostShare
     */
    select?: PostShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostShareInclude<ExtArgs> | null
  }


  /**
   * Model PostSave
   */

  export type AggregatePostSave = {
    _count: PostSaveCountAggregateOutputType | null
    _min: PostSaveMinAggregateOutputType | null
    _max: PostSaveMaxAggregateOutputType | null
  }

  export type PostSaveMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    postId: string | null
  }

  export type PostSaveMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    postId: string | null
  }

  export type PostSaveCountAggregateOutputType = {
    id: number
    profileId: number
    postId: number
    _all: number
  }


  export type PostSaveMinAggregateInputType = {
    id?: true
    profileId?: true
    postId?: true
  }

  export type PostSaveMaxAggregateInputType = {
    id?: true
    profileId?: true
    postId?: true
  }

  export type PostSaveCountAggregateInputType = {
    id?: true
    profileId?: true
    postId?: true
    _all?: true
  }

  export type PostSaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostSave to aggregate.
     */
    where?: PostSaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostSaves to fetch.
     */
    orderBy?: PostSaveOrderByWithRelationInput | PostSaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostSaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostSaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostSaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostSaves
    **/
    _count?: true | PostSaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostSaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostSaveMaxAggregateInputType
  }

  export type GetPostSaveAggregateType<T extends PostSaveAggregateArgs> = {
        [P in keyof T & keyof AggregatePostSave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostSave[P]>
      : GetScalarType<T[P], AggregatePostSave[P]>
  }




  export type PostSaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostSaveWhereInput
    orderBy?: PostSaveOrderByWithAggregationInput | PostSaveOrderByWithAggregationInput[]
    by: PostSaveScalarFieldEnum[] | PostSaveScalarFieldEnum
    having?: PostSaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostSaveCountAggregateInputType | true
    _min?: PostSaveMinAggregateInputType
    _max?: PostSaveMaxAggregateInputType
  }

  export type PostSaveGroupByOutputType = {
    id: string
    profileId: string
    postId: string
    _count: PostSaveCountAggregateOutputType | null
    _min: PostSaveMinAggregateOutputType | null
    _max: PostSaveMaxAggregateOutputType | null
  }

  type GetPostSaveGroupByPayload<T extends PostSaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostSaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostSaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostSaveGroupByOutputType[P]>
            : GetScalarType<T[P], PostSaveGroupByOutputType[P]>
        }
      >
    >


  export type PostSaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    postId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postSave"]>

  export type PostSaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    postId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postSave"]>

  export type PostSaveSelectScalar = {
    id?: boolean
    profileId?: boolean
    postId?: boolean
  }

  export type PostSaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostSaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $PostSavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostSave"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      postId: string
    }, ExtArgs["result"]["postSave"]>
    composites: {}
  }

  type PostSaveGetPayload<S extends boolean | null | undefined | PostSaveDefaultArgs> = $Result.GetResult<Prisma.$PostSavePayload, S>

  type PostSaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostSaveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostSaveCountAggregateInputType | true
    }

  export interface PostSaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostSave'], meta: { name: 'PostSave' } }
    /**
     * Find zero or one PostSave that matches the filter.
     * @param {PostSaveFindUniqueArgs} args - Arguments to find a PostSave
     * @example
     * // Get one PostSave
     * const postSave = await prisma.postSave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostSaveFindUniqueArgs>(args: SelectSubset<T, PostSaveFindUniqueArgs<ExtArgs>>): Prisma__PostSaveClient<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostSave that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostSaveFindUniqueOrThrowArgs} args - Arguments to find a PostSave
     * @example
     * // Get one PostSave
     * const postSave = await prisma.postSave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostSaveFindUniqueOrThrowArgs>(args: SelectSubset<T, PostSaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostSaveClient<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostSave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSaveFindFirstArgs} args - Arguments to find a PostSave
     * @example
     * // Get one PostSave
     * const postSave = await prisma.postSave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostSaveFindFirstArgs>(args?: SelectSubset<T, PostSaveFindFirstArgs<ExtArgs>>): Prisma__PostSaveClient<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostSave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSaveFindFirstOrThrowArgs} args - Arguments to find a PostSave
     * @example
     * // Get one PostSave
     * const postSave = await prisma.postSave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostSaveFindFirstOrThrowArgs>(args?: SelectSubset<T, PostSaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostSaveClient<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostSaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostSaves
     * const postSaves = await prisma.postSave.findMany()
     * 
     * // Get first 10 PostSaves
     * const postSaves = await prisma.postSave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postSaveWithIdOnly = await prisma.postSave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostSaveFindManyArgs>(args?: SelectSubset<T, PostSaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostSave.
     * @param {PostSaveCreateArgs} args - Arguments to create a PostSave.
     * @example
     * // Create one PostSave
     * const PostSave = await prisma.postSave.create({
     *   data: {
     *     // ... data to create a PostSave
     *   }
     * })
     * 
     */
    create<T extends PostSaveCreateArgs>(args: SelectSubset<T, PostSaveCreateArgs<ExtArgs>>): Prisma__PostSaveClient<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostSaves.
     * @param {PostSaveCreateManyArgs} args - Arguments to create many PostSaves.
     * @example
     * // Create many PostSaves
     * const postSave = await prisma.postSave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostSaveCreateManyArgs>(args?: SelectSubset<T, PostSaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostSaves and returns the data saved in the database.
     * @param {PostSaveCreateManyAndReturnArgs} args - Arguments to create many PostSaves.
     * @example
     * // Create many PostSaves
     * const postSave = await prisma.postSave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostSaves and only return the `id`
     * const postSaveWithIdOnly = await prisma.postSave.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostSaveCreateManyAndReturnArgs>(args?: SelectSubset<T, PostSaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostSave.
     * @param {PostSaveDeleteArgs} args - Arguments to delete one PostSave.
     * @example
     * // Delete one PostSave
     * const PostSave = await prisma.postSave.delete({
     *   where: {
     *     // ... filter to delete one PostSave
     *   }
     * })
     * 
     */
    delete<T extends PostSaveDeleteArgs>(args: SelectSubset<T, PostSaveDeleteArgs<ExtArgs>>): Prisma__PostSaveClient<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostSave.
     * @param {PostSaveUpdateArgs} args - Arguments to update one PostSave.
     * @example
     * // Update one PostSave
     * const postSave = await prisma.postSave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostSaveUpdateArgs>(args: SelectSubset<T, PostSaveUpdateArgs<ExtArgs>>): Prisma__PostSaveClient<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostSaves.
     * @param {PostSaveDeleteManyArgs} args - Arguments to filter PostSaves to delete.
     * @example
     * // Delete a few PostSaves
     * const { count } = await prisma.postSave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostSaveDeleteManyArgs>(args?: SelectSubset<T, PostSaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostSaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostSaves
     * const postSave = await prisma.postSave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostSaveUpdateManyArgs>(args: SelectSubset<T, PostSaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostSave.
     * @param {PostSaveUpsertArgs} args - Arguments to update or create a PostSave.
     * @example
     * // Update or create a PostSave
     * const postSave = await prisma.postSave.upsert({
     *   create: {
     *     // ... data to create a PostSave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostSave we want to update
     *   }
     * })
     */
    upsert<T extends PostSaveUpsertArgs>(args: SelectSubset<T, PostSaveUpsertArgs<ExtArgs>>): Prisma__PostSaveClient<$Result.GetResult<Prisma.$PostSavePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostSaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSaveCountArgs} args - Arguments to filter PostSaves to count.
     * @example
     * // Count the number of PostSaves
     * const count = await prisma.postSave.count({
     *   where: {
     *     // ... the filter for the PostSaves we want to count
     *   }
     * })
    **/
    count<T extends PostSaveCountArgs>(
      args?: Subset<T, PostSaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostSaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostSave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostSaveAggregateArgs>(args: Subset<T, PostSaveAggregateArgs>): Prisma.PrismaPromise<GetPostSaveAggregateType<T>>

    /**
     * Group by PostSave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostSaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostSaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostSaveGroupByArgs['orderBy'] }
        : { orderBy?: PostSaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostSaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostSaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostSave model
   */
  readonly fields: PostSaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostSave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostSaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostSave model
   */ 
  interface PostSaveFieldRefs {
    readonly id: FieldRef<"PostSave", 'String'>
    readonly profileId: FieldRef<"PostSave", 'String'>
    readonly postId: FieldRef<"PostSave", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostSave findUnique
   */
  export type PostSaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    /**
     * Filter, which PostSave to fetch.
     */
    where: PostSaveWhereUniqueInput
  }

  /**
   * PostSave findUniqueOrThrow
   */
  export type PostSaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    /**
     * Filter, which PostSave to fetch.
     */
    where: PostSaveWhereUniqueInput
  }

  /**
   * PostSave findFirst
   */
  export type PostSaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    /**
     * Filter, which PostSave to fetch.
     */
    where?: PostSaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostSaves to fetch.
     */
    orderBy?: PostSaveOrderByWithRelationInput | PostSaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostSaves.
     */
    cursor?: PostSaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostSaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostSaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostSaves.
     */
    distinct?: PostSaveScalarFieldEnum | PostSaveScalarFieldEnum[]
  }

  /**
   * PostSave findFirstOrThrow
   */
  export type PostSaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    /**
     * Filter, which PostSave to fetch.
     */
    where?: PostSaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostSaves to fetch.
     */
    orderBy?: PostSaveOrderByWithRelationInput | PostSaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostSaves.
     */
    cursor?: PostSaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostSaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostSaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostSaves.
     */
    distinct?: PostSaveScalarFieldEnum | PostSaveScalarFieldEnum[]
  }

  /**
   * PostSave findMany
   */
  export type PostSaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    /**
     * Filter, which PostSaves to fetch.
     */
    where?: PostSaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostSaves to fetch.
     */
    orderBy?: PostSaveOrderByWithRelationInput | PostSaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostSaves.
     */
    cursor?: PostSaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostSaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostSaves.
     */
    skip?: number
    distinct?: PostSaveScalarFieldEnum | PostSaveScalarFieldEnum[]
  }

  /**
   * PostSave create
   */
  export type PostSaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    /**
     * The data needed to create a PostSave.
     */
    data: XOR<PostSaveCreateInput, PostSaveUncheckedCreateInput>
  }

  /**
   * PostSave createMany
   */
  export type PostSaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostSaves.
     */
    data: PostSaveCreateManyInput | PostSaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostSave createManyAndReturn
   */
  export type PostSaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostSaves.
     */
    data: PostSaveCreateManyInput | PostSaveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostSave update
   */
  export type PostSaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    /**
     * The data needed to update a PostSave.
     */
    data: XOR<PostSaveUpdateInput, PostSaveUncheckedUpdateInput>
    /**
     * Choose, which PostSave to update.
     */
    where: PostSaveWhereUniqueInput
  }

  /**
   * PostSave updateMany
   */
  export type PostSaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostSaves.
     */
    data: XOR<PostSaveUpdateManyMutationInput, PostSaveUncheckedUpdateManyInput>
    /**
     * Filter which PostSaves to update
     */
    where?: PostSaveWhereInput
  }

  /**
   * PostSave upsert
   */
  export type PostSaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    /**
     * The filter to search for the PostSave to update in case it exists.
     */
    where: PostSaveWhereUniqueInput
    /**
     * In case the PostSave found by the `where` argument doesn't exist, create a new PostSave with this data.
     */
    create: XOR<PostSaveCreateInput, PostSaveUncheckedCreateInput>
    /**
     * In case the PostSave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostSaveUpdateInput, PostSaveUncheckedUpdateInput>
  }

  /**
   * PostSave delete
   */
  export type PostSaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
    /**
     * Filter which PostSave to delete.
     */
    where: PostSaveWhereUniqueInput
  }

  /**
   * PostSave deleteMany
   */
  export type PostSaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostSaves to delete
     */
    where?: PostSaveWhereInput
  }

  /**
   * PostSave without action
   */
  export type PostSaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostSave
     */
    select?: PostSaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostSaveInclude<ExtArgs> | null
  }


  /**
   * Model PostComment
   */

  export type AggregatePostComment = {
    _count: PostCommentCountAggregateOutputType | null
    _min: PostCommentMinAggregateOutputType | null
    _max: PostCommentMaxAggregateOutputType | null
  }

  export type PostCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    image: string | null
    isArchived: boolean | null
    profileId: string | null
    postId: string | null
    parentCommentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    image: string | null
    isArchived: boolean | null
    profileId: string | null
    postId: string | null
    parentCommentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCommentCountAggregateOutputType = {
    id: number
    content: number
    image: number
    isArchived: number
    profileId: number
    postId: number
    parentCommentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostCommentMinAggregateInputType = {
    id?: true
    content?: true
    image?: true
    isArchived?: true
    profileId?: true
    postId?: true
    parentCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCommentMaxAggregateInputType = {
    id?: true
    content?: true
    image?: true
    isArchived?: true
    profileId?: true
    postId?: true
    parentCommentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCommentCountAggregateInputType = {
    id?: true
    content?: true
    image?: true
    isArchived?: true
    profileId?: true
    postId?: true
    parentCommentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostComment to aggregate.
     */
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     */
    orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostComments
    **/
    _count?: true | PostCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostCommentMaxAggregateInputType
  }

  export type GetPostCommentAggregateType<T extends PostCommentAggregateArgs> = {
        [P in keyof T & keyof AggregatePostComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostComment[P]>
      : GetScalarType<T[P], AggregatePostComment[P]>
  }




  export type PostCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCommentWhereInput
    orderBy?: PostCommentOrderByWithAggregationInput | PostCommentOrderByWithAggregationInput[]
    by: PostCommentScalarFieldEnum[] | PostCommentScalarFieldEnum
    having?: PostCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCommentCountAggregateInputType | true
    _min?: PostCommentMinAggregateInputType
    _max?: PostCommentMaxAggregateInputType
  }

  export type PostCommentGroupByOutputType = {
    id: string
    content: string | null
    image: string | null
    isArchived: boolean
    profileId: string
    postId: string
    parentCommentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PostCommentCountAggregateOutputType | null
    _min: PostCommentMinAggregateOutputType | null
    _max: PostCommentMaxAggregateOutputType | null
  }

  type GetPostCommentGroupByPayload<T extends PostCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostCommentGroupByOutputType[P]>
            : GetScalarType<T[P], PostCommentGroupByOutputType[P]>
        }
      >
    >


  export type PostCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    image?: boolean
    isArchived?: boolean
    profileId?: boolean
    postId?: boolean
    parentCommentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    parentComment?: boolean | PostComment$parentCommentArgs<ExtArgs>
    children?: boolean | PostComment$childrenArgs<ExtArgs>
    likes?: boolean | PostComment$likesArgs<ExtArgs>
    _count?: boolean | PostCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postComment"]>

  export type PostCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    image?: boolean
    isArchived?: boolean
    profileId?: boolean
    postId?: boolean
    parentCommentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    parentComment?: boolean | PostComment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["postComment"]>

  export type PostCommentSelectScalar = {
    id?: boolean
    content?: boolean
    image?: boolean
    isArchived?: boolean
    profileId?: boolean
    postId?: boolean
    parentCommentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    parentComment?: boolean | PostComment$parentCommentArgs<ExtArgs>
    children?: boolean | PostComment$childrenArgs<ExtArgs>
    likes?: boolean | PostComment$likesArgs<ExtArgs>
    _count?: boolean | PostCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    parentComment?: boolean | PostComment$parentCommentArgs<ExtArgs>
  }

  export type $PostCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostComment"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs>
      parentComment: Prisma.$PostCommentPayload<ExtArgs> | null
      children: Prisma.$PostCommentPayload<ExtArgs>[]
      likes: Prisma.$PostCommentLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string | null
      image: string | null
      isArchived: boolean
      profileId: string
      postId: string
      parentCommentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["postComment"]>
    composites: {}
  }

  type PostCommentGetPayload<S extends boolean | null | undefined | PostCommentDefaultArgs> = $Result.GetResult<Prisma.$PostCommentPayload, S>

  type PostCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCommentCountAggregateInputType | true
    }

  export interface PostCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostComment'], meta: { name: 'PostComment' } }
    /**
     * Find zero or one PostComment that matches the filter.
     * @param {PostCommentFindUniqueArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostCommentFindUniqueArgs>(args: SelectSubset<T, PostCommentFindUniqueArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostCommentFindUniqueOrThrowArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, PostCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentFindFirstArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostCommentFindFirstArgs>(args?: SelectSubset<T, PostCommentFindFirstArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentFindFirstOrThrowArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, PostCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostComments
     * const postComments = await prisma.postComment.findMany()
     * 
     * // Get first 10 PostComments
     * const postComments = await prisma.postComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postCommentWithIdOnly = await prisma.postComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostCommentFindManyArgs>(args?: SelectSubset<T, PostCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostComment.
     * @param {PostCommentCreateArgs} args - Arguments to create a PostComment.
     * @example
     * // Create one PostComment
     * const PostComment = await prisma.postComment.create({
     *   data: {
     *     // ... data to create a PostComment
     *   }
     * })
     * 
     */
    create<T extends PostCommentCreateArgs>(args: SelectSubset<T, PostCommentCreateArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostComments.
     * @param {PostCommentCreateManyArgs} args - Arguments to create many PostComments.
     * @example
     * // Create many PostComments
     * const postComment = await prisma.postComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCommentCreateManyArgs>(args?: SelectSubset<T, PostCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostComments and returns the data saved in the database.
     * @param {PostCommentCreateManyAndReturnArgs} args - Arguments to create many PostComments.
     * @example
     * // Create many PostComments
     * const postComment = await prisma.postComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostComments and only return the `id`
     * const postCommentWithIdOnly = await prisma.postComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostComment.
     * @param {PostCommentDeleteArgs} args - Arguments to delete one PostComment.
     * @example
     * // Delete one PostComment
     * const PostComment = await prisma.postComment.delete({
     *   where: {
     *     // ... filter to delete one PostComment
     *   }
     * })
     * 
     */
    delete<T extends PostCommentDeleteArgs>(args: SelectSubset<T, PostCommentDeleteArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostComment.
     * @param {PostCommentUpdateArgs} args - Arguments to update one PostComment.
     * @example
     * // Update one PostComment
     * const postComment = await prisma.postComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostCommentUpdateArgs>(args: SelectSubset<T, PostCommentUpdateArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostComments.
     * @param {PostCommentDeleteManyArgs} args - Arguments to filter PostComments to delete.
     * @example
     * // Delete a few PostComments
     * const { count } = await prisma.postComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostCommentDeleteManyArgs>(args?: SelectSubset<T, PostCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostComments
     * const postComment = await prisma.postComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostCommentUpdateManyArgs>(args: SelectSubset<T, PostCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostComment.
     * @param {PostCommentUpsertArgs} args - Arguments to update or create a PostComment.
     * @example
     * // Update or create a PostComment
     * const postComment = await prisma.postComment.upsert({
     *   create: {
     *     // ... data to create a PostComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostComment we want to update
     *   }
     * })
     */
    upsert<T extends PostCommentUpsertArgs>(args: SelectSubset<T, PostCommentUpsertArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentCountArgs} args - Arguments to filter PostComments to count.
     * @example
     * // Count the number of PostComments
     * const count = await prisma.postComment.count({
     *   where: {
     *     // ... the filter for the PostComments we want to count
     *   }
     * })
    **/
    count<T extends PostCommentCountArgs>(
      args?: Subset<T, PostCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostCommentAggregateArgs>(args: Subset<T, PostCommentAggregateArgs>): Prisma.PrismaPromise<GetPostCommentAggregateType<T>>

    /**
     * Group by PostComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostCommentGroupByArgs['orderBy'] }
        : { orderBy?: PostCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostComment model
   */
  readonly fields: PostCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parentComment<T extends PostComment$parentCommentArgs<ExtArgs> = {}>(args?: Subset<T, PostComment$parentCommentArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends PostComment$childrenArgs<ExtArgs> = {}>(args?: Subset<T, PostComment$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends PostComment$likesArgs<ExtArgs> = {}>(args?: Subset<T, PostComment$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostComment model
   */ 
  interface PostCommentFieldRefs {
    readonly id: FieldRef<"PostComment", 'String'>
    readonly content: FieldRef<"PostComment", 'String'>
    readonly image: FieldRef<"PostComment", 'String'>
    readonly isArchived: FieldRef<"PostComment", 'Boolean'>
    readonly profileId: FieldRef<"PostComment", 'String'>
    readonly postId: FieldRef<"PostComment", 'String'>
    readonly parentCommentId: FieldRef<"PostComment", 'String'>
    readonly createdAt: FieldRef<"PostComment", 'DateTime'>
    readonly updatedAt: FieldRef<"PostComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostComment findUnique
   */
  export type PostCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComment to fetch.
     */
    where: PostCommentWhereUniqueInput
  }

  /**
   * PostComment findUniqueOrThrow
   */
  export type PostCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComment to fetch.
     */
    where: PostCommentWhereUniqueInput
  }

  /**
   * PostComment findFirst
   */
  export type PostCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComment to fetch.
     */
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     */
    orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostComments.
     */
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostComments.
     */
    distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
  }

  /**
   * PostComment findFirstOrThrow
   */
  export type PostCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComment to fetch.
     */
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     */
    orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostComments.
     */
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostComments.
     */
    distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
  }

  /**
   * PostComment findMany
   */
  export type PostCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComments to fetch.
     */
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     */
    orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostComments.
     */
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     */
    skip?: number
    distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
  }

  /**
   * PostComment create
   */
  export type PostCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a PostComment.
     */
    data: XOR<PostCommentCreateInput, PostCommentUncheckedCreateInput>
  }

  /**
   * PostComment createMany
   */
  export type PostCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostComments.
     */
    data: PostCommentCreateManyInput | PostCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostComment createManyAndReturn
   */
  export type PostCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostComments.
     */
    data: PostCommentCreateManyInput | PostCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostComment update
   */
  export type PostCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a PostComment.
     */
    data: XOR<PostCommentUpdateInput, PostCommentUncheckedUpdateInput>
    /**
     * Choose, which PostComment to update.
     */
    where: PostCommentWhereUniqueInput
  }

  /**
   * PostComment updateMany
   */
  export type PostCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostComments.
     */
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyInput>
    /**
     * Filter which PostComments to update
     */
    where?: PostCommentWhereInput
  }

  /**
   * PostComment upsert
   */
  export type PostCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the PostComment to update in case it exists.
     */
    where: PostCommentWhereUniqueInput
    /**
     * In case the PostComment found by the `where` argument doesn't exist, create a new PostComment with this data.
     */
    create: XOR<PostCommentCreateInput, PostCommentUncheckedCreateInput>
    /**
     * In case the PostComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostCommentUpdateInput, PostCommentUncheckedUpdateInput>
  }

  /**
   * PostComment delete
   */
  export type PostCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter which PostComment to delete.
     */
    where: PostCommentWhereUniqueInput
  }

  /**
   * PostComment deleteMany
   */
  export type PostCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostComments to delete
     */
    where?: PostCommentWhereInput
  }

  /**
   * PostComment.parentComment
   */
  export type PostComment$parentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    where?: PostCommentWhereInput
  }

  /**
   * PostComment.children
   */
  export type PostComment$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
    where?: PostCommentWhereInput
    orderBy?: PostCommentOrderByWithRelationInput | PostCommentOrderByWithRelationInput[]
    cursor?: PostCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostCommentScalarFieldEnum | PostCommentScalarFieldEnum[]
  }

  /**
   * PostComment.likes
   */
  export type PostComment$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    where?: PostCommentLikeWhereInput
    orderBy?: PostCommentLikeOrderByWithRelationInput | PostCommentLikeOrderByWithRelationInput[]
    cursor?: PostCommentLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostCommentLikeScalarFieldEnum | PostCommentLikeScalarFieldEnum[]
  }

  /**
   * PostComment without action
   */
  export type PostCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentInclude<ExtArgs> | null
  }


  /**
   * Model PostCommentLike
   */

  export type AggregatePostCommentLike = {
    _count: PostCommentLikeCountAggregateOutputType | null
    _min: PostCommentLikeMinAggregateOutputType | null
    _max: PostCommentLikeMaxAggregateOutputType | null
  }

  export type PostCommentLikeMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    postCommentId: string | null
  }

  export type PostCommentLikeMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    postCommentId: string | null
  }

  export type PostCommentLikeCountAggregateOutputType = {
    id: number
    profileId: number
    postCommentId: number
    _all: number
  }


  export type PostCommentLikeMinAggregateInputType = {
    id?: true
    profileId?: true
    postCommentId?: true
  }

  export type PostCommentLikeMaxAggregateInputType = {
    id?: true
    profileId?: true
    postCommentId?: true
  }

  export type PostCommentLikeCountAggregateInputType = {
    id?: true
    profileId?: true
    postCommentId?: true
    _all?: true
  }

  export type PostCommentLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostCommentLike to aggregate.
     */
    where?: PostCommentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCommentLikes to fetch.
     */
    orderBy?: PostCommentLikeOrderByWithRelationInput | PostCommentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostCommentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCommentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostCommentLikes
    **/
    _count?: true | PostCommentLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostCommentLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostCommentLikeMaxAggregateInputType
  }

  export type GetPostCommentLikeAggregateType<T extends PostCommentLikeAggregateArgs> = {
        [P in keyof T & keyof AggregatePostCommentLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostCommentLike[P]>
      : GetScalarType<T[P], AggregatePostCommentLike[P]>
  }




  export type PostCommentLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostCommentLikeWhereInput
    orderBy?: PostCommentLikeOrderByWithAggregationInput | PostCommentLikeOrderByWithAggregationInput[]
    by: PostCommentLikeScalarFieldEnum[] | PostCommentLikeScalarFieldEnum
    having?: PostCommentLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCommentLikeCountAggregateInputType | true
    _min?: PostCommentLikeMinAggregateInputType
    _max?: PostCommentLikeMaxAggregateInputType
  }

  export type PostCommentLikeGroupByOutputType = {
    id: string
    profileId: string
    postCommentId: string
    _count: PostCommentLikeCountAggregateOutputType | null
    _min: PostCommentLikeMinAggregateOutputType | null
    _max: PostCommentLikeMaxAggregateOutputType | null
  }

  type GetPostCommentLikeGroupByPayload<T extends PostCommentLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostCommentLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostCommentLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostCommentLikeGroupByOutputType[P]>
            : GetScalarType<T[P], PostCommentLikeGroupByOutputType[P]>
        }
      >
    >


  export type PostCommentLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    postCommentId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    postComment?: boolean | PostCommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postCommentLike"]>

  export type PostCommentLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    postCommentId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    postComment?: boolean | PostCommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postCommentLike"]>

  export type PostCommentLikeSelectScalar = {
    id?: boolean
    profileId?: boolean
    postCommentId?: boolean
  }

  export type PostCommentLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    postComment?: boolean | PostCommentDefaultArgs<ExtArgs>
  }
  export type PostCommentLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    postComment?: boolean | PostCommentDefaultArgs<ExtArgs>
  }

  export type $PostCommentLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostCommentLike"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      postComment: Prisma.$PostCommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      postCommentId: string
    }, ExtArgs["result"]["postCommentLike"]>
    composites: {}
  }

  type PostCommentLikeGetPayload<S extends boolean | null | undefined | PostCommentLikeDefaultArgs> = $Result.GetResult<Prisma.$PostCommentLikePayload, S>

  type PostCommentLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostCommentLikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCommentLikeCountAggregateInputType | true
    }

  export interface PostCommentLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostCommentLike'], meta: { name: 'PostCommentLike' } }
    /**
     * Find zero or one PostCommentLike that matches the filter.
     * @param {PostCommentLikeFindUniqueArgs} args - Arguments to find a PostCommentLike
     * @example
     * // Get one PostCommentLike
     * const postCommentLike = await prisma.postCommentLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostCommentLikeFindUniqueArgs>(args: SelectSubset<T, PostCommentLikeFindUniqueArgs<ExtArgs>>): Prisma__PostCommentLikeClient<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostCommentLike that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostCommentLikeFindUniqueOrThrowArgs} args - Arguments to find a PostCommentLike
     * @example
     * // Get one PostCommentLike
     * const postCommentLike = await prisma.postCommentLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostCommentLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, PostCommentLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostCommentLikeClient<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostCommentLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentLikeFindFirstArgs} args - Arguments to find a PostCommentLike
     * @example
     * // Get one PostCommentLike
     * const postCommentLike = await prisma.postCommentLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostCommentLikeFindFirstArgs>(args?: SelectSubset<T, PostCommentLikeFindFirstArgs<ExtArgs>>): Prisma__PostCommentLikeClient<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostCommentLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentLikeFindFirstOrThrowArgs} args - Arguments to find a PostCommentLike
     * @example
     * // Get one PostCommentLike
     * const postCommentLike = await prisma.postCommentLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostCommentLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, PostCommentLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostCommentLikeClient<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostCommentLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostCommentLikes
     * const postCommentLikes = await prisma.postCommentLike.findMany()
     * 
     * // Get first 10 PostCommentLikes
     * const postCommentLikes = await prisma.postCommentLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postCommentLikeWithIdOnly = await prisma.postCommentLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostCommentLikeFindManyArgs>(args?: SelectSubset<T, PostCommentLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostCommentLike.
     * @param {PostCommentLikeCreateArgs} args - Arguments to create a PostCommentLike.
     * @example
     * // Create one PostCommentLike
     * const PostCommentLike = await prisma.postCommentLike.create({
     *   data: {
     *     // ... data to create a PostCommentLike
     *   }
     * })
     * 
     */
    create<T extends PostCommentLikeCreateArgs>(args: SelectSubset<T, PostCommentLikeCreateArgs<ExtArgs>>): Prisma__PostCommentLikeClient<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostCommentLikes.
     * @param {PostCommentLikeCreateManyArgs} args - Arguments to create many PostCommentLikes.
     * @example
     * // Create many PostCommentLikes
     * const postCommentLike = await prisma.postCommentLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCommentLikeCreateManyArgs>(args?: SelectSubset<T, PostCommentLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostCommentLikes and returns the data saved in the database.
     * @param {PostCommentLikeCreateManyAndReturnArgs} args - Arguments to create many PostCommentLikes.
     * @example
     * // Create many PostCommentLikes
     * const postCommentLike = await prisma.postCommentLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostCommentLikes and only return the `id`
     * const postCommentLikeWithIdOnly = await prisma.postCommentLike.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCommentLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCommentLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostCommentLike.
     * @param {PostCommentLikeDeleteArgs} args - Arguments to delete one PostCommentLike.
     * @example
     * // Delete one PostCommentLike
     * const PostCommentLike = await prisma.postCommentLike.delete({
     *   where: {
     *     // ... filter to delete one PostCommentLike
     *   }
     * })
     * 
     */
    delete<T extends PostCommentLikeDeleteArgs>(args: SelectSubset<T, PostCommentLikeDeleteArgs<ExtArgs>>): Prisma__PostCommentLikeClient<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostCommentLike.
     * @param {PostCommentLikeUpdateArgs} args - Arguments to update one PostCommentLike.
     * @example
     * // Update one PostCommentLike
     * const postCommentLike = await prisma.postCommentLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostCommentLikeUpdateArgs>(args: SelectSubset<T, PostCommentLikeUpdateArgs<ExtArgs>>): Prisma__PostCommentLikeClient<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostCommentLikes.
     * @param {PostCommentLikeDeleteManyArgs} args - Arguments to filter PostCommentLikes to delete.
     * @example
     * // Delete a few PostCommentLikes
     * const { count } = await prisma.postCommentLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostCommentLikeDeleteManyArgs>(args?: SelectSubset<T, PostCommentLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostCommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostCommentLikes
     * const postCommentLike = await prisma.postCommentLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostCommentLikeUpdateManyArgs>(args: SelectSubset<T, PostCommentLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostCommentLike.
     * @param {PostCommentLikeUpsertArgs} args - Arguments to update or create a PostCommentLike.
     * @example
     * // Update or create a PostCommentLike
     * const postCommentLike = await prisma.postCommentLike.upsert({
     *   create: {
     *     // ... data to create a PostCommentLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostCommentLike we want to update
     *   }
     * })
     */
    upsert<T extends PostCommentLikeUpsertArgs>(args: SelectSubset<T, PostCommentLikeUpsertArgs<ExtArgs>>): Prisma__PostCommentLikeClient<$Result.GetResult<Prisma.$PostCommentLikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostCommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentLikeCountArgs} args - Arguments to filter PostCommentLikes to count.
     * @example
     * // Count the number of PostCommentLikes
     * const count = await prisma.postCommentLike.count({
     *   where: {
     *     // ... the filter for the PostCommentLikes we want to count
     *   }
     * })
    **/
    count<T extends PostCommentLikeCountArgs>(
      args?: Subset<T, PostCommentLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCommentLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostCommentLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostCommentLikeAggregateArgs>(args: Subset<T, PostCommentLikeAggregateArgs>): Prisma.PrismaPromise<GetPostCommentLikeAggregateType<T>>

    /**
     * Group by PostCommentLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostCommentLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostCommentLikeGroupByArgs['orderBy'] }
        : { orderBy?: PostCommentLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostCommentLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostCommentLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostCommentLike model
   */
  readonly fields: PostCommentLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostCommentLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostCommentLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    postComment<T extends PostCommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostCommentDefaultArgs<ExtArgs>>): Prisma__PostCommentClient<$Result.GetResult<Prisma.$PostCommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostCommentLike model
   */ 
  interface PostCommentLikeFieldRefs {
    readonly id: FieldRef<"PostCommentLike", 'String'>
    readonly profileId: FieldRef<"PostCommentLike", 'String'>
    readonly postCommentId: FieldRef<"PostCommentLike", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostCommentLike findUnique
   */
  export type PostCommentLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostCommentLike to fetch.
     */
    where: PostCommentLikeWhereUniqueInput
  }

  /**
   * PostCommentLike findUniqueOrThrow
   */
  export type PostCommentLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostCommentLike to fetch.
     */
    where: PostCommentLikeWhereUniqueInput
  }

  /**
   * PostCommentLike findFirst
   */
  export type PostCommentLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostCommentLike to fetch.
     */
    where?: PostCommentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCommentLikes to fetch.
     */
    orderBy?: PostCommentLikeOrderByWithRelationInput | PostCommentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostCommentLikes.
     */
    cursor?: PostCommentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCommentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostCommentLikes.
     */
    distinct?: PostCommentLikeScalarFieldEnum | PostCommentLikeScalarFieldEnum[]
  }

  /**
   * PostCommentLike findFirstOrThrow
   */
  export type PostCommentLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostCommentLike to fetch.
     */
    where?: PostCommentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCommentLikes to fetch.
     */
    orderBy?: PostCommentLikeOrderByWithRelationInput | PostCommentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostCommentLikes.
     */
    cursor?: PostCommentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCommentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostCommentLikes.
     */
    distinct?: PostCommentLikeScalarFieldEnum | PostCommentLikeScalarFieldEnum[]
  }

  /**
   * PostCommentLike findMany
   */
  export type PostCommentLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostCommentLikes to fetch.
     */
    where?: PostCommentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostCommentLikes to fetch.
     */
    orderBy?: PostCommentLikeOrderByWithRelationInput | PostCommentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostCommentLikes.
     */
    cursor?: PostCommentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostCommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostCommentLikes.
     */
    skip?: number
    distinct?: PostCommentLikeScalarFieldEnum | PostCommentLikeScalarFieldEnum[]
  }

  /**
   * PostCommentLike create
   */
  export type PostCommentLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a PostCommentLike.
     */
    data: XOR<PostCommentLikeCreateInput, PostCommentLikeUncheckedCreateInput>
  }

  /**
   * PostCommentLike createMany
   */
  export type PostCommentLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostCommentLikes.
     */
    data: PostCommentLikeCreateManyInput | PostCommentLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostCommentLike createManyAndReturn
   */
  export type PostCommentLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostCommentLikes.
     */
    data: PostCommentLikeCreateManyInput | PostCommentLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostCommentLike update
   */
  export type PostCommentLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a PostCommentLike.
     */
    data: XOR<PostCommentLikeUpdateInput, PostCommentLikeUncheckedUpdateInput>
    /**
     * Choose, which PostCommentLike to update.
     */
    where: PostCommentLikeWhereUniqueInput
  }

  /**
   * PostCommentLike updateMany
   */
  export type PostCommentLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostCommentLikes.
     */
    data: XOR<PostCommentLikeUpdateManyMutationInput, PostCommentLikeUncheckedUpdateManyInput>
    /**
     * Filter which PostCommentLikes to update
     */
    where?: PostCommentLikeWhereInput
  }

  /**
   * PostCommentLike upsert
   */
  export type PostCommentLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the PostCommentLike to update in case it exists.
     */
    where: PostCommentLikeWhereUniqueInput
    /**
     * In case the PostCommentLike found by the `where` argument doesn't exist, create a new PostCommentLike with this data.
     */
    create: XOR<PostCommentLikeCreateInput, PostCommentLikeUncheckedCreateInput>
    /**
     * In case the PostCommentLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostCommentLikeUpdateInput, PostCommentLikeUncheckedUpdateInput>
  }

  /**
   * PostCommentLike delete
   */
  export type PostCommentLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
    /**
     * Filter which PostCommentLike to delete.
     */
    where: PostCommentLikeWhereUniqueInput
  }

  /**
   * PostCommentLike deleteMany
   */
  export type PostCommentLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostCommentLikes to delete
     */
    where?: PostCommentLikeWhereInput
  }

  /**
   * PostCommentLike without action
   */
  export type PostCommentLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCommentLike
     */
    select?: PostCommentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostCommentLikeInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | ProfileDefaultArgs<ExtArgs>
    profiles?: boolean | Group$profilesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | ProfileDefaultArgs<ExtArgs>
    profiles?: boolean | Group$profilesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      owner: Prisma.$ProfilePayload<ExtArgs>
      profiles: Prisma.$ProfileGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profiles<T extends Group$profilesArgs<ExtArgs> = {}>(args?: Subset<T, Group$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */ 
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly ownerId: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
  }

  /**
   * Group.profiles
   */
  export type Group$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    where?: ProfileGroupWhereInput
    orderBy?: ProfileGroupOrderByWithRelationInput | ProfileGroupOrderByWithRelationInput[]
    cursor?: ProfileGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileGroupScalarFieldEnum | ProfileGroupScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model ProfileGroup
   */

  export type AggregateProfileGroup = {
    _count: ProfileGroupCountAggregateOutputType | null
    _min: ProfileGroupMinAggregateOutputType | null
    _max: ProfileGroupMaxAggregateOutputType | null
  }

  export type ProfileGroupMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    groupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileGroupMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    groupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileGroupCountAggregateOutputType = {
    id: number
    profileId: number
    groupId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileGroupMinAggregateInputType = {
    id?: true
    profileId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileGroupMaxAggregateInputType = {
    id?: true
    profileId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileGroupCountAggregateInputType = {
    id?: true
    profileId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileGroup to aggregate.
     */
    where?: ProfileGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileGroups to fetch.
     */
    orderBy?: ProfileGroupOrderByWithRelationInput | ProfileGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileGroups
    **/
    _count?: true | ProfileGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileGroupMaxAggregateInputType
  }

  export type GetProfileGroupAggregateType<T extends ProfileGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileGroup[P]>
      : GetScalarType<T[P], AggregateProfileGroup[P]>
  }




  export type ProfileGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileGroupWhereInput
    orderBy?: ProfileGroupOrderByWithAggregationInput | ProfileGroupOrderByWithAggregationInput[]
    by: ProfileGroupScalarFieldEnum[] | ProfileGroupScalarFieldEnum
    having?: ProfileGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileGroupCountAggregateInputType | true
    _min?: ProfileGroupMinAggregateInputType
    _max?: ProfileGroupMaxAggregateInputType
  }

  export type ProfileGroupGroupByOutputType = {
    id: string
    profileId: string
    groupId: string
    createdAt: Date
    updatedAt: Date
    _count: ProfileGroupCountAggregateOutputType | null
    _min: ProfileGroupMinAggregateOutputType | null
    _max: ProfileGroupMaxAggregateOutputType | null
  }

  type GetProfileGroupGroupByPayload<T extends ProfileGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupGroupByOutputType[P]>
        }
      >
    >


  export type ProfileGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    groupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileGroup"]>

  export type ProfileGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    groupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileGroup"]>

  export type ProfileGroupSelectScalar = {
    id?: boolean
    profileId?: boolean
    groupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type ProfileGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $ProfileGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileGroup"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      groupId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profileGroup"]>
    composites: {}
  }

  type ProfileGroupGetPayload<S extends boolean | null | undefined | ProfileGroupDefaultArgs> = $Result.GetResult<Prisma.$ProfileGroupPayload, S>

  type ProfileGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileGroupCountAggregateInputType | true
    }

  export interface ProfileGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileGroup'], meta: { name: 'ProfileGroup' } }
    /**
     * Find zero or one ProfileGroup that matches the filter.
     * @param {ProfileGroupFindUniqueArgs} args - Arguments to find a ProfileGroup
     * @example
     * // Get one ProfileGroup
     * const profileGroup = await prisma.profileGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileGroupFindUniqueArgs>(args: SelectSubset<T, ProfileGroupFindUniqueArgs<ExtArgs>>): Prisma__ProfileGroupClient<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileGroupFindUniqueOrThrowArgs} args - Arguments to find a ProfileGroup
     * @example
     * // Get one ProfileGroup
     * const profileGroup = await prisma.profileGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileGroupClient<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupFindFirstArgs} args - Arguments to find a ProfileGroup
     * @example
     * // Get one ProfileGroup
     * const profileGroup = await prisma.profileGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileGroupFindFirstArgs>(args?: SelectSubset<T, ProfileGroupFindFirstArgs<ExtArgs>>): Prisma__ProfileGroupClient<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupFindFirstOrThrowArgs} args - Arguments to find a ProfileGroup
     * @example
     * // Get one ProfileGroup
     * const profileGroup = await prisma.profileGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileGroupClient<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileGroups
     * const profileGroups = await prisma.profileGroup.findMany()
     * 
     * // Get first 10 ProfileGroups
     * const profileGroups = await prisma.profileGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileGroupWithIdOnly = await prisma.profileGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileGroupFindManyArgs>(args?: SelectSubset<T, ProfileGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileGroup.
     * @param {ProfileGroupCreateArgs} args - Arguments to create a ProfileGroup.
     * @example
     * // Create one ProfileGroup
     * const ProfileGroup = await prisma.profileGroup.create({
     *   data: {
     *     // ... data to create a ProfileGroup
     *   }
     * })
     * 
     */
    create<T extends ProfileGroupCreateArgs>(args: SelectSubset<T, ProfileGroupCreateArgs<ExtArgs>>): Prisma__ProfileGroupClient<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileGroups.
     * @param {ProfileGroupCreateManyArgs} args - Arguments to create many ProfileGroups.
     * @example
     * // Create many ProfileGroups
     * const profileGroup = await prisma.profileGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileGroupCreateManyArgs>(args?: SelectSubset<T, ProfileGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileGroups and returns the data saved in the database.
     * @param {ProfileGroupCreateManyAndReturnArgs} args - Arguments to create many ProfileGroups.
     * @example
     * // Create many ProfileGroups
     * const profileGroup = await prisma.profileGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileGroups and only return the `id`
     * const profileGroupWithIdOnly = await prisma.profileGroup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileGroup.
     * @param {ProfileGroupDeleteArgs} args - Arguments to delete one ProfileGroup.
     * @example
     * // Delete one ProfileGroup
     * const ProfileGroup = await prisma.profileGroup.delete({
     *   where: {
     *     // ... filter to delete one ProfileGroup
     *   }
     * })
     * 
     */
    delete<T extends ProfileGroupDeleteArgs>(args: SelectSubset<T, ProfileGroupDeleteArgs<ExtArgs>>): Prisma__ProfileGroupClient<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileGroup.
     * @param {ProfileGroupUpdateArgs} args - Arguments to update one ProfileGroup.
     * @example
     * // Update one ProfileGroup
     * const profileGroup = await prisma.profileGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileGroupUpdateArgs>(args: SelectSubset<T, ProfileGroupUpdateArgs<ExtArgs>>): Prisma__ProfileGroupClient<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileGroups.
     * @param {ProfileGroupDeleteManyArgs} args - Arguments to filter ProfileGroups to delete.
     * @example
     * // Delete a few ProfileGroups
     * const { count } = await prisma.profileGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileGroupDeleteManyArgs>(args?: SelectSubset<T, ProfileGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileGroups
     * const profileGroup = await prisma.profileGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileGroupUpdateManyArgs>(args: SelectSubset<T, ProfileGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileGroup.
     * @param {ProfileGroupUpsertArgs} args - Arguments to update or create a ProfileGroup.
     * @example
     * // Update or create a ProfileGroup
     * const profileGroup = await prisma.profileGroup.upsert({
     *   create: {
     *     // ... data to create a ProfileGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileGroup we want to update
     *   }
     * })
     */
    upsert<T extends ProfileGroupUpsertArgs>(args: SelectSubset<T, ProfileGroupUpsertArgs<ExtArgs>>): Prisma__ProfileGroupClient<$Result.GetResult<Prisma.$ProfileGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupCountArgs} args - Arguments to filter ProfileGroups to count.
     * @example
     * // Count the number of ProfileGroups
     * const count = await prisma.profileGroup.count({
     *   where: {
     *     // ... the filter for the ProfileGroups we want to count
     *   }
     * })
    **/
    count<T extends ProfileGroupCountArgs>(
      args?: Subset<T, ProfileGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileGroupAggregateArgs>(args: Subset<T, ProfileGroupAggregateArgs>): Prisma.PrismaPromise<GetProfileGroupAggregateType<T>>

    /**
     * Group by ProfileGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileGroup model
   */
  readonly fields: ProfileGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileGroup model
   */ 
  interface ProfileGroupFieldRefs {
    readonly id: FieldRef<"ProfileGroup", 'String'>
    readonly profileId: FieldRef<"ProfileGroup", 'String'>
    readonly groupId: FieldRef<"ProfileGroup", 'String'>
    readonly createdAt: FieldRef<"ProfileGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfileGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileGroup findUnique
   */
  export type ProfileGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProfileGroup to fetch.
     */
    where: ProfileGroupWhereUniqueInput
  }

  /**
   * ProfileGroup findUniqueOrThrow
   */
  export type ProfileGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProfileGroup to fetch.
     */
    where: ProfileGroupWhereUniqueInput
  }

  /**
   * ProfileGroup findFirst
   */
  export type ProfileGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProfileGroup to fetch.
     */
    where?: ProfileGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileGroups to fetch.
     */
    orderBy?: ProfileGroupOrderByWithRelationInput | ProfileGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileGroups.
     */
    cursor?: ProfileGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileGroups.
     */
    distinct?: ProfileGroupScalarFieldEnum | ProfileGroupScalarFieldEnum[]
  }

  /**
   * ProfileGroup findFirstOrThrow
   */
  export type ProfileGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProfileGroup to fetch.
     */
    where?: ProfileGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileGroups to fetch.
     */
    orderBy?: ProfileGroupOrderByWithRelationInput | ProfileGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileGroups.
     */
    cursor?: ProfileGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileGroups.
     */
    distinct?: ProfileGroupScalarFieldEnum | ProfileGroupScalarFieldEnum[]
  }

  /**
   * ProfileGroup findMany
   */
  export type ProfileGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    /**
     * Filter, which ProfileGroups to fetch.
     */
    where?: ProfileGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileGroups to fetch.
     */
    orderBy?: ProfileGroupOrderByWithRelationInput | ProfileGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileGroups.
     */
    cursor?: ProfileGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileGroups.
     */
    skip?: number
    distinct?: ProfileGroupScalarFieldEnum | ProfileGroupScalarFieldEnum[]
  }

  /**
   * ProfileGroup create
   */
  export type ProfileGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileGroup.
     */
    data: XOR<ProfileGroupCreateInput, ProfileGroupUncheckedCreateInput>
  }

  /**
   * ProfileGroup createMany
   */
  export type ProfileGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileGroups.
     */
    data: ProfileGroupCreateManyInput | ProfileGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileGroup createManyAndReturn
   */
  export type ProfileGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileGroups.
     */
    data: ProfileGroupCreateManyInput | ProfileGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileGroup update
   */
  export type ProfileGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileGroup.
     */
    data: XOR<ProfileGroupUpdateInput, ProfileGroupUncheckedUpdateInput>
    /**
     * Choose, which ProfileGroup to update.
     */
    where: ProfileGroupWhereUniqueInput
  }

  /**
   * ProfileGroup updateMany
   */
  export type ProfileGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileGroups.
     */
    data: XOR<ProfileGroupUpdateManyMutationInput, ProfileGroupUncheckedUpdateManyInput>
    /**
     * Filter which ProfileGroups to update
     */
    where?: ProfileGroupWhereInput
  }

  /**
   * ProfileGroup upsert
   */
  export type ProfileGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileGroup to update in case it exists.
     */
    where: ProfileGroupWhereUniqueInput
    /**
     * In case the ProfileGroup found by the `where` argument doesn't exist, create a new ProfileGroup with this data.
     */
    create: XOR<ProfileGroupCreateInput, ProfileGroupUncheckedCreateInput>
    /**
     * In case the ProfileGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileGroupUpdateInput, ProfileGroupUncheckedUpdateInput>
  }

  /**
   * ProfileGroup delete
   */
  export type ProfileGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
    /**
     * Filter which ProfileGroup to delete.
     */
    where: ProfileGroupWhereUniqueInput
  }

  /**
   * ProfileGroup deleteMany
   */
  export type ProfileGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileGroups to delete
     */
    where?: ProfileGroupWhereInput
  }

  /**
   * ProfileGroup without action
   */
  export type ProfileGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileGroup
     */
    select?: ProfileGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileGroupInclude<ExtArgs> | null
  }


  /**
   * Model News
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NewsType | null
    cover: string | null
    isPublished: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NewsType | null
    cover: string | null
    isPublished: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    type: number
    cover: number
    isPublished: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    cover?: true
    isPublished?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    cover?: true
    isPublished?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    cover?: true
    isPublished?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to aggregate.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithAggregationInput | NewsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    id: string
    title: string
    content: string | null
    type: $Enums.NewsType
    cover: string
    isPublished: boolean
    schoolId: string | null
    createdAt: Date
    updatedAt: Date
    _count: NewsCountAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    cover?: boolean
    isPublished?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | News$schoolArgs<ExtArgs>
    notifications?: boolean | News$notificationsArgs<ExtArgs>
    _count?: boolean | NewsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    cover?: boolean
    isPublished?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | News$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    cover?: boolean
    isPublished?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | News$schoolArgs<ExtArgs>
    notifications?: boolean | News$notificationsArgs<ExtArgs>
    _count?: boolean | NewsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | News$schoolArgs<ExtArgs>
  }

  export type $NewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "News"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs> | null
      notifications: Prisma.$NewsNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string | null
      type: $Enums.NewsType
      cover: string
      isPublished: boolean
      schoolId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["news"]>
    composites: {}
  }

  type NewsGetPayload<S extends boolean | null | undefined | NewsDefaultArgs> = $Result.GetResult<Prisma.$NewsPayload, S>

  type NewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface NewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['News'], meta: { name: 'News' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsFindUniqueArgs>(args: SelectSubset<T, NewsFindUniqueArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one News that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsFindFirstArgs>(args?: SelectSubset<T, NewsFindFirstArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsFindManyArgs>(args?: SelectSubset<T, NewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
     */
    create<T extends NewsCreateArgs>(args: SelectSubset<T, NewsCreateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many News.
     * @param {NewsCreateManyArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsCreateManyArgs>(args?: SelectSubset<T, NewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many News and returns the data saved in the database.
     * @param {NewsCreateManyAndReturnArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many News and only return the `id`
     * const newsWithIdOnly = await prisma.news.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
     */
    delete<T extends NewsDeleteArgs>(args: SelectSubset<T, NewsDeleteArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsUpdateArgs>(args: SelectSubset<T, NewsUpdateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsDeleteManyArgs>(args?: SelectSubset<T, NewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsUpdateManyArgs>(args: SelectSubset<T, NewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
     */
    upsert<T extends NewsUpsertArgs>(args: SelectSubset<T, NewsUpsertArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the News model
   */
  readonly fields: NewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends News$schoolArgs<ExtArgs> = {}>(args?: Subset<T, News$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends News$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, News$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the News model
   */ 
  interface NewsFieldRefs {
    readonly id: FieldRef<"News", 'String'>
    readonly title: FieldRef<"News", 'String'>
    readonly content: FieldRef<"News", 'String'>
    readonly type: FieldRef<"News", 'NewsType'>
    readonly cover: FieldRef<"News", 'String'>
    readonly isPublished: FieldRef<"News", 'Boolean'>
    readonly schoolId: FieldRef<"News", 'String'>
    readonly createdAt: FieldRef<"News", 'DateTime'>
    readonly updatedAt: FieldRef<"News", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findFirst
   */
  export type NewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findMany
   */
  export type NewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News create
   */
  export type NewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to create a News.
     */
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }

  /**
   * News createMany
   */
  export type NewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News createManyAndReturn
   */
  export type NewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * News update
   */
  export type NewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to update a News.
     */
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
  }

  /**
   * News upsert
   */
  export type NewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The filter to search for the News to update in case it exists.
     */
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     */
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }

  /**
   * News delete
   */
  export type NewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter which News to delete.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to delete
     */
    where?: NewsWhereInput
  }

  /**
   * News.school
   */
  export type News$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * News.notifications
   */
  export type News$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    where?: NewsNotificationWhereInput
    orderBy?: NewsNotificationOrderByWithRelationInput | NewsNotificationOrderByWithRelationInput[]
    cursor?: NewsNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsNotificationScalarFieldEnum | NewsNotificationScalarFieldEnum[]
  }

  /**
   * News without action
   */
  export type NewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
  }


  /**
   * Model NewsNotification
   */

  export type AggregateNewsNotification = {
    _count: NewsNotificationCountAggregateOutputType | null
    _min: NewsNotificationMinAggregateOutputType | null
    _max: NewsNotificationMaxAggregateOutputType | null
  }

  export type NewsNotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NewsType | null
    isRead: boolean | null
    studentId: string | null
    fromId: string | null
    newsId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsNotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NewsType | null
    isRead: boolean | null
    studentId: string | null
    fromId: string | null
    newsId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsNotificationCountAggregateOutputType = {
    id: number
    type: number
    isRead: number
    studentId: number
    fromId: number
    newsId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsNotificationMinAggregateInputType = {
    id?: true
    type?: true
    isRead?: true
    studentId?: true
    fromId?: true
    newsId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsNotificationMaxAggregateInputType = {
    id?: true
    type?: true
    isRead?: true
    studentId?: true
    fromId?: true
    newsId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsNotificationCountAggregateInputType = {
    id?: true
    type?: true
    isRead?: true
    studentId?: true
    fromId?: true
    newsId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsNotification to aggregate.
     */
    where?: NewsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsNotifications to fetch.
     */
    orderBy?: NewsNotificationOrderByWithRelationInput | NewsNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsNotifications
    **/
    _count?: true | NewsNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsNotificationMaxAggregateInputType
  }

  export type GetNewsNotificationAggregateType<T extends NewsNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsNotification[P]>
      : GetScalarType<T[P], AggregateNewsNotification[P]>
  }




  export type NewsNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsNotificationWhereInput
    orderBy?: NewsNotificationOrderByWithAggregationInput | NewsNotificationOrderByWithAggregationInput[]
    by: NewsNotificationScalarFieldEnum[] | NewsNotificationScalarFieldEnum
    having?: NewsNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsNotificationCountAggregateInputType | true
    _min?: NewsNotificationMinAggregateInputType
    _max?: NewsNotificationMaxAggregateInputType
  }

  export type NewsNotificationGroupByOutputType = {
    id: string
    type: $Enums.NewsType
    isRead: boolean
    studentId: string
    fromId: string | null
    newsId: string
    createdAt: Date
    updatedAt: Date
    _count: NewsNotificationCountAggregateOutputType | null
    _min: NewsNotificationMinAggregateOutputType | null
    _max: NewsNotificationMaxAggregateOutputType | null
  }

  type GetNewsNotificationGroupByPayload<T extends NewsNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NewsNotificationGroupByOutputType[P]>
        }
      >
    >


  export type NewsNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    isRead?: boolean
    studentId?: boolean
    fromId?: boolean
    newsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    fromStudent?: boolean | NewsNotification$fromStudentArgs<ExtArgs>
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsNotification"]>

  export type NewsNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    isRead?: boolean
    studentId?: boolean
    fromId?: boolean
    newsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    fromStudent?: boolean | NewsNotification$fromStudentArgs<ExtArgs>
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsNotification"]>

  export type NewsNotificationSelectScalar = {
    id?: boolean
    type?: boolean
    isRead?: boolean
    studentId?: boolean
    fromId?: boolean
    newsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    fromStudent?: boolean | NewsNotification$fromStudentArgs<ExtArgs>
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }
  export type NewsNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    fromStudent?: boolean | NewsNotification$fromStudentArgs<ExtArgs>
    news?: boolean | NewsDefaultArgs<ExtArgs>
  }

  export type $NewsNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsNotification"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      fromStudent: Prisma.$StudentPayload<ExtArgs> | null
      news: Prisma.$NewsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NewsType
      isRead: boolean
      studentId: string
      fromId: string | null
      newsId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["newsNotification"]>
    composites: {}
  }

  type NewsNotificationGetPayload<S extends boolean | null | undefined | NewsNotificationDefaultArgs> = $Result.GetResult<Prisma.$NewsNotificationPayload, S>

  type NewsNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsNotificationCountAggregateInputType | true
    }

  export interface NewsNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsNotification'], meta: { name: 'NewsNotification' } }
    /**
     * Find zero or one NewsNotification that matches the filter.
     * @param {NewsNotificationFindUniqueArgs} args - Arguments to find a NewsNotification
     * @example
     * // Get one NewsNotification
     * const newsNotification = await prisma.newsNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsNotificationFindUniqueArgs>(args: SelectSubset<T, NewsNotificationFindUniqueArgs<ExtArgs>>): Prisma__NewsNotificationClient<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsNotificationFindUniqueOrThrowArgs} args - Arguments to find a NewsNotification
     * @example
     * // Get one NewsNotification
     * const newsNotification = await prisma.newsNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsNotificationClient<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsNotificationFindFirstArgs} args - Arguments to find a NewsNotification
     * @example
     * // Get one NewsNotification
     * const newsNotification = await prisma.newsNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsNotificationFindFirstArgs>(args?: SelectSubset<T, NewsNotificationFindFirstArgs<ExtArgs>>): Prisma__NewsNotificationClient<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsNotificationFindFirstOrThrowArgs} args - Arguments to find a NewsNotification
     * @example
     * // Get one NewsNotification
     * const newsNotification = await prisma.newsNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsNotificationClient<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsNotifications
     * const newsNotifications = await prisma.newsNotification.findMany()
     * 
     * // Get first 10 NewsNotifications
     * const newsNotifications = await prisma.newsNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsNotificationWithIdOnly = await prisma.newsNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsNotificationFindManyArgs>(args?: SelectSubset<T, NewsNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsNotification.
     * @param {NewsNotificationCreateArgs} args - Arguments to create a NewsNotification.
     * @example
     * // Create one NewsNotification
     * const NewsNotification = await prisma.newsNotification.create({
     *   data: {
     *     // ... data to create a NewsNotification
     *   }
     * })
     * 
     */
    create<T extends NewsNotificationCreateArgs>(args: SelectSubset<T, NewsNotificationCreateArgs<ExtArgs>>): Prisma__NewsNotificationClient<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsNotifications.
     * @param {NewsNotificationCreateManyArgs} args - Arguments to create many NewsNotifications.
     * @example
     * // Create many NewsNotifications
     * const newsNotification = await prisma.newsNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsNotificationCreateManyArgs>(args?: SelectSubset<T, NewsNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsNotifications and returns the data saved in the database.
     * @param {NewsNotificationCreateManyAndReturnArgs} args - Arguments to create many NewsNotifications.
     * @example
     * // Create many NewsNotifications
     * const newsNotification = await prisma.newsNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsNotifications and only return the `id`
     * const newsNotificationWithIdOnly = await prisma.newsNotification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsNotification.
     * @param {NewsNotificationDeleteArgs} args - Arguments to delete one NewsNotification.
     * @example
     * // Delete one NewsNotification
     * const NewsNotification = await prisma.newsNotification.delete({
     *   where: {
     *     // ... filter to delete one NewsNotification
     *   }
     * })
     * 
     */
    delete<T extends NewsNotificationDeleteArgs>(args: SelectSubset<T, NewsNotificationDeleteArgs<ExtArgs>>): Prisma__NewsNotificationClient<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsNotification.
     * @param {NewsNotificationUpdateArgs} args - Arguments to update one NewsNotification.
     * @example
     * // Update one NewsNotification
     * const newsNotification = await prisma.newsNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsNotificationUpdateArgs>(args: SelectSubset<T, NewsNotificationUpdateArgs<ExtArgs>>): Prisma__NewsNotificationClient<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsNotifications.
     * @param {NewsNotificationDeleteManyArgs} args - Arguments to filter NewsNotifications to delete.
     * @example
     * // Delete a few NewsNotifications
     * const { count } = await prisma.newsNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsNotificationDeleteManyArgs>(args?: SelectSubset<T, NewsNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsNotifications
     * const newsNotification = await prisma.newsNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsNotificationUpdateManyArgs>(args: SelectSubset<T, NewsNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsNotification.
     * @param {NewsNotificationUpsertArgs} args - Arguments to update or create a NewsNotification.
     * @example
     * // Update or create a NewsNotification
     * const newsNotification = await prisma.newsNotification.upsert({
     *   create: {
     *     // ... data to create a NewsNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsNotification we want to update
     *   }
     * })
     */
    upsert<T extends NewsNotificationUpsertArgs>(args: SelectSubset<T, NewsNotificationUpsertArgs<ExtArgs>>): Prisma__NewsNotificationClient<$Result.GetResult<Prisma.$NewsNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsNotificationCountArgs} args - Arguments to filter NewsNotifications to count.
     * @example
     * // Count the number of NewsNotifications
     * const count = await prisma.newsNotification.count({
     *   where: {
     *     // ... the filter for the NewsNotifications we want to count
     *   }
     * })
    **/
    count<T extends NewsNotificationCountArgs>(
      args?: Subset<T, NewsNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsNotificationAggregateArgs>(args: Subset<T, NewsNotificationAggregateArgs>): Prisma.PrismaPromise<GetNewsNotificationAggregateType<T>>

    /**
     * Group by NewsNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsNotificationGroupByArgs['orderBy'] }
        : { orderBy?: NewsNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsNotification model
   */
  readonly fields: NewsNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fromStudent<T extends NewsNotification$fromStudentArgs<ExtArgs> = {}>(args?: Subset<T, NewsNotification$fromStudentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    news<T extends NewsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NewsDefaultArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsNotification model
   */ 
  interface NewsNotificationFieldRefs {
    readonly id: FieldRef<"NewsNotification", 'String'>
    readonly type: FieldRef<"NewsNotification", 'NewsType'>
    readonly isRead: FieldRef<"NewsNotification", 'Boolean'>
    readonly studentId: FieldRef<"NewsNotification", 'String'>
    readonly fromId: FieldRef<"NewsNotification", 'String'>
    readonly newsId: FieldRef<"NewsNotification", 'String'>
    readonly createdAt: FieldRef<"NewsNotification", 'DateTime'>
    readonly updatedAt: FieldRef<"NewsNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsNotification findUnique
   */
  export type NewsNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    /**
     * Filter, which NewsNotification to fetch.
     */
    where: NewsNotificationWhereUniqueInput
  }

  /**
   * NewsNotification findUniqueOrThrow
   */
  export type NewsNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    /**
     * Filter, which NewsNotification to fetch.
     */
    where: NewsNotificationWhereUniqueInput
  }

  /**
   * NewsNotification findFirst
   */
  export type NewsNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    /**
     * Filter, which NewsNotification to fetch.
     */
    where?: NewsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsNotifications to fetch.
     */
    orderBy?: NewsNotificationOrderByWithRelationInput | NewsNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsNotifications.
     */
    cursor?: NewsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsNotifications.
     */
    distinct?: NewsNotificationScalarFieldEnum | NewsNotificationScalarFieldEnum[]
  }

  /**
   * NewsNotification findFirstOrThrow
   */
  export type NewsNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    /**
     * Filter, which NewsNotification to fetch.
     */
    where?: NewsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsNotifications to fetch.
     */
    orderBy?: NewsNotificationOrderByWithRelationInput | NewsNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsNotifications.
     */
    cursor?: NewsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsNotifications.
     */
    distinct?: NewsNotificationScalarFieldEnum | NewsNotificationScalarFieldEnum[]
  }

  /**
   * NewsNotification findMany
   */
  export type NewsNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    /**
     * Filter, which NewsNotifications to fetch.
     */
    where?: NewsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsNotifications to fetch.
     */
    orderBy?: NewsNotificationOrderByWithRelationInput | NewsNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsNotifications.
     */
    cursor?: NewsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsNotifications.
     */
    skip?: number
    distinct?: NewsNotificationScalarFieldEnum | NewsNotificationScalarFieldEnum[]
  }

  /**
   * NewsNotification create
   */
  export type NewsNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a NewsNotification.
     */
    data: XOR<NewsNotificationCreateInput, NewsNotificationUncheckedCreateInput>
  }

  /**
   * NewsNotification createMany
   */
  export type NewsNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsNotifications.
     */
    data: NewsNotificationCreateManyInput | NewsNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewsNotification createManyAndReturn
   */
  export type NewsNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsNotifications.
     */
    data: NewsNotificationCreateManyInput | NewsNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NewsNotification update
   */
  export type NewsNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a NewsNotification.
     */
    data: XOR<NewsNotificationUpdateInput, NewsNotificationUncheckedUpdateInput>
    /**
     * Choose, which NewsNotification to update.
     */
    where: NewsNotificationWhereUniqueInput
  }

  /**
   * NewsNotification updateMany
   */
  export type NewsNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsNotifications.
     */
    data: XOR<NewsNotificationUpdateManyMutationInput, NewsNotificationUncheckedUpdateManyInput>
    /**
     * Filter which NewsNotifications to update
     */
    where?: NewsNotificationWhereInput
  }

  /**
   * NewsNotification upsert
   */
  export type NewsNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the NewsNotification to update in case it exists.
     */
    where: NewsNotificationWhereUniqueInput
    /**
     * In case the NewsNotification found by the `where` argument doesn't exist, create a new NewsNotification with this data.
     */
    create: XOR<NewsNotificationCreateInput, NewsNotificationUncheckedCreateInput>
    /**
     * In case the NewsNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsNotificationUpdateInput, NewsNotificationUncheckedUpdateInput>
  }

  /**
   * NewsNotification delete
   */
  export type NewsNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
    /**
     * Filter which NewsNotification to delete.
     */
    where: NewsNotificationWhereUniqueInput
  }

  /**
   * NewsNotification deleteMany
   */
  export type NewsNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsNotifications to delete
     */
    where?: NewsNotificationWhereInput
  }

  /**
   * NewsNotification.fromStudent
   */
  export type NewsNotification$fromStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * NewsNotification without action
   */
  export type NewsNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsNotification
     */
    select?: NewsNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsNotificationInclude<ExtArgs> | null
  }


  /**
   * Model StudentFollow
   */

  export type AggregateStudentFollow = {
    _count: StudentFollowCountAggregateOutputType | null
    _min: StudentFollowMinAggregateOutputType | null
    _max: StudentFollowMaxAggregateOutputType | null
  }

  export type StudentFollowMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    followerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentFollowMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    followerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentFollowCountAggregateOutputType = {
    id: number
    studentId: number
    followerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentFollowMinAggregateInputType = {
    id?: true
    studentId?: true
    followerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentFollowMaxAggregateInputType = {
    id?: true
    studentId?: true
    followerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentFollowCountAggregateInputType = {
    id?: true
    studentId?: true
    followerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentFollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentFollow to aggregate.
     */
    where?: StudentFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFollows to fetch.
     */
    orderBy?: StudentFollowOrderByWithRelationInput | StudentFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentFollows
    **/
    _count?: true | StudentFollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentFollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentFollowMaxAggregateInputType
  }

  export type GetStudentFollowAggregateType<T extends StudentFollowAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentFollow[P]>
      : GetScalarType<T[P], AggregateStudentFollow[P]>
  }




  export type StudentFollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFollowWhereInput
    orderBy?: StudentFollowOrderByWithAggregationInput | StudentFollowOrderByWithAggregationInput[]
    by: StudentFollowScalarFieldEnum[] | StudentFollowScalarFieldEnum
    having?: StudentFollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentFollowCountAggregateInputType | true
    _min?: StudentFollowMinAggregateInputType
    _max?: StudentFollowMaxAggregateInputType
  }

  export type StudentFollowGroupByOutputType = {
    id: string
    studentId: string
    followerId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentFollowCountAggregateOutputType | null
    _min: StudentFollowMinAggregateOutputType | null
    _max: StudentFollowMaxAggregateOutputType | null
  }

  type GetStudentFollowGroupByPayload<T extends StudentFollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentFollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentFollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentFollowGroupByOutputType[P]>
            : GetScalarType<T[P], StudentFollowGroupByOutputType[P]>
        }
      >
    >


  export type StudentFollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    followerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    follower?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFollow"]>

  export type StudentFollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    followerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    follower?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFollow"]>

  export type StudentFollowSelectScalar = {
    id?: boolean
    studentId?: boolean
    followerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentFollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    follower?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentFollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    follower?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentFollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentFollow"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      follower: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      followerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentFollow"]>
    composites: {}
  }

  type StudentFollowGetPayload<S extends boolean | null | undefined | StudentFollowDefaultArgs> = $Result.GetResult<Prisma.$StudentFollowPayload, S>

  type StudentFollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFollowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentFollowCountAggregateInputType | true
    }

  export interface StudentFollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentFollow'], meta: { name: 'StudentFollow' } }
    /**
     * Find zero or one StudentFollow that matches the filter.
     * @param {StudentFollowFindUniqueArgs} args - Arguments to find a StudentFollow
     * @example
     * // Get one StudentFollow
     * const studentFollow = await prisma.studentFollow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFollowFindUniqueArgs>(args: SelectSubset<T, StudentFollowFindUniqueArgs<ExtArgs>>): Prisma__StudentFollowClient<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentFollow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFollowFindUniqueOrThrowArgs} args - Arguments to find a StudentFollow
     * @example
     * // Get one StudentFollow
     * const studentFollow = await prisma.studentFollow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFollowFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentFollowClient<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentFollow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFollowFindFirstArgs} args - Arguments to find a StudentFollow
     * @example
     * // Get one StudentFollow
     * const studentFollow = await prisma.studentFollow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFollowFindFirstArgs>(args?: SelectSubset<T, StudentFollowFindFirstArgs<ExtArgs>>): Prisma__StudentFollowClient<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentFollow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFollowFindFirstOrThrowArgs} args - Arguments to find a StudentFollow
     * @example
     * // Get one StudentFollow
     * const studentFollow = await prisma.studentFollow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFollowFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentFollowClient<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentFollows
     * const studentFollows = await prisma.studentFollow.findMany()
     * 
     * // Get first 10 StudentFollows
     * const studentFollows = await prisma.studentFollow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentFollowWithIdOnly = await prisma.studentFollow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFollowFindManyArgs>(args?: SelectSubset<T, StudentFollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentFollow.
     * @param {StudentFollowCreateArgs} args - Arguments to create a StudentFollow.
     * @example
     * // Create one StudentFollow
     * const StudentFollow = await prisma.studentFollow.create({
     *   data: {
     *     // ... data to create a StudentFollow
     *   }
     * })
     * 
     */
    create<T extends StudentFollowCreateArgs>(args: SelectSubset<T, StudentFollowCreateArgs<ExtArgs>>): Prisma__StudentFollowClient<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentFollows.
     * @param {StudentFollowCreateManyArgs} args - Arguments to create many StudentFollows.
     * @example
     * // Create many StudentFollows
     * const studentFollow = await prisma.studentFollow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentFollowCreateManyArgs>(args?: SelectSubset<T, StudentFollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentFollows and returns the data saved in the database.
     * @param {StudentFollowCreateManyAndReturnArgs} args - Arguments to create many StudentFollows.
     * @example
     * // Create many StudentFollows
     * const studentFollow = await prisma.studentFollow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentFollows and only return the `id`
     * const studentFollowWithIdOnly = await prisma.studentFollow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentFollowCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentFollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentFollow.
     * @param {StudentFollowDeleteArgs} args - Arguments to delete one StudentFollow.
     * @example
     * // Delete one StudentFollow
     * const StudentFollow = await prisma.studentFollow.delete({
     *   where: {
     *     // ... filter to delete one StudentFollow
     *   }
     * })
     * 
     */
    delete<T extends StudentFollowDeleteArgs>(args: SelectSubset<T, StudentFollowDeleteArgs<ExtArgs>>): Prisma__StudentFollowClient<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentFollow.
     * @param {StudentFollowUpdateArgs} args - Arguments to update one StudentFollow.
     * @example
     * // Update one StudentFollow
     * const studentFollow = await prisma.studentFollow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentFollowUpdateArgs>(args: SelectSubset<T, StudentFollowUpdateArgs<ExtArgs>>): Prisma__StudentFollowClient<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentFollows.
     * @param {StudentFollowDeleteManyArgs} args - Arguments to filter StudentFollows to delete.
     * @example
     * // Delete a few StudentFollows
     * const { count } = await prisma.studentFollow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentFollowDeleteManyArgs>(args?: SelectSubset<T, StudentFollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentFollows
     * const studentFollow = await prisma.studentFollow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentFollowUpdateManyArgs>(args: SelectSubset<T, StudentFollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentFollow.
     * @param {StudentFollowUpsertArgs} args - Arguments to update or create a StudentFollow.
     * @example
     * // Update or create a StudentFollow
     * const studentFollow = await prisma.studentFollow.upsert({
     *   create: {
     *     // ... data to create a StudentFollow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentFollow we want to update
     *   }
     * })
     */
    upsert<T extends StudentFollowUpsertArgs>(args: SelectSubset<T, StudentFollowUpsertArgs<ExtArgs>>): Prisma__StudentFollowClient<$Result.GetResult<Prisma.$StudentFollowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFollowCountArgs} args - Arguments to filter StudentFollows to count.
     * @example
     * // Count the number of StudentFollows
     * const count = await prisma.studentFollow.count({
     *   where: {
     *     // ... the filter for the StudentFollows we want to count
     *   }
     * })
    **/
    count<T extends StudentFollowCountArgs>(
      args?: Subset<T, StudentFollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentFollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentFollowAggregateArgs>(args: Subset<T, StudentFollowAggregateArgs>): Prisma.PrismaPromise<GetStudentFollowAggregateType<T>>

    /**
     * Group by StudentFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentFollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentFollowGroupByArgs['orderBy'] }
        : { orderBy?: StudentFollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentFollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentFollow model
   */
  readonly fields: StudentFollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentFollow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentFollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    follower<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentFollow model
   */ 
  interface StudentFollowFieldRefs {
    readonly id: FieldRef<"StudentFollow", 'String'>
    readonly studentId: FieldRef<"StudentFollow", 'String'>
    readonly followerId: FieldRef<"StudentFollow", 'String'>
    readonly createdAt: FieldRef<"StudentFollow", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentFollow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentFollow findUnique
   */
  export type StudentFollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    /**
     * Filter, which StudentFollow to fetch.
     */
    where: StudentFollowWhereUniqueInput
  }

  /**
   * StudentFollow findUniqueOrThrow
   */
  export type StudentFollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    /**
     * Filter, which StudentFollow to fetch.
     */
    where: StudentFollowWhereUniqueInput
  }

  /**
   * StudentFollow findFirst
   */
  export type StudentFollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    /**
     * Filter, which StudentFollow to fetch.
     */
    where?: StudentFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFollows to fetch.
     */
    orderBy?: StudentFollowOrderByWithRelationInput | StudentFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentFollows.
     */
    cursor?: StudentFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentFollows.
     */
    distinct?: StudentFollowScalarFieldEnum | StudentFollowScalarFieldEnum[]
  }

  /**
   * StudentFollow findFirstOrThrow
   */
  export type StudentFollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    /**
     * Filter, which StudentFollow to fetch.
     */
    where?: StudentFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFollows to fetch.
     */
    orderBy?: StudentFollowOrderByWithRelationInput | StudentFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentFollows.
     */
    cursor?: StudentFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentFollows.
     */
    distinct?: StudentFollowScalarFieldEnum | StudentFollowScalarFieldEnum[]
  }

  /**
   * StudentFollow findMany
   */
  export type StudentFollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    /**
     * Filter, which StudentFollows to fetch.
     */
    where?: StudentFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFollows to fetch.
     */
    orderBy?: StudentFollowOrderByWithRelationInput | StudentFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentFollows.
     */
    cursor?: StudentFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFollows.
     */
    skip?: number
    distinct?: StudentFollowScalarFieldEnum | StudentFollowScalarFieldEnum[]
  }

  /**
   * StudentFollow create
   */
  export type StudentFollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentFollow.
     */
    data: XOR<StudentFollowCreateInput, StudentFollowUncheckedCreateInput>
  }

  /**
   * StudentFollow createMany
   */
  export type StudentFollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentFollows.
     */
    data: StudentFollowCreateManyInput | StudentFollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentFollow createManyAndReturn
   */
  export type StudentFollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentFollows.
     */
    data: StudentFollowCreateManyInput | StudentFollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentFollow update
   */
  export type StudentFollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentFollow.
     */
    data: XOR<StudentFollowUpdateInput, StudentFollowUncheckedUpdateInput>
    /**
     * Choose, which StudentFollow to update.
     */
    where: StudentFollowWhereUniqueInput
  }

  /**
   * StudentFollow updateMany
   */
  export type StudentFollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentFollows.
     */
    data: XOR<StudentFollowUpdateManyMutationInput, StudentFollowUncheckedUpdateManyInput>
    /**
     * Filter which StudentFollows to update
     */
    where?: StudentFollowWhereInput
  }

  /**
   * StudentFollow upsert
   */
  export type StudentFollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentFollow to update in case it exists.
     */
    where: StudentFollowWhereUniqueInput
    /**
     * In case the StudentFollow found by the `where` argument doesn't exist, create a new StudentFollow with this data.
     */
    create: XOR<StudentFollowCreateInput, StudentFollowUncheckedCreateInput>
    /**
     * In case the StudentFollow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentFollowUpdateInput, StudentFollowUncheckedUpdateInput>
  }

  /**
   * StudentFollow delete
   */
  export type StudentFollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
    /**
     * Filter which StudentFollow to delete.
     */
    where: StudentFollowWhereUniqueInput
  }

  /**
   * StudentFollow deleteMany
   */
  export type StudentFollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentFollows to delete
     */
    where?: StudentFollowWhereInput
  }

  /**
   * StudentFollow without action
   */
  export type StudentFollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFollow
     */
    select?: StudentFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFollowInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    title: $Enums.ContactTitle | null
    phone: string | null
    email: string | null
    message: string | null
    isRead: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    title: $Enums.ContactTitle | null
    phone: string | null
    email: string | null
    message: string | null
    isRead: boolean | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    title: number
    phone: number
    email: number
    message: number
    isRead: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    title?: true
    phone?: true
    email?: true
    message?: true
    isRead?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    title?: true
    phone?: true
    email?: true
    message?: true
    isRead?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    title?: true
    phone?: true
    email?: true
    message?: true
    isRead?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string
    title: $Enums.ContactTitle
    phone: string
    email: string
    message: string
    isRead: boolean
    schoolId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    phone?: boolean
    email?: boolean
    message?: boolean
    isRead?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | Contact$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    phone?: boolean
    email?: boolean
    message?: boolean
    isRead?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | Contact$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    title?: boolean
    phone?: boolean
    email?: boolean
    message?: boolean
    isRead?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | Contact$schoolArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | Contact$schoolArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      title: $Enums.ContactTitle
      phone: string
      email: string
      message: string
      isRead: boolean
      schoolId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends Contact$schoolArgs<ExtArgs> = {}>(args?: Subset<T, Contact$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly title: FieldRef<"Contact", 'ContactTitle'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly message: FieldRef<"Contact", 'String'>
    readonly isRead: FieldRef<"Contact", 'Boolean'>
    readonly schoolId: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact.school
   */
  export type Contact$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    password: 'password',
    name: 'name',
    dob: 'dob',
    gender: 'gender',
    phoneNumber: 'phoneNumber',
    idCardNumber: 'idCardNumber',
    address: 'address',
    image: 'image',
    isLocked: 'isLocked',
    isTwoFactorEnabled: 'isTwoFactorEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const TwoFactorTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt'
  };

  export type TwoFactorTokenScalarFieldEnum = (typeof TwoFactorTokenScalarFieldEnum)[keyof typeof TwoFactorTokenScalarFieldEnum]


  export const TwoFactorConfirmationScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwoFactorConfirmationScalarFieldEnum = (typeof TwoFactorConfirmationScalarFieldEnum)[keyof typeof TwoFactorConfirmationScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    logo: 'logo',
    background: 'background',
    name: 'name',
    short: 'short',
    description: 'description',
    history: 'history',
    color: 'color',
    isPublished: 'isPublished',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const SchoolScholarshipScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    cover: 'cover',
    isPublished: 'isPublished',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScholarshipScalarFieldEnum = (typeof SchoolScholarshipScalarFieldEnum)[keyof typeof SchoolScholarshipScalarFieldEnum]


  export const SchoolScholarshipImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    scholarshipId: 'scholarshipId'
  };

  export type SchoolScholarshipImageScalarFieldEnum = (typeof SchoolScholarshipImageScalarFieldEnum)[keyof typeof SchoolScholarshipImageScalarFieldEnum]


  export const StudentSchoolScholarshipScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    scholarshipId: 'scholarshipId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentSchoolScholarshipScalarFieldEnum = (typeof StudentSchoolScholarshipScalarFieldEnum)[keyof typeof StudentSchoolScholarshipScalarFieldEnum]


  export const SchoolGalleryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolGalleryScalarFieldEnum = (typeof SchoolGalleryScalarFieldEnum)[keyof typeof SchoolGalleryScalarFieldEnum]


  export const SchoolGalleryImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    galleryId: 'galleryId'
  };

  export type SchoolGalleryImageScalarFieldEnum = (typeof SchoolGalleryImageScalarFieldEnum)[keyof typeof SchoolGalleryImageScalarFieldEnum]


  export const SchoolLocationScalarFieldEnum: {
    id: 'id',
    cover: 'cover',
    name: 'name',
    address: 'address',
    isMain: 'isMain',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolLocationScalarFieldEnum = (typeof SchoolLocationScalarFieldEnum)[keyof typeof SchoolLocationScalarFieldEnum]


  export const SchoolLocationImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    locationId: 'locationId'
  };

  export type SchoolLocationImageScalarFieldEnum = (typeof SchoolLocationImageScalarFieldEnum)[keyof typeof SchoolLocationImageScalarFieldEnum]


  export const SchoolLocationContactScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    hours: 'hours',
    fax: 'fax',
    email: 'email',
    url: 'url',
    locationId: 'locationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolLocationContactScalarFieldEnum = (typeof SchoolLocationContactScalarFieldEnum)[keyof typeof SchoolLocationContactScalarFieldEnum]


  export const SchoolProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    cover: 'cover',
    isPublished: 'isPublished',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolProgramScalarFieldEnum = (typeof SchoolProgramScalarFieldEnum)[keyof typeof SchoolProgramScalarFieldEnum]


  export const SchoolProgramImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    programId: 'programId'
  };

  export type SchoolProgramImageScalarFieldEnum = (typeof SchoolProgramImageScalarFieldEnum)[keyof typeof SchoolProgramImageScalarFieldEnum]


  export const StudentSchoolProgramScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    programId: 'programId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentSchoolProgramScalarFieldEnum = (typeof StudentSchoolProgramScalarFieldEnum)[keyof typeof StudentSchoolProgramScalarFieldEnum]


  export const StudentSchoolLocationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    locationId: 'locationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentSchoolLocationScalarFieldEnum = (typeof StudentSchoolLocationScalarFieldEnum)[keyof typeof StudentSchoolLocationScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    studentCode: 'studentCode',
    degreeType: 'degreeType',
    certificateType: 'certificateType',
    certificateImg: 'certificateImg',
    gradeType: 'gradeType',
    gradeScore: 'gradeScore',
    cover: 'cover',
    additional: 'additional',
    status: 'status',
    accountId: 'accountId',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    name: 'name',
    creatAt: 'creatAt',
    updateAt: 'updateAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createAt: 'createAt',
    updateAt: 'updateAt',
    studentCode: 'studentCode',
    chatId: 'chatId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    hostId: 'hostId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventProfileScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    profileId: 'profileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventProfileScalarFieldEnum = (typeof EventProfileScalarFieldEnum)[keyof typeof EventProfileScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    status: 'status',
    studentId: 'studentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const ProfileFriendScalarFieldEnum: {
    id: 'id',
    isActive: 'isActive',
    profileIdOne: 'profileIdOne',
    profileIdTwo: 'profileIdTwo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileFriendScalarFieldEnum = (typeof ProfileFriendScalarFieldEnum)[keyof typeof ProfileFriendScalarFieldEnum]


  export const AreaScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const ProfileBiographyScalarFieldEnum: {
    id: 'id',
    content: 'content',
    profileId: 'profileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileBiographyScalarFieldEnum = (typeof ProfileBiographyScalarFieldEnum)[keyof typeof ProfileBiographyScalarFieldEnum]


  export const ProfileBiographyAreaScalarFieldEnum: {
    id: 'id',
    biographyId: 'biographyId',
    areaId: 'areaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileBiographyAreaScalarFieldEnum = (typeof ProfileBiographyAreaScalarFieldEnum)[keyof typeof ProfileBiographyAreaScalarFieldEnum]


  export const ProfileBiographySocialScalarFieldEnum: {
    id: 'id',
    type: 'type',
    href: 'href',
    profileBiographyId: 'profileBiographyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileBiographySocialScalarFieldEnum = (typeof ProfileBiographySocialScalarFieldEnum)[keyof typeof ProfileBiographySocialScalarFieldEnum]


  export const ProfileBlogScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    profileId: 'profileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileBlogScalarFieldEnum = (typeof ProfileBlogScalarFieldEnum)[keyof typeof ProfileBlogScalarFieldEnum]


  export const ProfileBlogImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    profileBlogId: 'profileBlogId'
  };

  export type ProfileBlogImageScalarFieldEnum = (typeof ProfileBlogImageScalarFieldEnum)[keyof typeof ProfileBlogImageScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    content: 'content',
    status: 'status',
    isArchived: 'isArchived',
    profileId: 'profileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PostImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    postId: 'postId'
  };

  export type PostImageScalarFieldEnum = (typeof PostImageScalarFieldEnum)[keyof typeof PostImageScalarFieldEnum]


  export const PostLikeScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    postId: 'postId'
  };

  export type PostLikeScalarFieldEnum = (typeof PostLikeScalarFieldEnum)[keyof typeof PostLikeScalarFieldEnum]


  export const PostShareScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    postId: 'postId'
  };

  export type PostShareScalarFieldEnum = (typeof PostShareScalarFieldEnum)[keyof typeof PostShareScalarFieldEnum]


  export const PostSaveScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    postId: 'postId'
  };

  export type PostSaveScalarFieldEnum = (typeof PostSaveScalarFieldEnum)[keyof typeof PostSaveScalarFieldEnum]


  export const PostCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    image: 'image',
    isArchived: 'isArchived',
    profileId: 'profileId',
    postId: 'postId',
    parentCommentId: 'parentCommentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostCommentScalarFieldEnum = (typeof PostCommentScalarFieldEnum)[keyof typeof PostCommentScalarFieldEnum]


  export const PostCommentLikeScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    postCommentId: 'postCommentId'
  };

  export type PostCommentLikeScalarFieldEnum = (typeof PostCommentLikeScalarFieldEnum)[keyof typeof PostCommentLikeScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const ProfileGroupScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    groupId: 'groupId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileGroupScalarFieldEnum = (typeof ProfileGroupScalarFieldEnum)[keyof typeof ProfileGroupScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    type: 'type',
    cover: 'cover',
    isPublished: 'isPublished',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const NewsNotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    isRead: 'isRead',
    studentId: 'studentId',
    fromId: 'fromId',
    newsId: 'newsId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsNotificationScalarFieldEnum = (typeof NewsNotificationScalarFieldEnum)[keyof typeof NewsNotificationScalarFieldEnum]


  export const StudentFollowScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    followerId: 'followerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentFollowScalarFieldEnum = (typeof StudentFollowScalarFieldEnum)[keyof typeof StudentFollowScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    title: 'title',
    phone: 'phone',
    email: 'email',
    message: 'message',
    isRead: 'isRead',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Country'
   */
  export type EnumCountryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Country'>
    


  /**
   * Reference to a field of type 'Country[]'
   */
  export type ListEnumCountryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Country[]'>
    


  /**
   * Reference to a field of type 'DegreeType'
   */
  export type EnumDegreeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DegreeType'>
    


  /**
   * Reference to a field of type 'DegreeType[]'
   */
  export type ListEnumDegreeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DegreeType[]'>
    


  /**
   * Reference to a field of type 'CertificateType'
   */
  export type EnumCertificateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificateType'>
    


  /**
   * Reference to a field of type 'CertificateType[]'
   */
  export type ListEnumCertificateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificateType[]'>
    


  /**
   * Reference to a field of type 'GradeType'
   */
  export type EnumGradeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GradeType'>
    


  /**
   * Reference to a field of type 'GradeType[]'
   */
  export type ListEnumGradeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GradeType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'StudentStatus'
   */
  export type EnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus'>
    


  /**
   * Reference to a field of type 'StudentStatus[]'
   */
  export type ListEnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus[]'>
    


  /**
   * Reference to a field of type 'ProfileStatus'
   */
  export type EnumProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProfileStatus'>
    


  /**
   * Reference to a field of type 'ProfileStatus[]'
   */
  export type ListEnumProfileStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProfileStatus[]'>
    


  /**
   * Reference to a field of type 'SocialType'
   */
  export type EnumSocialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialType'>
    


  /**
   * Reference to a field of type 'SocialType[]'
   */
  export type ListEnumSocialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialType[]'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'NewsType'
   */
  export type EnumNewsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NewsType'>
    


  /**
   * Reference to a field of type 'NewsType[]'
   */
  export type ListEnumNewsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NewsType[]'>
    


  /**
   * Reference to a field of type 'ContactTitle'
   */
  export type EnumContactTitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactTitle'>
    


  /**
   * Reference to a field of type 'ContactTitle[]'
   */
  export type ListEnumContactTitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactTitle[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    email?: StringFilter<"Account"> | string
    emailVerified?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    dob?: DateTimeFilter<"Account"> | Date | string
    gender?: EnumGenderFilter<"Account"> | $Enums.Gender
    phoneNumber?: StringFilter<"Account"> | string
    idCardNumber?: StringFilter<"Account"> | string
    address?: StringFilter<"Account"> | string
    image?: StringNullableFilter<"Account"> | string | null
    isLocked?: BoolFilter<"Account"> | boolean
    isTwoFactorEnabled?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    twoFactorConfirmation?: XOR<TwoFactorConfirmationNullableRelationFilter, TwoFactorConfirmationWhereInput> | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrder
    name?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phoneNumber?: SortOrder
    idCardNumber?: SortOrder
    address?: SortOrder
    image?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    isTwoFactorEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorConfirmation?: TwoFactorConfirmationOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    idCardNumber?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    emailVerified?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    dob?: DateTimeFilter<"Account"> | Date | string
    gender?: EnumGenderFilter<"Account"> | $Enums.Gender
    phoneNumber?: StringFilter<"Account"> | string
    address?: StringFilter<"Account"> | string
    image?: StringNullableFilter<"Account"> | string | null
    isLocked?: BoolFilter<"Account"> | boolean
    isTwoFactorEnabled?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    twoFactorConfirmation?: XOR<TwoFactorConfirmationNullableRelationFilter, TwoFactorConfirmationWhereInput> | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }, "id" | "email" | "idCardNumber">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrder
    name?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phoneNumber?: SortOrder
    idCardNumber?: SortOrder
    address?: SortOrder
    image?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    isTwoFactorEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    email?: StringWithAggregatesFilter<"Account"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    password?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    dob?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    gender?: EnumGenderWithAggregatesFilter<"Account"> | $Enums.Gender
    phoneNumber?: StringWithAggregatesFilter<"Account"> | string
    idCardNumber?: StringWithAggregatesFilter<"Account"> | string
    address?: StringWithAggregatesFilter<"Account"> | string
    image?: StringNullableWithAggregatesFilter<"Account"> | string | null
    isLocked?: BoolWithAggregatesFilter<"Account"> | boolean
    isTwoFactorEnabled?: BoolWithAggregatesFilter<"Account"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    email?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: VerificationTokenEmailTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    email?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    email?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: PasswordResetTokenEmailTokenCompoundUniqueInput
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type TwoFactorTokenWhereInput = {
    AND?: TwoFactorTokenWhereInput | TwoFactorTokenWhereInput[]
    OR?: TwoFactorTokenWhereInput[]
    NOT?: TwoFactorTokenWhereInput | TwoFactorTokenWhereInput[]
    id?: StringFilter<"TwoFactorToken"> | string
    email?: StringFilter<"TwoFactorToken"> | string
    token?: StringFilter<"TwoFactorToken"> | string
    expires?: DateTimeFilter<"TwoFactorToken"> | Date | string
    createdAt?: DateTimeFilter<"TwoFactorToken"> | Date | string
  }

  export type TwoFactorTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: TwoFactorTokenEmailTokenCompoundUniqueInput
    AND?: TwoFactorTokenWhereInput | TwoFactorTokenWhereInput[]
    OR?: TwoFactorTokenWhereInput[]
    NOT?: TwoFactorTokenWhereInput | TwoFactorTokenWhereInput[]
    email?: StringFilter<"TwoFactorToken"> | string
    expires?: DateTimeFilter<"TwoFactorToken"> | Date | string
    createdAt?: DateTimeFilter<"TwoFactorToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type TwoFactorTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    _count?: TwoFactorTokenCountOrderByAggregateInput
    _max?: TwoFactorTokenMaxOrderByAggregateInput
    _min?: TwoFactorTokenMinOrderByAggregateInput
  }

  export type TwoFactorTokenScalarWhereWithAggregatesInput = {
    AND?: TwoFactorTokenScalarWhereWithAggregatesInput | TwoFactorTokenScalarWhereWithAggregatesInput[]
    OR?: TwoFactorTokenScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorTokenScalarWhereWithAggregatesInput | TwoFactorTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwoFactorToken"> | string
    email?: StringWithAggregatesFilter<"TwoFactorToken"> | string
    token?: StringWithAggregatesFilter<"TwoFactorToken"> | string
    expires?: DateTimeWithAggregatesFilter<"TwoFactorToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TwoFactorToken"> | Date | string
  }

  export type TwoFactorConfirmationWhereInput = {
    AND?: TwoFactorConfirmationWhereInput | TwoFactorConfirmationWhereInput[]
    OR?: TwoFactorConfirmationWhereInput[]
    NOT?: TwoFactorConfirmationWhereInput | TwoFactorConfirmationWhereInput[]
    id?: StringFilter<"TwoFactorConfirmation"> | string
    accountId?: StringFilter<"TwoFactorConfirmation"> | string
    createdAt?: DateTimeFilter<"TwoFactorConfirmation"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorConfirmation"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type TwoFactorConfirmationOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type TwoFactorConfirmationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    AND?: TwoFactorConfirmationWhereInput | TwoFactorConfirmationWhereInput[]
    OR?: TwoFactorConfirmationWhereInput[]
    NOT?: TwoFactorConfirmationWhereInput | TwoFactorConfirmationWhereInput[]
    createdAt?: DateTimeFilter<"TwoFactorConfirmation"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorConfirmation"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id" | "accountId">

  export type TwoFactorConfirmationOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwoFactorConfirmationCountOrderByAggregateInput
    _max?: TwoFactorConfirmationMaxOrderByAggregateInput
    _min?: TwoFactorConfirmationMinOrderByAggregateInput
  }

  export type TwoFactorConfirmationScalarWhereWithAggregatesInput = {
    AND?: TwoFactorConfirmationScalarWhereWithAggregatesInput | TwoFactorConfirmationScalarWhereWithAggregatesInput[]
    OR?: TwoFactorConfirmationScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorConfirmationScalarWhereWithAggregatesInput | TwoFactorConfirmationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwoFactorConfirmation"> | string
    accountId?: StringWithAggregatesFilter<"TwoFactorConfirmation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TwoFactorConfirmation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TwoFactorConfirmation"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    logo?: StringFilter<"School"> | string
    background?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    short?: StringNullableFilter<"School"> | string | null
    description?: StringNullableFilter<"School"> | string | null
    history?: StringNullableFilter<"School"> | string | null
    color?: StringFilter<"School"> | string
    isPublished?: BoolFilter<"School"> | boolean
    country?: EnumCountryFilter<"School"> | $Enums.Country
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    students?: StudentListRelationFilter
    locations?: SchoolLocationListRelationFilter
    programs?: SchoolProgramListRelationFilter
    galleries?: SchoolGalleryListRelationFilter
    scholarships?: SchoolScholarshipListRelationFilter
    news?: NewsListRelationFilter
    contacts?: ContactListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    logo?: SortOrder
    background?: SortOrder
    name?: SortOrder
    short?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    color?: SortOrder
    isPublished?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    students?: StudentOrderByRelationAggregateInput
    locations?: SchoolLocationOrderByRelationAggregateInput
    programs?: SchoolProgramOrderByRelationAggregateInput
    galleries?: SchoolGalleryOrderByRelationAggregateInput
    scholarships?: SchoolScholarshipOrderByRelationAggregateInput
    news?: NewsOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    logo?: StringFilter<"School"> | string
    background?: StringFilter<"School"> | string
    short?: StringNullableFilter<"School"> | string | null
    description?: StringNullableFilter<"School"> | string | null
    history?: StringNullableFilter<"School"> | string | null
    color?: StringFilter<"School"> | string
    isPublished?: BoolFilter<"School"> | boolean
    country?: EnumCountryFilter<"School"> | $Enums.Country
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    students?: StudentListRelationFilter
    locations?: SchoolLocationListRelationFilter
    programs?: SchoolProgramListRelationFilter
    galleries?: SchoolGalleryListRelationFilter
    scholarships?: SchoolScholarshipListRelationFilter
    news?: NewsListRelationFilter
    contacts?: ContactListRelationFilter
  }, "id" | "name">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    logo?: SortOrder
    background?: SortOrder
    name?: SortOrder
    short?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    color?: SortOrder
    isPublished?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    logo?: StringWithAggregatesFilter<"School"> | string
    background?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    short?: StringNullableWithAggregatesFilter<"School"> | string | null
    description?: StringNullableWithAggregatesFilter<"School"> | string | null
    history?: StringNullableWithAggregatesFilter<"School"> | string | null
    color?: StringWithAggregatesFilter<"School"> | string
    isPublished?: BoolWithAggregatesFilter<"School"> | boolean
    country?: EnumCountryWithAggregatesFilter<"School"> | $Enums.Country
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type SchoolScholarshipWhereInput = {
    AND?: SchoolScholarshipWhereInput | SchoolScholarshipWhereInput[]
    OR?: SchoolScholarshipWhereInput[]
    NOT?: SchoolScholarshipWhereInput | SchoolScholarshipWhereInput[]
    id?: StringFilter<"SchoolScholarship"> | string
    name?: StringFilter<"SchoolScholarship"> | string
    description?: StringFilter<"SchoolScholarship"> | string
    cover?: StringNullableFilter<"SchoolScholarship"> | string | null
    isPublished?: BoolFilter<"SchoolScholarship"> | boolean
    schoolId?: StringFilter<"SchoolScholarship"> | string
    createdAt?: DateTimeFilter<"SchoolScholarship"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolScholarship"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    owners?: StudentSchoolScholarshipListRelationFilter
    images?: SchoolScholarshipImageListRelationFilter
  }

  export type SchoolScholarshipOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    owners?: StudentSchoolScholarshipOrderByRelationAggregateInput
    images?: SchoolScholarshipImageOrderByRelationAggregateInput
  }

  export type SchoolScholarshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: SchoolScholarshipSchoolIdNameCompoundUniqueInput
    AND?: SchoolScholarshipWhereInput | SchoolScholarshipWhereInput[]
    OR?: SchoolScholarshipWhereInput[]
    NOT?: SchoolScholarshipWhereInput | SchoolScholarshipWhereInput[]
    name?: StringFilter<"SchoolScholarship"> | string
    description?: StringFilter<"SchoolScholarship"> | string
    cover?: StringNullableFilter<"SchoolScholarship"> | string | null
    isPublished?: BoolFilter<"SchoolScholarship"> | boolean
    schoolId?: StringFilter<"SchoolScholarship"> | string
    createdAt?: DateTimeFilter<"SchoolScholarship"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolScholarship"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    owners?: StudentSchoolScholarshipListRelationFilter
    images?: SchoolScholarshipImageListRelationFilter
  }, "id" | "schoolId_name">

  export type SchoolScholarshipOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolScholarshipCountOrderByAggregateInput
    _max?: SchoolScholarshipMaxOrderByAggregateInput
    _min?: SchoolScholarshipMinOrderByAggregateInput
  }

  export type SchoolScholarshipScalarWhereWithAggregatesInput = {
    AND?: SchoolScholarshipScalarWhereWithAggregatesInput | SchoolScholarshipScalarWhereWithAggregatesInput[]
    OR?: SchoolScholarshipScalarWhereWithAggregatesInput[]
    NOT?: SchoolScholarshipScalarWhereWithAggregatesInput | SchoolScholarshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolScholarship"> | string
    name?: StringWithAggregatesFilter<"SchoolScholarship"> | string
    description?: StringWithAggregatesFilter<"SchoolScholarship"> | string
    cover?: StringNullableWithAggregatesFilter<"SchoolScholarship"> | string | null
    isPublished?: BoolWithAggregatesFilter<"SchoolScholarship"> | boolean
    schoolId?: StringWithAggregatesFilter<"SchoolScholarship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SchoolScholarship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolScholarship"> | Date | string
  }

  export type SchoolScholarshipImageWhereInput = {
    AND?: SchoolScholarshipImageWhereInput | SchoolScholarshipImageWhereInput[]
    OR?: SchoolScholarshipImageWhereInput[]
    NOT?: SchoolScholarshipImageWhereInput | SchoolScholarshipImageWhereInput[]
    id?: StringFilter<"SchoolScholarshipImage"> | string
    url?: StringFilter<"SchoolScholarshipImage"> | string
    scholarshipId?: StringFilter<"SchoolScholarshipImage"> | string
    scholarship?: XOR<SchoolScholarshipRelationFilter, SchoolScholarshipWhereInput>
  }

  export type SchoolScholarshipImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    scholarshipId?: SortOrder
    scholarship?: SchoolScholarshipOrderByWithRelationInput
  }

  export type SchoolScholarshipImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolScholarshipImageWhereInput | SchoolScholarshipImageWhereInput[]
    OR?: SchoolScholarshipImageWhereInput[]
    NOT?: SchoolScholarshipImageWhereInput | SchoolScholarshipImageWhereInput[]
    url?: StringFilter<"SchoolScholarshipImage"> | string
    scholarshipId?: StringFilter<"SchoolScholarshipImage"> | string
    scholarship?: XOR<SchoolScholarshipRelationFilter, SchoolScholarshipWhereInput>
  }, "id">

  export type SchoolScholarshipImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    scholarshipId?: SortOrder
    _count?: SchoolScholarshipImageCountOrderByAggregateInput
    _max?: SchoolScholarshipImageMaxOrderByAggregateInput
    _min?: SchoolScholarshipImageMinOrderByAggregateInput
  }

  export type SchoolScholarshipImageScalarWhereWithAggregatesInput = {
    AND?: SchoolScholarshipImageScalarWhereWithAggregatesInput | SchoolScholarshipImageScalarWhereWithAggregatesInput[]
    OR?: SchoolScholarshipImageScalarWhereWithAggregatesInput[]
    NOT?: SchoolScholarshipImageScalarWhereWithAggregatesInput | SchoolScholarshipImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolScholarshipImage"> | string
    url?: StringWithAggregatesFilter<"SchoolScholarshipImage"> | string
    scholarshipId?: StringWithAggregatesFilter<"SchoolScholarshipImage"> | string
  }

  export type StudentSchoolScholarshipWhereInput = {
    AND?: StudentSchoolScholarshipWhereInput | StudentSchoolScholarshipWhereInput[]
    OR?: StudentSchoolScholarshipWhereInput[]
    NOT?: StudentSchoolScholarshipWhereInput | StudentSchoolScholarshipWhereInput[]
    id?: StringFilter<"StudentSchoolScholarship"> | string
    studentId?: StringFilter<"StudentSchoolScholarship"> | string
    scholarshipId?: StringFilter<"StudentSchoolScholarship"> | string
    createdAt?: DateTimeFilter<"StudentSchoolScholarship"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSchoolScholarship"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    scholarship?: XOR<SchoolScholarshipRelationFilter, SchoolScholarshipWhereInput>
  }

  export type StudentSchoolScholarshipOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    scholarshipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    scholarship?: SchoolScholarshipOrderByWithRelationInput
  }

  export type StudentSchoolScholarshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    studentId_scholarshipId?: StudentSchoolScholarshipStudentIdScholarshipIdCompoundUniqueInput
    AND?: StudentSchoolScholarshipWhereInput | StudentSchoolScholarshipWhereInput[]
    OR?: StudentSchoolScholarshipWhereInput[]
    NOT?: StudentSchoolScholarshipWhereInput | StudentSchoolScholarshipWhereInput[]
    scholarshipId?: StringFilter<"StudentSchoolScholarship"> | string
    createdAt?: DateTimeFilter<"StudentSchoolScholarship"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSchoolScholarship"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    scholarship?: XOR<SchoolScholarshipRelationFilter, SchoolScholarshipWhereInput>
  }, "id" | "studentId" | "studentId_scholarshipId">

  export type StudentSchoolScholarshipOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    scholarshipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentSchoolScholarshipCountOrderByAggregateInput
    _max?: StudentSchoolScholarshipMaxOrderByAggregateInput
    _min?: StudentSchoolScholarshipMinOrderByAggregateInput
  }

  export type StudentSchoolScholarshipScalarWhereWithAggregatesInput = {
    AND?: StudentSchoolScholarshipScalarWhereWithAggregatesInput | StudentSchoolScholarshipScalarWhereWithAggregatesInput[]
    OR?: StudentSchoolScholarshipScalarWhereWithAggregatesInput[]
    NOT?: StudentSchoolScholarshipScalarWhereWithAggregatesInput | StudentSchoolScholarshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSchoolScholarship"> | string
    studentId?: StringWithAggregatesFilter<"StudentSchoolScholarship"> | string
    scholarshipId?: StringWithAggregatesFilter<"StudentSchoolScholarship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSchoolScholarship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSchoolScholarship"> | Date | string
  }

  export type SchoolGalleryWhereInput = {
    AND?: SchoolGalleryWhereInput | SchoolGalleryWhereInput[]
    OR?: SchoolGalleryWhereInput[]
    NOT?: SchoolGalleryWhereInput | SchoolGalleryWhereInput[]
    id?: StringFilter<"SchoolGallery"> | string
    name?: StringFilter<"SchoolGallery"> | string
    description?: StringNullableFilter<"SchoolGallery"> | string | null
    schoolId?: StringFilter<"SchoolGallery"> | string
    createdAt?: DateTimeFilter<"SchoolGallery"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolGallery"> | Date | string
    images?: SchoolGalleryImageListRelationFilter
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type SchoolGalleryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: SchoolGalleryImageOrderByRelationAggregateInput
    school?: SchoolOrderByWithRelationInput
  }

  export type SchoolGalleryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolGalleryWhereInput | SchoolGalleryWhereInput[]
    OR?: SchoolGalleryWhereInput[]
    NOT?: SchoolGalleryWhereInput | SchoolGalleryWhereInput[]
    name?: StringFilter<"SchoolGallery"> | string
    description?: StringNullableFilter<"SchoolGallery"> | string | null
    schoolId?: StringFilter<"SchoolGallery"> | string
    createdAt?: DateTimeFilter<"SchoolGallery"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolGallery"> | Date | string
    images?: SchoolGalleryImageListRelationFilter
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type SchoolGalleryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolGalleryCountOrderByAggregateInput
    _max?: SchoolGalleryMaxOrderByAggregateInput
    _min?: SchoolGalleryMinOrderByAggregateInput
  }

  export type SchoolGalleryScalarWhereWithAggregatesInput = {
    AND?: SchoolGalleryScalarWhereWithAggregatesInput | SchoolGalleryScalarWhereWithAggregatesInput[]
    OR?: SchoolGalleryScalarWhereWithAggregatesInput[]
    NOT?: SchoolGalleryScalarWhereWithAggregatesInput | SchoolGalleryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolGallery"> | string
    name?: StringWithAggregatesFilter<"SchoolGallery"> | string
    description?: StringNullableWithAggregatesFilter<"SchoolGallery"> | string | null
    schoolId?: StringWithAggregatesFilter<"SchoolGallery"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SchoolGallery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolGallery"> | Date | string
  }

  export type SchoolGalleryImageWhereInput = {
    AND?: SchoolGalleryImageWhereInput | SchoolGalleryImageWhereInput[]
    OR?: SchoolGalleryImageWhereInput[]
    NOT?: SchoolGalleryImageWhereInput | SchoolGalleryImageWhereInput[]
    id?: StringFilter<"SchoolGalleryImage"> | string
    url?: StringFilter<"SchoolGalleryImage"> | string
    galleryId?: StringFilter<"SchoolGalleryImage"> | string
    gallery?: XOR<SchoolGalleryRelationFilter, SchoolGalleryWhereInput>
  }

  export type SchoolGalleryImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    galleryId?: SortOrder
    gallery?: SchoolGalleryOrderByWithRelationInput
  }

  export type SchoolGalleryImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolGalleryImageWhereInput | SchoolGalleryImageWhereInput[]
    OR?: SchoolGalleryImageWhereInput[]
    NOT?: SchoolGalleryImageWhereInput | SchoolGalleryImageWhereInput[]
    url?: StringFilter<"SchoolGalleryImage"> | string
    galleryId?: StringFilter<"SchoolGalleryImage"> | string
    gallery?: XOR<SchoolGalleryRelationFilter, SchoolGalleryWhereInput>
  }, "id">

  export type SchoolGalleryImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    galleryId?: SortOrder
    _count?: SchoolGalleryImageCountOrderByAggregateInput
    _max?: SchoolGalleryImageMaxOrderByAggregateInput
    _min?: SchoolGalleryImageMinOrderByAggregateInput
  }

  export type SchoolGalleryImageScalarWhereWithAggregatesInput = {
    AND?: SchoolGalleryImageScalarWhereWithAggregatesInput | SchoolGalleryImageScalarWhereWithAggregatesInput[]
    OR?: SchoolGalleryImageScalarWhereWithAggregatesInput[]
    NOT?: SchoolGalleryImageScalarWhereWithAggregatesInput | SchoolGalleryImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolGalleryImage"> | string
    url?: StringWithAggregatesFilter<"SchoolGalleryImage"> | string
    galleryId?: StringWithAggregatesFilter<"SchoolGalleryImage"> | string
  }

  export type SchoolLocationWhereInput = {
    AND?: SchoolLocationWhereInput | SchoolLocationWhereInput[]
    OR?: SchoolLocationWhereInput[]
    NOT?: SchoolLocationWhereInput | SchoolLocationWhereInput[]
    id?: StringFilter<"SchoolLocation"> | string
    cover?: StringNullableFilter<"SchoolLocation"> | string | null
    name?: StringFilter<"SchoolLocation"> | string
    address?: StringFilter<"SchoolLocation"> | string
    isMain?: BoolFilter<"SchoolLocation"> | boolean
    schoolId?: StringFilter<"SchoolLocation"> | string
    createdAt?: DateTimeFilter<"SchoolLocation"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolLocation"> | Date | string
    images?: SchoolLocationImageListRelationFilter
    contacts?: SchoolLocationContactListRelationFilter
    students?: StudentSchoolLocationListRelationFilter
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type SchoolLocationOrderByWithRelationInput = {
    id?: SortOrder
    cover?: SortOrderInput | SortOrder
    name?: SortOrder
    address?: SortOrder
    isMain?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: SchoolLocationImageOrderByRelationAggregateInput
    contacts?: SchoolLocationContactOrderByRelationAggregateInput
    students?: StudentSchoolLocationOrderByRelationAggregateInput
    school?: SchoolOrderByWithRelationInput
  }

  export type SchoolLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    address?: string
    AND?: SchoolLocationWhereInput | SchoolLocationWhereInput[]
    OR?: SchoolLocationWhereInput[]
    NOT?: SchoolLocationWhereInput | SchoolLocationWhereInput[]
    cover?: StringNullableFilter<"SchoolLocation"> | string | null
    isMain?: BoolFilter<"SchoolLocation"> | boolean
    schoolId?: StringFilter<"SchoolLocation"> | string
    createdAt?: DateTimeFilter<"SchoolLocation"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolLocation"> | Date | string
    images?: SchoolLocationImageListRelationFilter
    contacts?: SchoolLocationContactListRelationFilter
    students?: StudentSchoolLocationListRelationFilter
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id" | "name" | "address">

  export type SchoolLocationOrderByWithAggregationInput = {
    id?: SortOrder
    cover?: SortOrderInput | SortOrder
    name?: SortOrder
    address?: SortOrder
    isMain?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolLocationCountOrderByAggregateInput
    _max?: SchoolLocationMaxOrderByAggregateInput
    _min?: SchoolLocationMinOrderByAggregateInput
  }

  export type SchoolLocationScalarWhereWithAggregatesInput = {
    AND?: SchoolLocationScalarWhereWithAggregatesInput | SchoolLocationScalarWhereWithAggregatesInput[]
    OR?: SchoolLocationScalarWhereWithAggregatesInput[]
    NOT?: SchoolLocationScalarWhereWithAggregatesInput | SchoolLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolLocation"> | string
    cover?: StringNullableWithAggregatesFilter<"SchoolLocation"> | string | null
    name?: StringWithAggregatesFilter<"SchoolLocation"> | string
    address?: StringWithAggregatesFilter<"SchoolLocation"> | string
    isMain?: BoolWithAggregatesFilter<"SchoolLocation"> | boolean
    schoolId?: StringWithAggregatesFilter<"SchoolLocation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SchoolLocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolLocation"> | Date | string
  }

  export type SchoolLocationImageWhereInput = {
    AND?: SchoolLocationImageWhereInput | SchoolLocationImageWhereInput[]
    OR?: SchoolLocationImageWhereInput[]
    NOT?: SchoolLocationImageWhereInput | SchoolLocationImageWhereInput[]
    id?: StringFilter<"SchoolLocationImage"> | string
    url?: StringFilter<"SchoolLocationImage"> | string
    locationId?: StringFilter<"SchoolLocationImage"> | string
    location?: XOR<SchoolLocationRelationFilter, SchoolLocationWhereInput>
  }

  export type SchoolLocationImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    locationId?: SortOrder
    location?: SchoolLocationOrderByWithRelationInput
  }

  export type SchoolLocationImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolLocationImageWhereInput | SchoolLocationImageWhereInput[]
    OR?: SchoolLocationImageWhereInput[]
    NOT?: SchoolLocationImageWhereInput | SchoolLocationImageWhereInput[]
    url?: StringFilter<"SchoolLocationImage"> | string
    locationId?: StringFilter<"SchoolLocationImage"> | string
    location?: XOR<SchoolLocationRelationFilter, SchoolLocationWhereInput>
  }, "id">

  export type SchoolLocationImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    locationId?: SortOrder
    _count?: SchoolLocationImageCountOrderByAggregateInput
    _max?: SchoolLocationImageMaxOrderByAggregateInput
    _min?: SchoolLocationImageMinOrderByAggregateInput
  }

  export type SchoolLocationImageScalarWhereWithAggregatesInput = {
    AND?: SchoolLocationImageScalarWhereWithAggregatesInput | SchoolLocationImageScalarWhereWithAggregatesInput[]
    OR?: SchoolLocationImageScalarWhereWithAggregatesInput[]
    NOT?: SchoolLocationImageScalarWhereWithAggregatesInput | SchoolLocationImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolLocationImage"> | string
    url?: StringWithAggregatesFilter<"SchoolLocationImage"> | string
    locationId?: StringWithAggregatesFilter<"SchoolLocationImage"> | string
  }

  export type SchoolLocationContactWhereInput = {
    AND?: SchoolLocationContactWhereInput | SchoolLocationContactWhereInput[]
    OR?: SchoolLocationContactWhereInput[]
    NOT?: SchoolLocationContactWhereInput | SchoolLocationContactWhereInput[]
    id?: StringFilter<"SchoolLocationContact"> | string
    phone?: StringNullableFilter<"SchoolLocationContact"> | string | null
    hours?: StringNullableFilter<"SchoolLocationContact"> | string | null
    fax?: StringNullableFilter<"SchoolLocationContact"> | string | null
    email?: StringNullableFilter<"SchoolLocationContact"> | string | null
    url?: StringNullableFilter<"SchoolLocationContact"> | string | null
    locationId?: StringFilter<"SchoolLocationContact"> | string
    createdAt?: DateTimeFilter<"SchoolLocationContact"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolLocationContact"> | Date | string
    location?: XOR<SchoolLocationRelationFilter, SchoolLocationWhereInput>
  }

  export type SchoolLocationContactOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SchoolLocationOrderByWithRelationInput
  }

  export type SchoolLocationContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolLocationContactWhereInput | SchoolLocationContactWhereInput[]
    OR?: SchoolLocationContactWhereInput[]
    NOT?: SchoolLocationContactWhereInput | SchoolLocationContactWhereInput[]
    phone?: StringNullableFilter<"SchoolLocationContact"> | string | null
    hours?: StringNullableFilter<"SchoolLocationContact"> | string | null
    fax?: StringNullableFilter<"SchoolLocationContact"> | string | null
    email?: StringNullableFilter<"SchoolLocationContact"> | string | null
    url?: StringNullableFilter<"SchoolLocationContact"> | string | null
    locationId?: StringFilter<"SchoolLocationContact"> | string
    createdAt?: DateTimeFilter<"SchoolLocationContact"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolLocationContact"> | Date | string
    location?: XOR<SchoolLocationRelationFilter, SchoolLocationWhereInput>
  }, "id">

  export type SchoolLocationContactOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolLocationContactCountOrderByAggregateInput
    _max?: SchoolLocationContactMaxOrderByAggregateInput
    _min?: SchoolLocationContactMinOrderByAggregateInput
  }

  export type SchoolLocationContactScalarWhereWithAggregatesInput = {
    AND?: SchoolLocationContactScalarWhereWithAggregatesInput | SchoolLocationContactScalarWhereWithAggregatesInput[]
    OR?: SchoolLocationContactScalarWhereWithAggregatesInput[]
    NOT?: SchoolLocationContactScalarWhereWithAggregatesInput | SchoolLocationContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolLocationContact"> | string
    phone?: StringNullableWithAggregatesFilter<"SchoolLocationContact"> | string | null
    hours?: StringNullableWithAggregatesFilter<"SchoolLocationContact"> | string | null
    fax?: StringNullableWithAggregatesFilter<"SchoolLocationContact"> | string | null
    email?: StringNullableWithAggregatesFilter<"SchoolLocationContact"> | string | null
    url?: StringNullableWithAggregatesFilter<"SchoolLocationContact"> | string | null
    locationId?: StringWithAggregatesFilter<"SchoolLocationContact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SchoolLocationContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolLocationContact"> | Date | string
  }

  export type SchoolProgramWhereInput = {
    AND?: SchoolProgramWhereInput | SchoolProgramWhereInput[]
    OR?: SchoolProgramWhereInput[]
    NOT?: SchoolProgramWhereInput | SchoolProgramWhereInput[]
    id?: StringFilter<"SchoolProgram"> | string
    name?: StringFilter<"SchoolProgram"> | string
    description?: StringFilter<"SchoolProgram"> | string
    cover?: StringNullableFilter<"SchoolProgram"> | string | null
    isPublished?: BoolFilter<"SchoolProgram"> | boolean
    schoolId?: StringFilter<"SchoolProgram"> | string
    createdAt?: DateTimeFilter<"SchoolProgram"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolProgram"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    studentPrograms?: StudentSchoolProgramListRelationFilter
    images?: SchoolProgramImageListRelationFilter
  }

  export type SchoolProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    studentPrograms?: StudentSchoolProgramOrderByRelationAggregateInput
    images?: SchoolProgramImageOrderByRelationAggregateInput
  }

  export type SchoolProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: SchoolProgramSchoolIdNameCompoundUniqueInput
    AND?: SchoolProgramWhereInput | SchoolProgramWhereInput[]
    OR?: SchoolProgramWhereInput[]
    NOT?: SchoolProgramWhereInput | SchoolProgramWhereInput[]
    name?: StringFilter<"SchoolProgram"> | string
    description?: StringFilter<"SchoolProgram"> | string
    cover?: StringNullableFilter<"SchoolProgram"> | string | null
    isPublished?: BoolFilter<"SchoolProgram"> | boolean
    schoolId?: StringFilter<"SchoolProgram"> | string
    createdAt?: DateTimeFilter<"SchoolProgram"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolProgram"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    studentPrograms?: StudentSchoolProgramListRelationFilter
    images?: SchoolProgramImageListRelationFilter
  }, "id" | "schoolId_name">

  export type SchoolProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolProgramCountOrderByAggregateInput
    _max?: SchoolProgramMaxOrderByAggregateInput
    _min?: SchoolProgramMinOrderByAggregateInput
  }

  export type SchoolProgramScalarWhereWithAggregatesInput = {
    AND?: SchoolProgramScalarWhereWithAggregatesInput | SchoolProgramScalarWhereWithAggregatesInput[]
    OR?: SchoolProgramScalarWhereWithAggregatesInput[]
    NOT?: SchoolProgramScalarWhereWithAggregatesInput | SchoolProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolProgram"> | string
    name?: StringWithAggregatesFilter<"SchoolProgram"> | string
    description?: StringWithAggregatesFilter<"SchoolProgram"> | string
    cover?: StringNullableWithAggregatesFilter<"SchoolProgram"> | string | null
    isPublished?: BoolWithAggregatesFilter<"SchoolProgram"> | boolean
    schoolId?: StringWithAggregatesFilter<"SchoolProgram"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SchoolProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolProgram"> | Date | string
  }

  export type SchoolProgramImageWhereInput = {
    AND?: SchoolProgramImageWhereInput | SchoolProgramImageWhereInput[]
    OR?: SchoolProgramImageWhereInput[]
    NOT?: SchoolProgramImageWhereInput | SchoolProgramImageWhereInput[]
    id?: StringFilter<"SchoolProgramImage"> | string
    url?: StringFilter<"SchoolProgramImage"> | string
    programId?: StringFilter<"SchoolProgramImage"> | string
    program?: XOR<SchoolProgramRelationFilter, SchoolProgramWhereInput>
  }

  export type SchoolProgramImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    programId?: SortOrder
    program?: SchoolProgramOrderByWithRelationInput
  }

  export type SchoolProgramImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolProgramImageWhereInput | SchoolProgramImageWhereInput[]
    OR?: SchoolProgramImageWhereInput[]
    NOT?: SchoolProgramImageWhereInput | SchoolProgramImageWhereInput[]
    url?: StringFilter<"SchoolProgramImage"> | string
    programId?: StringFilter<"SchoolProgramImage"> | string
    program?: XOR<SchoolProgramRelationFilter, SchoolProgramWhereInput>
  }, "id">

  export type SchoolProgramImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    programId?: SortOrder
    _count?: SchoolProgramImageCountOrderByAggregateInput
    _max?: SchoolProgramImageMaxOrderByAggregateInput
    _min?: SchoolProgramImageMinOrderByAggregateInput
  }

  export type SchoolProgramImageScalarWhereWithAggregatesInput = {
    AND?: SchoolProgramImageScalarWhereWithAggregatesInput | SchoolProgramImageScalarWhereWithAggregatesInput[]
    OR?: SchoolProgramImageScalarWhereWithAggregatesInput[]
    NOT?: SchoolProgramImageScalarWhereWithAggregatesInput | SchoolProgramImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolProgramImage"> | string
    url?: StringWithAggregatesFilter<"SchoolProgramImage"> | string
    programId?: StringWithAggregatesFilter<"SchoolProgramImage"> | string
  }

  export type StudentSchoolProgramWhereInput = {
    AND?: StudentSchoolProgramWhereInput | StudentSchoolProgramWhereInput[]
    OR?: StudentSchoolProgramWhereInput[]
    NOT?: StudentSchoolProgramWhereInput | StudentSchoolProgramWhereInput[]
    id?: StringFilter<"StudentSchoolProgram"> | string
    studentId?: StringFilter<"StudentSchoolProgram"> | string
    programId?: StringFilter<"StudentSchoolProgram"> | string
    createdAt?: DateTimeFilter<"StudentSchoolProgram"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSchoolProgram"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    program?: XOR<SchoolProgramRelationFilter, SchoolProgramWhereInput>
  }

  export type StudentSchoolProgramOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    program?: SchoolProgramOrderByWithRelationInput
  }

  export type StudentSchoolProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    studentId_programId?: StudentSchoolProgramStudentIdProgramIdCompoundUniqueInput
    AND?: StudentSchoolProgramWhereInput | StudentSchoolProgramWhereInput[]
    OR?: StudentSchoolProgramWhereInput[]
    NOT?: StudentSchoolProgramWhereInput | StudentSchoolProgramWhereInput[]
    programId?: StringFilter<"StudentSchoolProgram"> | string
    createdAt?: DateTimeFilter<"StudentSchoolProgram"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSchoolProgram"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    program?: XOR<SchoolProgramRelationFilter, SchoolProgramWhereInput>
  }, "id" | "studentId" | "studentId_programId">

  export type StudentSchoolProgramOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentSchoolProgramCountOrderByAggregateInput
    _max?: StudentSchoolProgramMaxOrderByAggregateInput
    _min?: StudentSchoolProgramMinOrderByAggregateInput
  }

  export type StudentSchoolProgramScalarWhereWithAggregatesInput = {
    AND?: StudentSchoolProgramScalarWhereWithAggregatesInput | StudentSchoolProgramScalarWhereWithAggregatesInput[]
    OR?: StudentSchoolProgramScalarWhereWithAggregatesInput[]
    NOT?: StudentSchoolProgramScalarWhereWithAggregatesInput | StudentSchoolProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSchoolProgram"> | string
    studentId?: StringWithAggregatesFilter<"StudentSchoolProgram"> | string
    programId?: StringWithAggregatesFilter<"StudentSchoolProgram"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSchoolProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSchoolProgram"> | Date | string
  }

  export type StudentSchoolLocationWhereInput = {
    AND?: StudentSchoolLocationWhereInput | StudentSchoolLocationWhereInput[]
    OR?: StudentSchoolLocationWhereInput[]
    NOT?: StudentSchoolLocationWhereInput | StudentSchoolLocationWhereInput[]
    id?: StringFilter<"StudentSchoolLocation"> | string
    studentId?: StringFilter<"StudentSchoolLocation"> | string
    locationId?: StringFilter<"StudentSchoolLocation"> | string
    createdAt?: DateTimeFilter<"StudentSchoolLocation"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSchoolLocation"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    location?: XOR<SchoolLocationRelationFilter, SchoolLocationWhereInput>
  }

  export type StudentSchoolLocationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    location?: SchoolLocationOrderByWithRelationInput
  }

  export type StudentSchoolLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    studentId_locationId?: StudentSchoolLocationStudentIdLocationIdCompoundUniqueInput
    AND?: StudentSchoolLocationWhereInput | StudentSchoolLocationWhereInput[]
    OR?: StudentSchoolLocationWhereInput[]
    NOT?: StudentSchoolLocationWhereInput | StudentSchoolLocationWhereInput[]
    locationId?: StringFilter<"StudentSchoolLocation"> | string
    createdAt?: DateTimeFilter<"StudentSchoolLocation"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSchoolLocation"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    location?: XOR<SchoolLocationRelationFilter, SchoolLocationWhereInput>
  }, "id" | "studentId" | "studentId_locationId">

  export type StudentSchoolLocationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentSchoolLocationCountOrderByAggregateInput
    _max?: StudentSchoolLocationMaxOrderByAggregateInput
    _min?: StudentSchoolLocationMinOrderByAggregateInput
  }

  export type StudentSchoolLocationScalarWhereWithAggregatesInput = {
    AND?: StudentSchoolLocationScalarWhereWithAggregatesInput | StudentSchoolLocationScalarWhereWithAggregatesInput[]
    OR?: StudentSchoolLocationScalarWhereWithAggregatesInput[]
    NOT?: StudentSchoolLocationScalarWhereWithAggregatesInput | StudentSchoolLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSchoolLocation"> | string
    studentId?: StringWithAggregatesFilter<"StudentSchoolLocation"> | string
    locationId?: StringWithAggregatesFilter<"StudentSchoolLocation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSchoolLocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSchoolLocation"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    studentCode?: StringNullableFilter<"Student"> | string | null
    degreeType?: EnumDegreeTypeFilter<"Student"> | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFilter<"Student"> | $Enums.CertificateType
    certificateImg?: StringFilter<"Student"> | string
    gradeType?: EnumGradeTypeFilter<"Student"> | $Enums.GradeType
    gradeScore?: FloatFilter<"Student"> | number
    cover?: StringNullableFilter<"Student"> | string | null
    additional?: StringNullableFilter<"Student"> | string | null
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    accountId?: StringFilter<"Student"> | string
    schoolId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    messeages?: MessageListRelationFilter
    chats?: ChatListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    program?: XOR<StudentSchoolProgramNullableRelationFilter, StudentSchoolProgramWhereInput> | null
    location?: XOR<StudentSchoolLocationNullableRelationFilter, StudentSchoolLocationWhereInput> | null
    scholarship?: StudentSchoolScholarshipListRelationFilter
    notifications?: NewsNotificationListRelationFilter
    ownedNotifications?: NewsNotificationListRelationFilter
    follows?: StudentFollowListRelationFilter
    followers?: StudentFollowListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    studentCode?: SortOrderInput | SortOrder
    degreeType?: SortOrder
    certificateType?: SortOrder
    certificateImg?: SortOrder
    gradeType?: SortOrder
    gradeScore?: SortOrder
    cover?: SortOrderInput | SortOrder
    additional?: SortOrderInput | SortOrder
    status?: SortOrder
    accountId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    messeages?: MessageOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
    program?: StudentSchoolProgramOrderByWithRelationInput
    location?: StudentSchoolLocationOrderByWithRelationInput
    scholarship?: StudentSchoolScholarshipOrderByRelationAggregateInput
    notifications?: NewsNotificationOrderByRelationAggregateInput
    ownedNotifications?: NewsNotificationOrderByRelationAggregateInput
    follows?: StudentFollowOrderByRelationAggregateInput
    followers?: StudentFollowOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentCode?: string
    accountId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    degreeType?: EnumDegreeTypeFilter<"Student"> | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFilter<"Student"> | $Enums.CertificateType
    certificateImg?: StringFilter<"Student"> | string
    gradeType?: EnumGradeTypeFilter<"Student"> | $Enums.GradeType
    gradeScore?: FloatFilter<"Student"> | number
    cover?: StringNullableFilter<"Student"> | string | null
    additional?: StringNullableFilter<"Student"> | string | null
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    schoolId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    messeages?: MessageListRelationFilter
    chats?: ChatListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    program?: XOR<StudentSchoolProgramNullableRelationFilter, StudentSchoolProgramWhereInput> | null
    location?: XOR<StudentSchoolLocationNullableRelationFilter, StudentSchoolLocationWhereInput> | null
    scholarship?: StudentSchoolScholarshipListRelationFilter
    notifications?: NewsNotificationListRelationFilter
    ownedNotifications?: NewsNotificationListRelationFilter
    follows?: StudentFollowListRelationFilter
    followers?: StudentFollowListRelationFilter
  }, "id" | "studentCode" | "accountId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    studentCode?: SortOrderInput | SortOrder
    degreeType?: SortOrder
    certificateType?: SortOrder
    certificateImg?: SortOrder
    gradeType?: SortOrder
    gradeScore?: SortOrder
    cover?: SortOrderInput | SortOrder
    additional?: SortOrderInput | SortOrder
    status?: SortOrder
    accountId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    studentCode?: StringNullableWithAggregatesFilter<"Student"> | string | null
    degreeType?: EnumDegreeTypeWithAggregatesFilter<"Student"> | $Enums.DegreeType
    certificateType?: EnumCertificateTypeWithAggregatesFilter<"Student"> | $Enums.CertificateType
    certificateImg?: StringWithAggregatesFilter<"Student"> | string
    gradeType?: EnumGradeTypeWithAggregatesFilter<"Student"> | $Enums.GradeType
    gradeScore?: FloatWithAggregatesFilter<"Student"> | number
    cover?: StringNullableWithAggregatesFilter<"Student"> | string | null
    additional?: StringNullableWithAggregatesFilter<"Student"> | string | null
    status?: EnumStudentStatusWithAggregatesFilter<"Student"> | $Enums.StudentStatus
    accountId?: StringWithAggregatesFilter<"Student"> | string
    schoolId?: StringWithAggregatesFilter<"Student"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
    creatAt?: DateTimeFilter<"Chat"> | Date | string
    updateAt?: DateTimeFilter<"Chat"> | Date | string
    messeges?: MessageListRelationFilter
    students?: StudentListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    creatAt?: SortOrder
    updateAt?: SortOrder
    messeges?: MessageOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    creatAt?: DateTimeFilter<"Chat"> | Date | string
    updateAt?: DateTimeFilter<"Chat"> | Date | string
    messeges?: MessageListRelationFilter
    students?: StudentListRelationFilter
  }, "id" | "name">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    creatAt?: SortOrder
    updateAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    name?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    creatAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createAt?: DateTimeFilter<"Message"> | Date | string
    updateAt?: DateTimeFilter<"Message"> | Date | string
    studentCode?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    studentCode?: SortOrder
    chatId?: SortOrder
    student?: StudentOrderByWithRelationInput
    chat?: ChatOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    createAt?: DateTimeFilter<"Message"> | Date | string
    updateAt?: DateTimeFilter<"Message"> | Date | string
    studentCode?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    studentCode?: SortOrder
    chatId?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    createAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    studentCode?: StringWithAggregatesFilter<"Message"> | string
    chatId?: StringWithAggregatesFilter<"Message"> | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    hostId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    host?: XOR<ProfileRelationFilter, ProfileWhereInput>
    participants?: EventProfileListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    host?: ProfileOrderByWithRelationInput
    participants?: EventProfileOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hostId?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    host?: XOR<ProfileRelationFilter, ProfileWhereInput>
    participants?: EventProfileListRelationFilter
  }, "id" | "hostId">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    hostId?: StringWithAggregatesFilter<"Event"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventProfileWhereInput = {
    AND?: EventProfileWhereInput | EventProfileWhereInput[]
    OR?: EventProfileWhereInput[]
    NOT?: EventProfileWhereInput | EventProfileWhereInput[]
    id?: StringFilter<"EventProfile"> | string
    eventId?: StringFilter<"EventProfile"> | string
    profileId?: StringFilter<"EventProfile"> | string
    createdAt?: DateTimeFilter<"EventProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EventProfile"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type EventProfileOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type EventProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_profileId?: EventProfileEventIdProfileIdCompoundUniqueInput
    AND?: EventProfileWhereInput | EventProfileWhereInput[]
    OR?: EventProfileWhereInput[]
    NOT?: EventProfileWhereInput | EventProfileWhereInput[]
    eventId?: StringFilter<"EventProfile"> | string
    profileId?: StringFilter<"EventProfile"> | string
    createdAt?: DateTimeFilter<"EventProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EventProfile"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "id" | "eventId_profileId">

  export type EventProfileOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventProfileCountOrderByAggregateInput
    _max?: EventProfileMaxOrderByAggregateInput
    _min?: EventProfileMinOrderByAggregateInput
  }

  export type EventProfileScalarWhereWithAggregatesInput = {
    AND?: EventProfileScalarWhereWithAggregatesInput | EventProfileScalarWhereWithAggregatesInput[]
    OR?: EventProfileScalarWhereWithAggregatesInput[]
    NOT?: EventProfileScalarWhereWithAggregatesInput | EventProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventProfile"> | string
    eventId?: StringWithAggregatesFilter<"EventProfile"> | string
    profileId?: StringWithAggregatesFilter<"EventProfile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventProfile"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    status?: EnumProfileStatusFilter<"Profile"> | $Enums.ProfileStatus
    studentId?: StringFilter<"Profile"> | string
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    hostedEvents?: EventListRelationFilter
    participatedEvents?: EventProfileListRelationFilter
    posts?: PostListRelationFilter
    biography?: XOR<ProfileBiographyNullableRelationFilter, ProfileBiographyWhereInput> | null
    friendRequests?: ProfileFriendListRelationFilter
    friendReceived?: ProfileFriendListRelationFilter
    ownedGroups?: GroupListRelationFilter
    groups?: ProfileGroupListRelationFilter
    blogs?: ProfileBlogListRelationFilter
    postComments?: PostCommentListRelationFilter
    postCommentLikes?: PostCommentLikeListRelationFilter
    postLikes?: PostLikeListRelationFilter
    postShares?: PostShareListRelationFilter
    postSaved?: PostSaveListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    hostedEvents?: EventOrderByRelationAggregateInput
    participatedEvents?: EventProfileOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    biography?: ProfileBiographyOrderByWithRelationInput
    friendRequests?: ProfileFriendOrderByRelationAggregateInput
    friendReceived?: ProfileFriendOrderByRelationAggregateInput
    ownedGroups?: GroupOrderByRelationAggregateInput
    groups?: ProfileGroupOrderByRelationAggregateInput
    blogs?: ProfileBlogOrderByRelationAggregateInput
    postComments?: PostCommentOrderByRelationAggregateInput
    postCommentLikes?: PostCommentLikeOrderByRelationAggregateInput
    postLikes?: PostLikeOrderByRelationAggregateInput
    postShares?: PostShareOrderByRelationAggregateInput
    postSaved?: PostSaveOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    status?: EnumProfileStatusFilter<"Profile"> | $Enums.ProfileStatus
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    hostedEvents?: EventListRelationFilter
    participatedEvents?: EventProfileListRelationFilter
    posts?: PostListRelationFilter
    biography?: XOR<ProfileBiographyNullableRelationFilter, ProfileBiographyWhereInput> | null
    friendRequests?: ProfileFriendListRelationFilter
    friendReceived?: ProfileFriendListRelationFilter
    ownedGroups?: GroupListRelationFilter
    groups?: ProfileGroupListRelationFilter
    blogs?: ProfileBlogListRelationFilter
    postComments?: PostCommentListRelationFilter
    postCommentLikes?: PostCommentLikeListRelationFilter
    postLikes?: PostLikeListRelationFilter
    postShares?: PostShareListRelationFilter
    postSaved?: PostSaveListRelationFilter
  }, "id" | "studentId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    status?: EnumProfileStatusWithAggregatesFilter<"Profile"> | $Enums.ProfileStatus
    studentId?: StringWithAggregatesFilter<"Profile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type ProfileFriendWhereInput = {
    AND?: ProfileFriendWhereInput | ProfileFriendWhereInput[]
    OR?: ProfileFriendWhereInput[]
    NOT?: ProfileFriendWhereInput | ProfileFriendWhereInput[]
    id?: StringFilter<"ProfileFriend"> | string
    isActive?: BoolFilter<"ProfileFriend"> | boolean
    profileIdOne?: StringFilter<"ProfileFriend"> | string
    profileIdTwo?: StringFilter<"ProfileFriend"> | string
    createdAt?: DateTimeFilter<"ProfileFriend"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileFriend"> | Date | string
    profileOne?: XOR<ProfileRelationFilter, ProfileWhereInput>
    profileTwo?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type ProfileFriendOrderByWithRelationInput = {
    id?: SortOrder
    isActive?: SortOrder
    profileIdOne?: SortOrder
    profileIdTwo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileOne?: ProfileOrderByWithRelationInput
    profileTwo?: ProfileOrderByWithRelationInput
  }

  export type ProfileFriendWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileIdOne?: string
    profileIdTwo?: string
    AND?: ProfileFriendWhereInput | ProfileFriendWhereInput[]
    OR?: ProfileFriendWhereInput[]
    NOT?: ProfileFriendWhereInput | ProfileFriendWhereInput[]
    isActive?: BoolFilter<"ProfileFriend"> | boolean
    createdAt?: DateTimeFilter<"ProfileFriend"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileFriend"> | Date | string
    profileOne?: XOR<ProfileRelationFilter, ProfileWhereInput>
    profileTwo?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "id" | "profileIdOne" | "profileIdTwo">

  export type ProfileFriendOrderByWithAggregationInput = {
    id?: SortOrder
    isActive?: SortOrder
    profileIdOne?: SortOrder
    profileIdTwo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileFriendCountOrderByAggregateInput
    _max?: ProfileFriendMaxOrderByAggregateInput
    _min?: ProfileFriendMinOrderByAggregateInput
  }

  export type ProfileFriendScalarWhereWithAggregatesInput = {
    AND?: ProfileFriendScalarWhereWithAggregatesInput | ProfileFriendScalarWhereWithAggregatesInput[]
    OR?: ProfileFriendScalarWhereWithAggregatesInput[]
    NOT?: ProfileFriendScalarWhereWithAggregatesInput | ProfileFriendScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileFriend"> | string
    isActive?: BoolWithAggregatesFilter<"ProfileFriend"> | boolean
    profileIdOne?: StringWithAggregatesFilter<"ProfileFriend"> | string
    profileIdTwo?: StringWithAggregatesFilter<"ProfileFriend"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileFriend"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfileFriend"> | Date | string
  }

  export type AreaWhereInput = {
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    id?: StringFilter<"Area"> | string
    title?: StringFilter<"Area"> | string
    createdAt?: DateTimeFilter<"Area"> | Date | string
    updatedAt?: DateTimeFilter<"Area"> | Date | string
    biographies?: ProfileBiographyAreaListRelationFilter
  }

  export type AreaOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    biographies?: ProfileBiographyAreaOrderByRelationAggregateInput
  }

  export type AreaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    createdAt?: DateTimeFilter<"Area"> | Date | string
    updatedAt?: DateTimeFilter<"Area"> | Date | string
    biographies?: ProfileBiographyAreaListRelationFilter
  }, "id" | "title">

  export type AreaOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AreaCountOrderByAggregateInput
    _max?: AreaMaxOrderByAggregateInput
    _min?: AreaMinOrderByAggregateInput
  }

  export type AreaScalarWhereWithAggregatesInput = {
    AND?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    OR?: AreaScalarWhereWithAggregatesInput[]
    NOT?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Area"> | string
    title?: StringWithAggregatesFilter<"Area"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Area"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Area"> | Date | string
  }

  export type ProfileBiographyWhereInput = {
    AND?: ProfileBiographyWhereInput | ProfileBiographyWhereInput[]
    OR?: ProfileBiographyWhereInput[]
    NOT?: ProfileBiographyWhereInput | ProfileBiographyWhereInput[]
    id?: StringFilter<"ProfileBiography"> | string
    content?: StringFilter<"ProfileBiography"> | string
    profileId?: StringFilter<"ProfileBiography"> | string
    createdAt?: DateTimeFilter<"ProfileBiography"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBiography"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    areas?: ProfileBiographyAreaListRelationFilter
    socials?: ProfileBiographySocialListRelationFilter
  }

  export type ProfileBiographyOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    areas?: ProfileBiographyAreaOrderByRelationAggregateInput
    socials?: ProfileBiographySocialOrderByRelationAggregateInput
  }

  export type ProfileBiographyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId?: string
    AND?: ProfileBiographyWhereInput | ProfileBiographyWhereInput[]
    OR?: ProfileBiographyWhereInput[]
    NOT?: ProfileBiographyWhereInput | ProfileBiographyWhereInput[]
    content?: StringFilter<"ProfileBiography"> | string
    createdAt?: DateTimeFilter<"ProfileBiography"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBiography"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    areas?: ProfileBiographyAreaListRelationFilter
    socials?: ProfileBiographySocialListRelationFilter
  }, "id" | "profileId">

  export type ProfileBiographyOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileBiographyCountOrderByAggregateInput
    _max?: ProfileBiographyMaxOrderByAggregateInput
    _min?: ProfileBiographyMinOrderByAggregateInput
  }

  export type ProfileBiographyScalarWhereWithAggregatesInput = {
    AND?: ProfileBiographyScalarWhereWithAggregatesInput | ProfileBiographyScalarWhereWithAggregatesInput[]
    OR?: ProfileBiographyScalarWhereWithAggregatesInput[]
    NOT?: ProfileBiographyScalarWhereWithAggregatesInput | ProfileBiographyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileBiography"> | string
    content?: StringWithAggregatesFilter<"ProfileBiography"> | string
    profileId?: StringWithAggregatesFilter<"ProfileBiography"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileBiography"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfileBiography"> | Date | string
  }

  export type ProfileBiographyAreaWhereInput = {
    AND?: ProfileBiographyAreaWhereInput | ProfileBiographyAreaWhereInput[]
    OR?: ProfileBiographyAreaWhereInput[]
    NOT?: ProfileBiographyAreaWhereInput | ProfileBiographyAreaWhereInput[]
    id?: StringFilter<"ProfileBiographyArea"> | string
    biographyId?: StringFilter<"ProfileBiographyArea"> | string
    areaId?: StringFilter<"ProfileBiographyArea"> | string
    createdAt?: DateTimeFilter<"ProfileBiographyArea"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBiographyArea"> | Date | string
    biography?: XOR<ProfileBiographyRelationFilter, ProfileBiographyWhereInput>
    area?: XOR<AreaRelationFilter, AreaWhereInput>
  }

  export type ProfileBiographyAreaOrderByWithRelationInput = {
    id?: SortOrder
    biographyId?: SortOrder
    areaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    biography?: ProfileBiographyOrderByWithRelationInput
    area?: AreaOrderByWithRelationInput
  }

  export type ProfileBiographyAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    biographyId_areaId?: ProfileBiographyAreaBiographyIdAreaIdCompoundUniqueInput
    AND?: ProfileBiographyAreaWhereInput | ProfileBiographyAreaWhereInput[]
    OR?: ProfileBiographyAreaWhereInput[]
    NOT?: ProfileBiographyAreaWhereInput | ProfileBiographyAreaWhereInput[]
    biographyId?: StringFilter<"ProfileBiographyArea"> | string
    areaId?: StringFilter<"ProfileBiographyArea"> | string
    createdAt?: DateTimeFilter<"ProfileBiographyArea"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBiographyArea"> | Date | string
    biography?: XOR<ProfileBiographyRelationFilter, ProfileBiographyWhereInput>
    area?: XOR<AreaRelationFilter, AreaWhereInput>
  }, "id" | "biographyId_areaId">

  export type ProfileBiographyAreaOrderByWithAggregationInput = {
    id?: SortOrder
    biographyId?: SortOrder
    areaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileBiographyAreaCountOrderByAggregateInput
    _max?: ProfileBiographyAreaMaxOrderByAggregateInput
    _min?: ProfileBiographyAreaMinOrderByAggregateInput
  }

  export type ProfileBiographyAreaScalarWhereWithAggregatesInput = {
    AND?: ProfileBiographyAreaScalarWhereWithAggregatesInput | ProfileBiographyAreaScalarWhereWithAggregatesInput[]
    OR?: ProfileBiographyAreaScalarWhereWithAggregatesInput[]
    NOT?: ProfileBiographyAreaScalarWhereWithAggregatesInput | ProfileBiographyAreaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileBiographyArea"> | string
    biographyId?: StringWithAggregatesFilter<"ProfileBiographyArea"> | string
    areaId?: StringWithAggregatesFilter<"ProfileBiographyArea"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileBiographyArea"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfileBiographyArea"> | Date | string
  }

  export type ProfileBiographySocialWhereInput = {
    AND?: ProfileBiographySocialWhereInput | ProfileBiographySocialWhereInput[]
    OR?: ProfileBiographySocialWhereInput[]
    NOT?: ProfileBiographySocialWhereInput | ProfileBiographySocialWhereInput[]
    id?: StringFilter<"ProfileBiographySocial"> | string
    type?: EnumSocialTypeFilter<"ProfileBiographySocial"> | $Enums.SocialType
    href?: StringFilter<"ProfileBiographySocial"> | string
    profileBiographyId?: StringFilter<"ProfileBiographySocial"> | string
    createdAt?: DateTimeFilter<"ProfileBiographySocial"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBiographySocial"> | Date | string
    profileBiography?: XOR<ProfileBiographyRelationFilter, ProfileBiographyWhereInput>
  }

  export type ProfileBiographySocialOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    href?: SortOrder
    profileBiographyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileBiography?: ProfileBiographyOrderByWithRelationInput
  }

  export type ProfileBiographySocialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type_href?: ProfileBiographySocialTypeHrefCompoundUniqueInput
    AND?: ProfileBiographySocialWhereInput | ProfileBiographySocialWhereInput[]
    OR?: ProfileBiographySocialWhereInput[]
    NOT?: ProfileBiographySocialWhereInput | ProfileBiographySocialWhereInput[]
    type?: EnumSocialTypeFilter<"ProfileBiographySocial"> | $Enums.SocialType
    href?: StringFilter<"ProfileBiographySocial"> | string
    profileBiographyId?: StringFilter<"ProfileBiographySocial"> | string
    createdAt?: DateTimeFilter<"ProfileBiographySocial"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBiographySocial"> | Date | string
    profileBiography?: XOR<ProfileBiographyRelationFilter, ProfileBiographyWhereInput>
  }, "id" | "type_href">

  export type ProfileBiographySocialOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    href?: SortOrder
    profileBiographyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileBiographySocialCountOrderByAggregateInput
    _max?: ProfileBiographySocialMaxOrderByAggregateInput
    _min?: ProfileBiographySocialMinOrderByAggregateInput
  }

  export type ProfileBiographySocialScalarWhereWithAggregatesInput = {
    AND?: ProfileBiographySocialScalarWhereWithAggregatesInput | ProfileBiographySocialScalarWhereWithAggregatesInput[]
    OR?: ProfileBiographySocialScalarWhereWithAggregatesInput[]
    NOT?: ProfileBiographySocialScalarWhereWithAggregatesInput | ProfileBiographySocialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileBiographySocial"> | string
    type?: EnumSocialTypeWithAggregatesFilter<"ProfileBiographySocial"> | $Enums.SocialType
    href?: StringWithAggregatesFilter<"ProfileBiographySocial"> | string
    profileBiographyId?: StringWithAggregatesFilter<"ProfileBiographySocial"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileBiographySocial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfileBiographySocial"> | Date | string
  }

  export type ProfileBlogWhereInput = {
    AND?: ProfileBlogWhereInput | ProfileBlogWhereInput[]
    OR?: ProfileBlogWhereInput[]
    NOT?: ProfileBlogWhereInput | ProfileBlogWhereInput[]
    id?: StringFilter<"ProfileBlog"> | string
    title?: StringFilter<"ProfileBlog"> | string
    content?: StringNullableFilter<"ProfileBlog"> | string | null
    profileId?: StringFilter<"ProfileBlog"> | string
    createdAt?: DateTimeFilter<"ProfileBlog"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBlog"> | Date | string
    images?: ProfileBlogImageListRelationFilter
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type ProfileBlogOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: ProfileBlogImageOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type ProfileBlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId?: string
    AND?: ProfileBlogWhereInput | ProfileBlogWhereInput[]
    OR?: ProfileBlogWhereInput[]
    NOT?: ProfileBlogWhereInput | ProfileBlogWhereInput[]
    title?: StringFilter<"ProfileBlog"> | string
    content?: StringNullableFilter<"ProfileBlog"> | string | null
    createdAt?: DateTimeFilter<"ProfileBlog"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBlog"> | Date | string
    images?: ProfileBlogImageListRelationFilter
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "id" | "profileId">

  export type ProfileBlogOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileBlogCountOrderByAggregateInput
    _max?: ProfileBlogMaxOrderByAggregateInput
    _min?: ProfileBlogMinOrderByAggregateInput
  }

  export type ProfileBlogScalarWhereWithAggregatesInput = {
    AND?: ProfileBlogScalarWhereWithAggregatesInput | ProfileBlogScalarWhereWithAggregatesInput[]
    OR?: ProfileBlogScalarWhereWithAggregatesInput[]
    NOT?: ProfileBlogScalarWhereWithAggregatesInput | ProfileBlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileBlog"> | string
    title?: StringWithAggregatesFilter<"ProfileBlog"> | string
    content?: StringNullableWithAggregatesFilter<"ProfileBlog"> | string | null
    profileId?: StringWithAggregatesFilter<"ProfileBlog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileBlog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfileBlog"> | Date | string
  }

  export type ProfileBlogImageWhereInput = {
    AND?: ProfileBlogImageWhereInput | ProfileBlogImageWhereInput[]
    OR?: ProfileBlogImageWhereInput[]
    NOT?: ProfileBlogImageWhereInput | ProfileBlogImageWhereInput[]
    id?: StringFilter<"ProfileBlogImage"> | string
    url?: StringFilter<"ProfileBlogImage"> | string
    profileBlogId?: StringFilter<"ProfileBlogImage"> | string
    profileBlog?: XOR<ProfileBlogRelationFilter, ProfileBlogWhereInput>
  }

  export type ProfileBlogImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    profileBlogId?: SortOrder
    profileBlog?: ProfileBlogOrderByWithRelationInput
  }

  export type ProfileBlogImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProfileBlogImageWhereInput | ProfileBlogImageWhereInput[]
    OR?: ProfileBlogImageWhereInput[]
    NOT?: ProfileBlogImageWhereInput | ProfileBlogImageWhereInput[]
    url?: StringFilter<"ProfileBlogImage"> | string
    profileBlogId?: StringFilter<"ProfileBlogImage"> | string
    profileBlog?: XOR<ProfileBlogRelationFilter, ProfileBlogWhereInput>
  }, "id">

  export type ProfileBlogImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    profileBlogId?: SortOrder
    _count?: ProfileBlogImageCountOrderByAggregateInput
    _max?: ProfileBlogImageMaxOrderByAggregateInput
    _min?: ProfileBlogImageMinOrderByAggregateInput
  }

  export type ProfileBlogImageScalarWhereWithAggregatesInput = {
    AND?: ProfileBlogImageScalarWhereWithAggregatesInput | ProfileBlogImageScalarWhereWithAggregatesInput[]
    OR?: ProfileBlogImageScalarWhereWithAggregatesInput[]
    NOT?: ProfileBlogImageScalarWhereWithAggregatesInput | ProfileBlogImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileBlogImage"> | string
    url?: StringWithAggregatesFilter<"ProfileBlogImage"> | string
    profileBlogId?: StringWithAggregatesFilter<"ProfileBlogImage"> | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    isArchived?: BoolFilter<"Post"> | boolean
    profileId?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    images?: PostImageListRelationFilter
    comments?: PostCommentListRelationFilter
    likes?: PostLikeListRelationFilter
    shares?: PostShareListRelationFilter
    saves?: PostSaveListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    images?: PostImageOrderByRelationAggregateInput
    comments?: PostCommentOrderByRelationAggregateInput
    likes?: PostLikeOrderByRelationAggregateInput
    shares?: PostShareOrderByRelationAggregateInput
    saves?: PostSaveOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    content?: StringNullableFilter<"Post"> | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    isArchived?: BoolFilter<"Post"> | boolean
    profileId?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    images?: PostImageListRelationFilter
    comments?: PostCommentListRelationFilter
    likes?: PostLikeListRelationFilter
    shares?: PostShareListRelationFilter
    saves?: PostSaveListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    status?: EnumPostStatusWithAggregatesFilter<"Post"> | $Enums.PostStatus
    isArchived?: BoolWithAggregatesFilter<"Post"> | boolean
    profileId?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type PostImageWhereInput = {
    AND?: PostImageWhereInput | PostImageWhereInput[]
    OR?: PostImageWhereInput[]
    NOT?: PostImageWhereInput | PostImageWhereInput[]
    id?: StringFilter<"PostImage"> | string
    url?: StringFilter<"PostImage"> | string
    postId?: StringFilter<"PostImage"> | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type PostImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    postId?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type PostImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostImageWhereInput | PostImageWhereInput[]
    OR?: PostImageWhereInput[]
    NOT?: PostImageWhereInput | PostImageWhereInput[]
    url?: StringFilter<"PostImage"> | string
    postId?: StringFilter<"PostImage"> | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }, "id">

  export type PostImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    postId?: SortOrder
    _count?: PostImageCountOrderByAggregateInput
    _max?: PostImageMaxOrderByAggregateInput
    _min?: PostImageMinOrderByAggregateInput
  }

  export type PostImageScalarWhereWithAggregatesInput = {
    AND?: PostImageScalarWhereWithAggregatesInput | PostImageScalarWhereWithAggregatesInput[]
    OR?: PostImageScalarWhereWithAggregatesInput[]
    NOT?: PostImageScalarWhereWithAggregatesInput | PostImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostImage"> | string
    url?: StringWithAggregatesFilter<"PostImage"> | string
    postId?: StringWithAggregatesFilter<"PostImage"> | string
  }

  export type PostLikeWhereInput = {
    AND?: PostLikeWhereInput | PostLikeWhereInput[]
    OR?: PostLikeWhereInput[]
    NOT?: PostLikeWhereInput | PostLikeWhereInput[]
    id?: StringFilter<"PostLike"> | string
    profileId?: StringFilter<"PostLike"> | string
    postId?: StringFilter<"PostLike"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type PostLikeOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type PostLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_postId?: PostLikeProfileIdPostIdCompoundUniqueInput
    AND?: PostLikeWhereInput | PostLikeWhereInput[]
    OR?: PostLikeWhereInput[]
    NOT?: PostLikeWhereInput | PostLikeWhereInput[]
    profileId?: StringFilter<"PostLike"> | string
    postId?: StringFilter<"PostLike"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
  }, "id" | "profileId_postId">

  export type PostLikeOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    _count?: PostLikeCountOrderByAggregateInput
    _max?: PostLikeMaxOrderByAggregateInput
    _min?: PostLikeMinOrderByAggregateInput
  }

  export type PostLikeScalarWhereWithAggregatesInput = {
    AND?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
    OR?: PostLikeScalarWhereWithAggregatesInput[]
    NOT?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostLike"> | string
    profileId?: StringWithAggregatesFilter<"PostLike"> | string
    postId?: StringWithAggregatesFilter<"PostLike"> | string
  }

  export type PostShareWhereInput = {
    AND?: PostShareWhereInput | PostShareWhereInput[]
    OR?: PostShareWhereInput[]
    NOT?: PostShareWhereInput | PostShareWhereInput[]
    id?: StringFilter<"PostShare"> | string
    profileId?: StringFilter<"PostShare"> | string
    postId?: StringFilter<"PostShare"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type PostShareOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type PostShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_postId?: PostShareProfileIdPostIdCompoundUniqueInput
    AND?: PostShareWhereInput | PostShareWhereInput[]
    OR?: PostShareWhereInput[]
    NOT?: PostShareWhereInput | PostShareWhereInput[]
    profileId?: StringFilter<"PostShare"> | string
    postId?: StringFilter<"PostShare"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
  }, "id" | "profileId_postId">

  export type PostShareOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    _count?: PostShareCountOrderByAggregateInput
    _max?: PostShareMaxOrderByAggregateInput
    _min?: PostShareMinOrderByAggregateInput
  }

  export type PostShareScalarWhereWithAggregatesInput = {
    AND?: PostShareScalarWhereWithAggregatesInput | PostShareScalarWhereWithAggregatesInput[]
    OR?: PostShareScalarWhereWithAggregatesInput[]
    NOT?: PostShareScalarWhereWithAggregatesInput | PostShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostShare"> | string
    profileId?: StringWithAggregatesFilter<"PostShare"> | string
    postId?: StringWithAggregatesFilter<"PostShare"> | string
  }

  export type PostSaveWhereInput = {
    AND?: PostSaveWhereInput | PostSaveWhereInput[]
    OR?: PostSaveWhereInput[]
    NOT?: PostSaveWhereInput | PostSaveWhereInput[]
    id?: StringFilter<"PostSave"> | string
    profileId?: StringFilter<"PostSave"> | string
    postId?: StringFilter<"PostSave"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type PostSaveOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type PostSaveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_postId?: PostSaveProfileIdPostIdCompoundUniqueInput
    AND?: PostSaveWhereInput | PostSaveWhereInput[]
    OR?: PostSaveWhereInput[]
    NOT?: PostSaveWhereInput | PostSaveWhereInput[]
    profileId?: StringFilter<"PostSave"> | string
    postId?: StringFilter<"PostSave"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
  }, "id" | "profileId_postId">

  export type PostSaveOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    _count?: PostSaveCountOrderByAggregateInput
    _max?: PostSaveMaxOrderByAggregateInput
    _min?: PostSaveMinOrderByAggregateInput
  }

  export type PostSaveScalarWhereWithAggregatesInput = {
    AND?: PostSaveScalarWhereWithAggregatesInput | PostSaveScalarWhereWithAggregatesInput[]
    OR?: PostSaveScalarWhereWithAggregatesInput[]
    NOT?: PostSaveScalarWhereWithAggregatesInput | PostSaveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostSave"> | string
    profileId?: StringWithAggregatesFilter<"PostSave"> | string
    postId?: StringWithAggregatesFilter<"PostSave"> | string
  }

  export type PostCommentWhereInput = {
    AND?: PostCommentWhereInput | PostCommentWhereInput[]
    OR?: PostCommentWhereInput[]
    NOT?: PostCommentWhereInput | PostCommentWhereInput[]
    id?: StringFilter<"PostComment"> | string
    content?: StringNullableFilter<"PostComment"> | string | null
    image?: StringNullableFilter<"PostComment"> | string | null
    isArchived?: BoolFilter<"PostComment"> | boolean
    profileId?: StringFilter<"PostComment"> | string
    postId?: StringFilter<"PostComment"> | string
    parentCommentId?: StringNullableFilter<"PostComment"> | string | null
    createdAt?: DateTimeFilter<"PostComment"> | Date | string
    updatedAt?: DateTimeFilter<"PostComment"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
    parentComment?: XOR<PostCommentNullableRelationFilter, PostCommentWhereInput> | null
    children?: PostCommentListRelationFilter
    likes?: PostCommentLikeListRelationFilter
  }

  export type PostCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    parentComment?: PostCommentOrderByWithRelationInput
    children?: PostCommentOrderByRelationAggregateInput
    likes?: PostCommentLikeOrderByRelationAggregateInput
  }

  export type PostCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostCommentWhereInput | PostCommentWhereInput[]
    OR?: PostCommentWhereInput[]
    NOT?: PostCommentWhereInput | PostCommentWhereInput[]
    content?: StringNullableFilter<"PostComment"> | string | null
    image?: StringNullableFilter<"PostComment"> | string | null
    isArchived?: BoolFilter<"PostComment"> | boolean
    profileId?: StringFilter<"PostComment"> | string
    postId?: StringFilter<"PostComment"> | string
    parentCommentId?: StringNullableFilter<"PostComment"> | string | null
    createdAt?: DateTimeFilter<"PostComment"> | Date | string
    updatedAt?: DateTimeFilter<"PostComment"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
    parentComment?: XOR<PostCommentNullableRelationFilter, PostCommentWhereInput> | null
    children?: PostCommentListRelationFilter
    likes?: PostCommentLikeListRelationFilter
  }, "id">

  export type PostCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCommentCountOrderByAggregateInput
    _max?: PostCommentMaxOrderByAggregateInput
    _min?: PostCommentMinOrderByAggregateInput
  }

  export type PostCommentScalarWhereWithAggregatesInput = {
    AND?: PostCommentScalarWhereWithAggregatesInput | PostCommentScalarWhereWithAggregatesInput[]
    OR?: PostCommentScalarWhereWithAggregatesInput[]
    NOT?: PostCommentScalarWhereWithAggregatesInput | PostCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostComment"> | string
    content?: StringNullableWithAggregatesFilter<"PostComment"> | string | null
    image?: StringNullableWithAggregatesFilter<"PostComment"> | string | null
    isArchived?: BoolWithAggregatesFilter<"PostComment"> | boolean
    profileId?: StringWithAggregatesFilter<"PostComment"> | string
    postId?: StringWithAggregatesFilter<"PostComment"> | string
    parentCommentId?: StringNullableWithAggregatesFilter<"PostComment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PostComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PostComment"> | Date | string
  }

  export type PostCommentLikeWhereInput = {
    AND?: PostCommentLikeWhereInput | PostCommentLikeWhereInput[]
    OR?: PostCommentLikeWhereInput[]
    NOT?: PostCommentLikeWhereInput | PostCommentLikeWhereInput[]
    id?: StringFilter<"PostCommentLike"> | string
    profileId?: StringFilter<"PostCommentLike"> | string
    postCommentId?: StringFilter<"PostCommentLike"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    postComment?: XOR<PostCommentRelationFilter, PostCommentWhereInput>
  }

  export type PostCommentLikeOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    postCommentId?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    postComment?: PostCommentOrderByWithRelationInput
  }

  export type PostCommentLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_postCommentId?: PostCommentLikeProfileIdPostCommentIdCompoundUniqueInput
    AND?: PostCommentLikeWhereInput | PostCommentLikeWhereInput[]
    OR?: PostCommentLikeWhereInput[]
    NOT?: PostCommentLikeWhereInput | PostCommentLikeWhereInput[]
    profileId?: StringFilter<"PostCommentLike"> | string
    postCommentId?: StringFilter<"PostCommentLike"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    postComment?: XOR<PostCommentRelationFilter, PostCommentWhereInput>
  }, "id" | "profileId_postCommentId">

  export type PostCommentLikeOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    postCommentId?: SortOrder
    _count?: PostCommentLikeCountOrderByAggregateInput
    _max?: PostCommentLikeMaxOrderByAggregateInput
    _min?: PostCommentLikeMinOrderByAggregateInput
  }

  export type PostCommentLikeScalarWhereWithAggregatesInput = {
    AND?: PostCommentLikeScalarWhereWithAggregatesInput | PostCommentLikeScalarWhereWithAggregatesInput[]
    OR?: PostCommentLikeScalarWhereWithAggregatesInput[]
    NOT?: PostCommentLikeScalarWhereWithAggregatesInput | PostCommentLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostCommentLike"> | string
    profileId?: StringWithAggregatesFilter<"PostCommentLike"> | string
    postCommentId?: StringWithAggregatesFilter<"PostCommentLike"> | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    ownerId?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    owner?: XOR<ProfileRelationFilter, ProfileWhereInput>
    profiles?: ProfileGroupListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: ProfileOrderByWithRelationInput
    profiles?: ProfileGroupOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    ownerId?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    owner?: XOR<ProfileRelationFilter, ProfileWhereInput>
    profiles?: ProfileGroupListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    ownerId?: StringWithAggregatesFilter<"Group"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type ProfileGroupWhereInput = {
    AND?: ProfileGroupWhereInput | ProfileGroupWhereInput[]
    OR?: ProfileGroupWhereInput[]
    NOT?: ProfileGroupWhereInput | ProfileGroupWhereInput[]
    id?: StringFilter<"ProfileGroup"> | string
    profileId?: StringFilter<"ProfileGroup"> | string
    groupId?: StringFilter<"ProfileGroup"> | string
    createdAt?: DateTimeFilter<"ProfileGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileGroup"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    group?: XOR<GroupRelationFilter, GroupWhereInput>
  }

  export type ProfileGroupOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type ProfileGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_groupId?: ProfileGroupProfileIdGroupIdCompoundUniqueInput
    AND?: ProfileGroupWhereInput | ProfileGroupWhereInput[]
    OR?: ProfileGroupWhereInput[]
    NOT?: ProfileGroupWhereInput | ProfileGroupWhereInput[]
    profileId?: StringFilter<"ProfileGroup"> | string
    groupId?: StringFilter<"ProfileGroup"> | string
    createdAt?: DateTimeFilter<"ProfileGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileGroup"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    group?: XOR<GroupRelationFilter, GroupWhereInput>
  }, "id" | "profileId_groupId">

  export type ProfileGroupOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileGroupCountOrderByAggregateInput
    _max?: ProfileGroupMaxOrderByAggregateInput
    _min?: ProfileGroupMinOrderByAggregateInput
  }

  export type ProfileGroupScalarWhereWithAggregatesInput = {
    AND?: ProfileGroupScalarWhereWithAggregatesInput | ProfileGroupScalarWhereWithAggregatesInput[]
    OR?: ProfileGroupScalarWhereWithAggregatesInput[]
    NOT?: ProfileGroupScalarWhereWithAggregatesInput | ProfileGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileGroup"> | string
    profileId?: StringWithAggregatesFilter<"ProfileGroup"> | string
    groupId?: StringWithAggregatesFilter<"ProfileGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfileGroup"> | Date | string
  }

  export type NewsWhereInput = {
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    id?: StringFilter<"News"> | string
    title?: StringFilter<"News"> | string
    content?: StringNullableFilter<"News"> | string | null
    type?: EnumNewsTypeFilter<"News"> | $Enums.NewsType
    cover?: StringFilter<"News"> | string
    isPublished?: BoolFilter<"News"> | boolean
    schoolId?: StringNullableFilter<"News"> | string | null
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
    school?: XOR<SchoolNullableRelationFilter, SchoolWhereInput> | null
    notifications?: NewsNotificationListRelationFilter
  }

  export type NewsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    notifications?: NewsNotificationOrderByRelationAggregateInput
  }

  export type NewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    title?: StringFilter<"News"> | string
    content?: StringNullableFilter<"News"> | string | null
    type?: EnumNewsTypeFilter<"News"> | $Enums.NewsType
    cover?: StringFilter<"News"> | string
    isPublished?: BoolFilter<"News"> | boolean
    schoolId?: StringNullableFilter<"News"> | string | null
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
    school?: XOR<SchoolNullableRelationFilter, SchoolWhereInput> | null
    notifications?: NewsNotificationListRelationFilter
  }, "id">

  export type NewsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsCountOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    OR?: NewsScalarWhereWithAggregatesInput[]
    NOT?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"News"> | string
    title?: StringWithAggregatesFilter<"News"> | string
    content?: StringNullableWithAggregatesFilter<"News"> | string | null
    type?: EnumNewsTypeWithAggregatesFilter<"News"> | $Enums.NewsType
    cover?: StringWithAggregatesFilter<"News"> | string
    isPublished?: BoolWithAggregatesFilter<"News"> | boolean
    schoolId?: StringNullableWithAggregatesFilter<"News"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
  }

  export type NewsNotificationWhereInput = {
    AND?: NewsNotificationWhereInput | NewsNotificationWhereInput[]
    OR?: NewsNotificationWhereInput[]
    NOT?: NewsNotificationWhereInput | NewsNotificationWhereInput[]
    id?: StringFilter<"NewsNotification"> | string
    type?: EnumNewsTypeFilter<"NewsNotification"> | $Enums.NewsType
    isRead?: BoolFilter<"NewsNotification"> | boolean
    studentId?: StringFilter<"NewsNotification"> | string
    fromId?: StringNullableFilter<"NewsNotification"> | string | null
    newsId?: StringFilter<"NewsNotification"> | string
    createdAt?: DateTimeFilter<"NewsNotification"> | Date | string
    updatedAt?: DateTimeFilter<"NewsNotification"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    fromStudent?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    news?: XOR<NewsRelationFilter, NewsWhereInput>
  }

  export type NewsNotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    studentId?: SortOrder
    fromId?: SortOrderInput | SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    fromStudent?: StudentOrderByWithRelationInput
    news?: NewsOrderByWithRelationInput
  }

  export type NewsNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsNotificationWhereInput | NewsNotificationWhereInput[]
    OR?: NewsNotificationWhereInput[]
    NOT?: NewsNotificationWhereInput | NewsNotificationWhereInput[]
    type?: EnumNewsTypeFilter<"NewsNotification"> | $Enums.NewsType
    isRead?: BoolFilter<"NewsNotification"> | boolean
    studentId?: StringFilter<"NewsNotification"> | string
    fromId?: StringNullableFilter<"NewsNotification"> | string | null
    newsId?: StringFilter<"NewsNotification"> | string
    createdAt?: DateTimeFilter<"NewsNotification"> | Date | string
    updatedAt?: DateTimeFilter<"NewsNotification"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    fromStudent?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    news?: XOR<NewsRelationFilter, NewsWhereInput>
  }, "id">

  export type NewsNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    studentId?: SortOrder
    fromId?: SortOrderInput | SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsNotificationCountOrderByAggregateInput
    _max?: NewsNotificationMaxOrderByAggregateInput
    _min?: NewsNotificationMinOrderByAggregateInput
  }

  export type NewsNotificationScalarWhereWithAggregatesInput = {
    AND?: NewsNotificationScalarWhereWithAggregatesInput | NewsNotificationScalarWhereWithAggregatesInput[]
    OR?: NewsNotificationScalarWhereWithAggregatesInput[]
    NOT?: NewsNotificationScalarWhereWithAggregatesInput | NewsNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsNotification"> | string
    type?: EnumNewsTypeWithAggregatesFilter<"NewsNotification"> | $Enums.NewsType
    isRead?: BoolWithAggregatesFilter<"NewsNotification"> | boolean
    studentId?: StringWithAggregatesFilter<"NewsNotification"> | string
    fromId?: StringNullableWithAggregatesFilter<"NewsNotification"> | string | null
    newsId?: StringWithAggregatesFilter<"NewsNotification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NewsNotification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NewsNotification"> | Date | string
  }

  export type StudentFollowWhereInput = {
    AND?: StudentFollowWhereInput | StudentFollowWhereInput[]
    OR?: StudentFollowWhereInput[]
    NOT?: StudentFollowWhereInput | StudentFollowWhereInput[]
    id?: StringFilter<"StudentFollow"> | string
    studentId?: StringFilter<"StudentFollow"> | string
    followerId?: StringFilter<"StudentFollow"> | string
    createdAt?: DateTimeFilter<"StudentFollow"> | Date | string
    updatedAt?: DateTimeFilter<"StudentFollow"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    follower?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type StudentFollowOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    followerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    follower?: StudentOrderByWithRelationInput
  }

  export type StudentFollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_followerId?: StudentFollowStudentIdFollowerIdCompoundUniqueInput
    AND?: StudentFollowWhereInput | StudentFollowWhereInput[]
    OR?: StudentFollowWhereInput[]
    NOT?: StudentFollowWhereInput | StudentFollowWhereInput[]
    studentId?: StringFilter<"StudentFollow"> | string
    followerId?: StringFilter<"StudentFollow"> | string
    createdAt?: DateTimeFilter<"StudentFollow"> | Date | string
    updatedAt?: DateTimeFilter<"StudentFollow"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    follower?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id" | "studentId_followerId">

  export type StudentFollowOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    followerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentFollowCountOrderByAggregateInput
    _max?: StudentFollowMaxOrderByAggregateInput
    _min?: StudentFollowMinOrderByAggregateInput
  }

  export type StudentFollowScalarWhereWithAggregatesInput = {
    AND?: StudentFollowScalarWhereWithAggregatesInput | StudentFollowScalarWhereWithAggregatesInput[]
    OR?: StudentFollowScalarWhereWithAggregatesInput[]
    NOT?: StudentFollowScalarWhereWithAggregatesInput | StudentFollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentFollow"> | string
    studentId?: StringWithAggregatesFilter<"StudentFollow"> | string
    followerId?: StringWithAggregatesFilter<"StudentFollow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentFollow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentFollow"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    title?: EnumContactTitleFilter<"Contact"> | $Enums.ContactTitle
    phone?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    message?: StringFilter<"Contact"> | string
    isRead?: BoolFilter<"Contact"> | boolean
    schoolId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    school?: XOR<SchoolNullableRelationFilter, SchoolWhereInput> | null
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    title?: EnumContactTitleFilter<"Contact"> | $Enums.ContactTitle
    phone?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    message?: StringFilter<"Contact"> | string
    isRead?: BoolFilter<"Contact"> | boolean
    schoolId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    school?: XOR<SchoolNullableRelationFilter, SchoolWhereInput> | null
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    title?: EnumContactTitleWithAggregatesFilter<"Contact"> | $Enums.ContactTitle
    phone?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    message?: StringWithAggregatesFilter<"Contact"> | string
    isRead?: BoolWithAggregatesFilter<"Contact"> | boolean
    schoolId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    password: string
    name: string
    dob: Date | string
    gender: $Enums.Gender
    phoneNumber: string
    idCardNumber: string
    address: string
    image?: string | null
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutAccountInput
    student?: StudentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    password: string
    name: string
    dob: Date | string
    gender: $Enums.Gender
    phoneNumber: string
    idCardNumber: string
    address: string
    image?: string | null
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutAccountInput
    student?: StudentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    phoneNumber?: StringFieldUpdateOperationsInput | string
    idCardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutAccountNestedInput
    student?: StudentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    phoneNumber?: StringFieldUpdateOperationsInput | string
    idCardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutAccountNestedInput
    student?: StudentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    password: string
    name: string
    dob: Date | string
    gender: $Enums.Gender
    phoneNumber: string
    idCardNumber: string
    address: string
    image?: string | null
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    phoneNumber?: StringFieldUpdateOperationsInput | string
    idCardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    phoneNumber?: StringFieldUpdateOperationsInput | string
    idCardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type TwoFactorTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type TwoFactorTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type TwoFactorTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorConfirmationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutTwoFactorConfirmationInput
  }

  export type TwoFactorConfirmationUncheckedCreateInput = {
    id?: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorConfirmationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTwoFactorConfirmationNestedInput
  }

  export type TwoFactorConfirmationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorConfirmationCreateManyInput = {
    id?: string
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorConfirmationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorConfirmationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipCreateNestedManyWithoutSchoolInput
    news?: NewsCreateNestedManyWithoutSchoolInput
    contacts?: ContactCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationUncheckedCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramUncheckedCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryUncheckedCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipUncheckedCreateNestedManyWithoutSchoolInput
    news?: NewsUncheckedCreateNestedManyWithoutSchoolInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUpdateManyWithoutSchoolNestedInput
    news?: NewsUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUncheckedUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUncheckedUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUncheckedUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUncheckedUpdateManyWithoutSchoolNestedInput
    news?: NewsUncheckedUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolScholarshipCreateInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutScholarshipsInput
    owners?: StudentSchoolScholarshipCreateNestedManyWithoutScholarshipInput
    images?: SchoolScholarshipImageCreateNestedManyWithoutScholarshipInput
  }

  export type SchoolScholarshipUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutScholarshipInput
    images?: SchoolScholarshipImageUncheckedCreateNestedManyWithoutScholarshipInput
  }

  export type SchoolScholarshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutScholarshipsNestedInput
    owners?: StudentSchoolScholarshipUpdateManyWithoutScholarshipNestedInput
    images?: SchoolScholarshipImageUpdateManyWithoutScholarshipNestedInput
  }

  export type SchoolScholarshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: StudentSchoolScholarshipUncheckedUpdateManyWithoutScholarshipNestedInput
    images?: SchoolScholarshipImageUncheckedUpdateManyWithoutScholarshipNestedInput
  }

  export type SchoolScholarshipCreateManyInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolScholarshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolScholarshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolScholarshipImageCreateInput = {
    id?: string
    url: string
    scholarship: SchoolScholarshipCreateNestedOneWithoutImagesInput
  }

  export type SchoolScholarshipImageUncheckedCreateInput = {
    id?: string
    url: string
    scholarshipId: string
  }

  export type SchoolScholarshipImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    scholarship?: SchoolScholarshipUpdateOneRequiredWithoutImagesNestedInput
  }

  export type SchoolScholarshipImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    scholarshipId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolScholarshipImageCreateManyInput = {
    id?: string
    url: string
    scholarshipId: string
  }

  export type SchoolScholarshipImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolScholarshipImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    scholarshipId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSchoolScholarshipCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutScholarshipInput
    scholarship: SchoolScholarshipCreateNestedOneWithoutOwnersInput
  }

  export type StudentSchoolScholarshipUncheckedCreateInput = {
    id?: string
    studentId: string
    scholarshipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolScholarshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutScholarshipNestedInput
    scholarship?: SchoolScholarshipUpdateOneRequiredWithoutOwnersNestedInput
  }

  export type StudentSchoolScholarshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scholarshipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolScholarshipCreateManyInput = {
    id?: string
    studentId: string
    scholarshipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolScholarshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolScholarshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scholarshipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolGalleryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolGalleryImageCreateNestedManyWithoutGalleryInput
    school: SchoolCreateNestedOneWithoutGalleriesInput
  }

  export type SchoolGalleryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolGalleryImageUncheckedCreateNestedManyWithoutGalleryInput
  }

  export type SchoolGalleryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolGalleryImageUpdateManyWithoutGalleryNestedInput
    school?: SchoolUpdateOneRequiredWithoutGalleriesNestedInput
  }

  export type SchoolGalleryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolGalleryImageUncheckedUpdateManyWithoutGalleryNestedInput
  }

  export type SchoolGalleryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolGalleryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolGalleryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolGalleryImageCreateInput = {
    id?: string
    url: string
    gallery: SchoolGalleryCreateNestedOneWithoutImagesInput
  }

  export type SchoolGalleryImageUncheckedCreateInput = {
    id?: string
    url: string
    galleryId: string
  }

  export type SchoolGalleryImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    gallery?: SchoolGalleryUpdateOneRequiredWithoutImagesNestedInput
  }

  export type SchoolGalleryImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    galleryId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolGalleryImageCreateManyInput = {
    id?: string
    url: string
    galleryId: string
  }

  export type SchoolGalleryImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolGalleryImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    galleryId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolLocationCreateInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolLocationImageCreateNestedManyWithoutLocationInput
    contacts?: SchoolLocationContactCreateNestedManyWithoutLocationInput
    students?: StudentSchoolLocationCreateNestedManyWithoutLocationInput
    school: SchoolCreateNestedOneWithoutLocationsInput
  }

  export type SchoolLocationUncheckedCreateInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolLocationImageUncheckedCreateNestedManyWithoutLocationInput
    contacts?: SchoolLocationContactUncheckedCreateNestedManyWithoutLocationInput
    students?: StudentSchoolLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type SchoolLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolLocationImageUpdateManyWithoutLocationNestedInput
    contacts?: SchoolLocationContactUpdateManyWithoutLocationNestedInput
    students?: StudentSchoolLocationUpdateManyWithoutLocationNestedInput
    school?: SchoolUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type SchoolLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolLocationImageUncheckedUpdateManyWithoutLocationNestedInput
    contacts?: SchoolLocationContactUncheckedUpdateManyWithoutLocationNestedInput
    students?: StudentSchoolLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type SchoolLocationCreateManyInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLocationImageCreateInput = {
    id?: string
    url: string
    location: SchoolLocationCreateNestedOneWithoutImagesInput
  }

  export type SchoolLocationImageUncheckedCreateInput = {
    id?: string
    url: string
    locationId: string
  }

  export type SchoolLocationImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    location?: SchoolLocationUpdateOneRequiredWithoutImagesNestedInput
  }

  export type SchoolLocationImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolLocationImageCreateManyInput = {
    id?: string
    url: string
    locationId: string
  }

  export type SchoolLocationImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolLocationImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolLocationContactCreateInput = {
    id?: string
    phone?: string | null
    hours?: string | null
    fax?: string | null
    email?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: SchoolLocationCreateNestedOneWithoutContactsInput
  }

  export type SchoolLocationContactUncheckedCreateInput = {
    id?: string
    phone?: string | null
    hours?: string | null
    fax?: string | null
    email?: string | null
    url?: string | null
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolLocationContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: SchoolLocationUpdateOneRequiredWithoutContactsNestedInput
  }

  export type SchoolLocationContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLocationContactCreateManyInput = {
    id?: string
    phone?: string | null
    hours?: string | null
    fax?: string | null
    email?: string | null
    url?: string | null
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolLocationContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLocationContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolProgramCreateInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutProgramsInput
    studentPrograms?: StudentSchoolProgramCreateNestedManyWithoutProgramInput
    images?: SchoolProgramImageCreateNestedManyWithoutProgramInput
  }

  export type SchoolProgramUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentSchoolProgramUncheckedCreateNestedManyWithoutProgramInput
    images?: SchoolProgramImageUncheckedCreateNestedManyWithoutProgramInput
  }

  export type SchoolProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutProgramsNestedInput
    studentPrograms?: StudentSchoolProgramUpdateManyWithoutProgramNestedInput
    images?: SchoolProgramImageUpdateManyWithoutProgramNestedInput
  }

  export type SchoolProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentSchoolProgramUncheckedUpdateManyWithoutProgramNestedInput
    images?: SchoolProgramImageUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type SchoolProgramCreateManyInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolProgramImageCreateInput = {
    id?: string
    url: string
    program: SchoolProgramCreateNestedOneWithoutImagesInput
  }

  export type SchoolProgramImageUncheckedCreateInput = {
    id?: string
    url: string
    programId: string
  }

  export type SchoolProgramImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    program?: SchoolProgramUpdateOneRequiredWithoutImagesNestedInput
  }

  export type SchoolProgramImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolProgramImageCreateManyInput = {
    id?: string
    url: string
    programId: string
  }

  export type SchoolProgramImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolProgramImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSchoolProgramCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProgramInput
    program: SchoolProgramCreateNestedOneWithoutStudentProgramsInput
  }

  export type StudentSchoolProgramUncheckedCreateInput = {
    id?: string
    studentId: string
    programId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProgramNestedInput
    program?: SchoolProgramUpdateOneRequiredWithoutStudentProgramsNestedInput
  }

  export type StudentSchoolProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolProgramCreateManyInput = {
    id?: string
    studentId: string
    programId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolLocationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutLocationInput
    location: SchoolLocationCreateNestedOneWithoutStudentsInput
  }

  export type StudentSchoolLocationUncheckedCreateInput = {
    id?: string
    studentId: string
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLocationNestedInput
    location?: SchoolLocationUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentSchoolLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolLocationCreateManyInput = {
    id?: string
    studentId: string
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    name?: string | null
    creatAt?: Date | string
    updateAt?: Date | string
    messeges?: MessageCreateNestedManyWithoutChatInput
    students?: StudentCreateNestedManyWithoutChatsInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    name?: string | null
    creatAt?: Date | string
    updateAt?: Date | string
    messeges?: MessageUncheckedCreateNestedManyWithoutChatInput
    students?: StudentUncheckedCreateNestedManyWithoutChatsInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeges?: MessageUpdateManyWithoutChatNestedInput
    students?: StudentUpdateManyWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeges?: MessageUncheckedUpdateManyWithoutChatNestedInput
    students?: StudentUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    name?: string | null
    creatAt?: Date | string
    updateAt?: Date | string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    createAt?: Date | string
    updateAt?: Date | string
    student: StudentCreateNestedOneWithoutMesseagesInput
    chat: ChatCreateNestedOneWithoutMessegesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    createAt?: Date | string
    updateAt?: Date | string
    studentCode: string
    chatId: string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMesseagesNestedInput
    chat?: ChatUpdateOneRequiredWithoutMessegesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    createAt?: Date | string
    updateAt?: Date | string
    studentCode: string
    chatId: string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    host: ProfileCreateNestedOneWithoutHostedEventsInput
    participants?: EventProfileCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    hostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: EventProfileUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: ProfileUpdateOneRequiredWithoutHostedEventsNestedInput
    participants?: EventProfileUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: EventProfileUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    hostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventProfileCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutParticipantsInput
    profile: ProfileCreateNestedOneWithoutParticipatedEventsInput
  }

  export type EventProfileUncheckedCreateInput = {
    id?: string
    eventId: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutParticipantsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutParticipatedEventsNestedInput
  }

  export type EventProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventProfileCreateManyInput = {
    id?: string
    eventId: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileFriendCreateInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileOne: ProfileCreateNestedOneWithoutFriendRequestsInput
    profileTwo: ProfileCreateNestedOneWithoutFriendReceivedInput
  }

  export type ProfileFriendUncheckedCreateInput = {
    id?: string
    isActive?: boolean
    profileIdOne: string
    profileIdTwo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileFriendUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileOne?: ProfileUpdateOneRequiredWithoutFriendRequestsNestedInput
    profileTwo?: ProfileUpdateOneRequiredWithoutFriendReceivedNestedInput
  }

  export type ProfileFriendUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileIdOne?: StringFieldUpdateOperationsInput | string
    profileIdTwo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileFriendCreateManyInput = {
    id?: string
    isActive?: boolean
    profileIdOne: string
    profileIdTwo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileFriendUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileFriendUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileIdOne?: StringFieldUpdateOperationsInput | string
    profileIdTwo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    biographies?: ProfileBiographyAreaCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    biographies?: ProfileBiographyAreaUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biographies?: ProfileBiographyAreaUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biographies?: ProfileBiographyAreaUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AreaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographyCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutBiographyInput
    areas?: ProfileBiographyAreaCreateNestedManyWithoutBiographyInput
    socials?: ProfileBiographySocialCreateNestedManyWithoutProfileBiographyInput
  }

  export type ProfileBiographyUncheckedCreateInput = {
    id?: string
    content: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    areas?: ProfileBiographyAreaUncheckedCreateNestedManyWithoutBiographyInput
    socials?: ProfileBiographySocialUncheckedCreateNestedManyWithoutProfileBiographyInput
  }

  export type ProfileBiographyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutBiographyNestedInput
    areas?: ProfileBiographyAreaUpdateManyWithoutBiographyNestedInput
    socials?: ProfileBiographySocialUpdateManyWithoutProfileBiographyNestedInput
  }

  export type ProfileBiographyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areas?: ProfileBiographyAreaUncheckedUpdateManyWithoutBiographyNestedInput
    socials?: ProfileBiographySocialUncheckedUpdateManyWithoutProfileBiographyNestedInput
  }

  export type ProfileBiographyCreateManyInput = {
    id?: string
    content: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographyAreaCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    biography: ProfileBiographyCreateNestedOneWithoutAreasInput
    area: AreaCreateNestedOneWithoutBiographiesInput
  }

  export type ProfileBiographyAreaUncheckedCreateInput = {
    id?: string
    biographyId: string
    areaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographyAreaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biography?: ProfileBiographyUpdateOneRequiredWithoutAreasNestedInput
    area?: AreaUpdateOneRequiredWithoutBiographiesNestedInput
  }

  export type ProfileBiographyAreaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    biographyId?: StringFieldUpdateOperationsInput | string
    areaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographyAreaCreateManyInput = {
    id?: string
    biographyId: string
    areaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographyAreaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographyAreaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    biographyId?: StringFieldUpdateOperationsInput | string
    areaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographySocialCreateInput = {
    id?: string
    type: $Enums.SocialType
    href: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileBiography: ProfileBiographyCreateNestedOneWithoutSocialsInput
  }

  export type ProfileBiographySocialUncheckedCreateInput = {
    id?: string
    type: $Enums.SocialType
    href: string
    profileBiographyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographySocialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialTypeFieldUpdateOperationsInput | $Enums.SocialType
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileBiography?: ProfileBiographyUpdateOneRequiredWithoutSocialsNestedInput
  }

  export type ProfileBiographySocialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialTypeFieldUpdateOperationsInput | $Enums.SocialType
    href?: StringFieldUpdateOperationsInput | string
    profileBiographyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographySocialCreateManyInput = {
    id?: string
    type: $Enums.SocialType
    href: string
    profileBiographyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographySocialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialTypeFieldUpdateOperationsInput | $Enums.SocialType
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographySocialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialTypeFieldUpdateOperationsInput | $Enums.SocialType
    href?: StringFieldUpdateOperationsInput | string
    profileBiographyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBlogCreateInput = {
    id?: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProfileBlogImageCreateNestedManyWithoutProfileBlogInput
    profile: ProfileCreateNestedOneWithoutBlogsInput
  }

  export type ProfileBlogUncheckedCreateInput = {
    id?: string
    title: string
    content?: string | null
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProfileBlogImageUncheckedCreateNestedManyWithoutProfileBlogInput
  }

  export type ProfileBlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProfileBlogImageUpdateManyWithoutProfileBlogNestedInput
    profile?: ProfileUpdateOneRequiredWithoutBlogsNestedInput
  }

  export type ProfileBlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProfileBlogImageUncheckedUpdateManyWithoutProfileBlogNestedInput
  }

  export type ProfileBlogCreateManyInput = {
    id?: string
    title: string
    content?: string | null
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBlogImageCreateInput = {
    id?: string
    url: string
    profileBlog: ProfileBlogCreateNestedOneWithoutImagesInput
  }

  export type ProfileBlogImageUncheckedCreateInput = {
    id?: string
    url: string
    profileBlogId: string
  }

  export type ProfileBlogImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    profileBlog?: ProfileBlogUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ProfileBlogImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    profileBlogId?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileBlogImageCreateManyInput = {
    id?: string
    url: string
    profileBlogId: string
  }

  export type ProfileBlogImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileBlogImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    profileBlogId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostsInput
    images?: PostImageCreateNestedManyWithoutPostInput
    comments?: PostCommentCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
    shares?: PostShareCreateNestedManyWithoutPostInput
    saves?: PostSaveCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    shares?: PostShareUncheckedCreateNestedManyWithoutPostInput
    saves?: PostSaveUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    comments?: PostCommentUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
    shares?: PostShareUpdateManyWithoutPostNestedInput
    saves?: PostSaveUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    shares?: PostShareUncheckedUpdateManyWithoutPostNestedInput
    saves?: PostSaveUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageCreateInput = {
    id?: string
    url: string
    post: PostCreateNestedOneWithoutImagesInput
  }

  export type PostImageUncheckedCreateInput = {
    id?: string
    url: string
    postId: string
  }

  export type PostImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutImagesNestedInput
  }

  export type PostImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostImageCreateManyInput = {
    id?: string
    url: string
    postId: string
  }

  export type PostImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PostImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeCreateInput = {
    id?: string
    profile: ProfileCreateNestedOneWithoutPostLikesInput
    post: PostCreateNestedOneWithoutLikesInput
  }

  export type PostLikeUncheckedCreateInput = {
    id?: string
    profileId: string
    postId: string
  }

  export type PostLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneRequiredWithoutPostLikesNestedInput
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type PostLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeCreateManyInput = {
    id?: string
    profileId: string
    postId: string
  }

  export type PostLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostShareCreateInput = {
    id?: string
    profile: ProfileCreateNestedOneWithoutPostSharesInput
    post: PostCreateNestedOneWithoutSharesInput
  }

  export type PostShareUncheckedCreateInput = {
    id?: string
    profileId: string
    postId: string
  }

  export type PostShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneRequiredWithoutPostSharesNestedInput
    post?: PostUpdateOneRequiredWithoutSharesNestedInput
  }

  export type PostShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostShareCreateManyInput = {
    id?: string
    profileId: string
    postId: string
  }

  export type PostShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PostShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostSaveCreateInput = {
    id?: string
    profile: ProfileCreateNestedOneWithoutPostSavedInput
    post: PostCreateNestedOneWithoutSavesInput
  }

  export type PostSaveUncheckedCreateInput = {
    id?: string
    profileId: string
    postId: string
  }

  export type PostSaveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneRequiredWithoutPostSavedNestedInput
    post?: PostUpdateOneRequiredWithoutSavesNestedInput
  }

  export type PostSaveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostSaveCreateManyInput = {
    id?: string
    profileId: string
    postId: string
  }

  export type PostSaveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PostSaveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentCreateInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostCommentsInput
    post: PostCreateNestedOneWithoutCommentsInput
    parentComment?: PostCommentCreateNestedOneWithoutChildrenInput
    children?: PostCommentCreateNestedManyWithoutParentCommentInput
    likes?: PostCommentLikeCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentUncheckedCreateInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    profileId: string
    postId: string
    parentCommentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostCommentUncheckedCreateNestedManyWithoutParentCommentInput
    likes?: PostCommentLikeUncheckedCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostCommentsNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: PostCommentUpdateOneWithoutChildrenNestedInput
    children?: PostCommentUpdateManyWithoutParentCommentNestedInput
    likes?: PostCommentLikeUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostCommentUncheckedUpdateManyWithoutParentCommentNestedInput
    likes?: PostCommentLikeUncheckedUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentCreateManyInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    profileId: string
    postId: string
    parentCommentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentLikeCreateInput = {
    id?: string
    profile: ProfileCreateNestedOneWithoutPostCommentLikesInput
    postComment: PostCommentCreateNestedOneWithoutLikesInput
  }

  export type PostCommentLikeUncheckedCreateInput = {
    id?: string
    profileId: string
    postCommentId: string
  }

  export type PostCommentLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneRequiredWithoutPostCommentLikesNestedInput
    postComment?: PostCommentUpdateOneRequiredWithoutLikesNestedInput
  }

  export type PostCommentLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    postCommentId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentLikeCreateManyInput = {
    id?: string
    profileId: string
    postCommentId: string
  }

  export type PostCommentLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    postCommentId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: ProfileCreateNestedOneWithoutOwnedGroupsInput
    profiles?: ProfileGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: ProfileUpdateOneRequiredWithoutOwnedGroupsNestedInput
    profiles?: ProfileGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileGroupCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutGroupsInput
    group: GroupCreateNestedOneWithoutProfilesInput
  }

  export type ProfileGroupUncheckedCreateInput = {
    id?: string
    profileId: string
    groupId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutGroupsNestedInput
    group?: GroupUpdateOneRequiredWithoutProfilesNestedInput
  }

  export type ProfileGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileGroupCreateManyInput = {
    id?: string
    profileId: string
    groupId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateInput = {
    id?: string
    title: string
    content?: string | null
    type: $Enums.NewsType
    cover: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutNewsInput
    notifications?: NewsNotificationCreateNestedManyWithoutNewsInput
  }

  export type NewsUncheckedCreateInput = {
    id?: string
    title: string
    content?: string | null
    type: $Enums.NewsType
    cover: string
    isPublished?: boolean
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutNewsInput
  }

  export type NewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    cover?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutNewsNestedInput
    notifications?: NewsNotificationUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    cover?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NewsNotificationUncheckedUpdateManyWithoutNewsNestedInput
  }

  export type NewsCreateManyInput = {
    id?: string
    title: string
    content?: string | null
    type: $Enums.NewsType
    cover: string
    isPublished?: boolean
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    cover?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    cover?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsNotificationCreateInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutNotificationsInput
    fromStudent?: StudentCreateNestedOneWithoutOwnedNotificationsInput
    news: NewsCreateNestedOneWithoutNotificationsInput
  }

  export type NewsNotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    studentId: string
    fromId?: string | null
    newsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutNotificationsNestedInput
    fromStudent?: StudentUpdateOneWithoutOwnedNotificationsNestedInput
    news?: NewsUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NewsNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    fromId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsNotificationCreateManyInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    studentId: string
    fromId?: string | null
    newsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    fromId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentFollowCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFollowsInput
    follower: StudentCreateNestedOneWithoutFollowersInput
  }

  export type StudentFollowUncheckedCreateInput = {
    id?: string
    studentId: string
    followerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentFollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFollowsNestedInput
    follower?: StudentUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type StudentFollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentFollowCreateManyInput = {
    id?: string
    studentId: string
    followerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentFollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentFollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    title: $Enums.ContactTitle
    phone: string
    email: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    name: string
    title: $Enums.ContactTitle
    phone: string
    email: string
    message: string
    isRead?: boolean
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: EnumContactTitleFieldUpdateOperationsInput | $Enums.ContactTitle
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: EnumContactTitleFieldUpdateOperationsInput | $Enums.ContactTitle
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyInput = {
    id?: string
    name: string
    title: $Enums.ContactTitle
    phone: string
    email: string
    message: string
    isRead?: boolean
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: EnumContactTitleFieldUpdateOperationsInput | $Enums.ContactTitle
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: EnumContactTitleFieldUpdateOperationsInput | $Enums.ContactTitle
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TwoFactorConfirmationNullableRelationFilter = {
    is?: TwoFactorConfirmationWhereInput | null
    isNot?: TwoFactorConfirmationWhereInput | null
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    name?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phoneNumber?: SortOrder
    idCardNumber?: SortOrder
    address?: SortOrder
    image?: SortOrder
    isLocked?: SortOrder
    isTwoFactorEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    name?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phoneNumber?: SortOrder
    idCardNumber?: SortOrder
    address?: SortOrder
    image?: SortOrder
    isLocked?: SortOrder
    isTwoFactorEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    name?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    phoneNumber?: SortOrder
    idCardNumber?: SortOrder
    address?: SortOrder
    image?: SortOrder
    isLocked?: SortOrder
    isTwoFactorEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type VerificationTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type TwoFactorTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type TwoFactorConfirmationCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorConfirmationMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorConfirmationMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCountryFilter<$PrismaModel = never> = {
    equals?: $Enums.Country | EnumCountryFieldRefInput<$PrismaModel>
    in?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    not?: NestedEnumCountryFilter<$PrismaModel> | $Enums.Country
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type SchoolLocationListRelationFilter = {
    every?: SchoolLocationWhereInput
    some?: SchoolLocationWhereInput
    none?: SchoolLocationWhereInput
  }

  export type SchoolProgramListRelationFilter = {
    every?: SchoolProgramWhereInput
    some?: SchoolProgramWhereInput
    none?: SchoolProgramWhereInput
  }

  export type SchoolGalleryListRelationFilter = {
    every?: SchoolGalleryWhereInput
    some?: SchoolGalleryWhereInput
    none?: SchoolGalleryWhereInput
  }

  export type SchoolScholarshipListRelationFilter = {
    every?: SchoolScholarshipWhereInput
    some?: SchoolScholarshipWhereInput
    none?: SchoolScholarshipWhereInput
  }

  export type NewsListRelationFilter = {
    every?: NewsWhereInput
    some?: NewsWhereInput
    none?: NewsWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolGalleryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolScholarshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    logo?: SortOrder
    background?: SortOrder
    name?: SortOrder
    short?: SortOrder
    description?: SortOrder
    history?: SortOrder
    color?: SortOrder
    isPublished?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    logo?: SortOrder
    background?: SortOrder
    name?: SortOrder
    short?: SortOrder
    description?: SortOrder
    history?: SortOrder
    color?: SortOrder
    isPublished?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    logo?: SortOrder
    background?: SortOrder
    name?: SortOrder
    short?: SortOrder
    description?: SortOrder
    history?: SortOrder
    color?: SortOrder
    isPublished?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCountryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Country | EnumCountryFieldRefInput<$PrismaModel>
    in?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    not?: NestedEnumCountryWithAggregatesFilter<$PrismaModel> | $Enums.Country
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCountryFilter<$PrismaModel>
    _max?: NestedEnumCountryFilter<$PrismaModel>
  }

  export type SchoolRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type StudentSchoolScholarshipListRelationFilter = {
    every?: StudentSchoolScholarshipWhereInput
    some?: StudentSchoolScholarshipWhereInput
    none?: StudentSchoolScholarshipWhereInput
  }

  export type SchoolScholarshipImageListRelationFilter = {
    every?: SchoolScholarshipImageWhereInput
    some?: SchoolScholarshipImageWhereInput
    none?: SchoolScholarshipImageWhereInput
  }

  export type StudentSchoolScholarshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolScholarshipImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolScholarshipSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type SchoolScholarshipCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolScholarshipMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolScholarshipMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolScholarshipRelationFilter = {
    is?: SchoolScholarshipWhereInput
    isNot?: SchoolScholarshipWhereInput
  }

  export type SchoolScholarshipImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    scholarshipId?: SortOrder
  }

  export type SchoolScholarshipImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    scholarshipId?: SortOrder
  }

  export type SchoolScholarshipImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    scholarshipId?: SortOrder
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type StudentSchoolScholarshipStudentIdScholarshipIdCompoundUniqueInput = {
    studentId: string
    scholarshipId: string
  }

  export type StudentSchoolScholarshipCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    scholarshipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSchoolScholarshipMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    scholarshipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSchoolScholarshipMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    scholarshipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolGalleryImageListRelationFilter = {
    every?: SchoolGalleryImageWhereInput
    some?: SchoolGalleryImageWhereInput
    none?: SchoolGalleryImageWhereInput
  }

  export type SchoolGalleryImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolGalleryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolGalleryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolGalleryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolGalleryRelationFilter = {
    is?: SchoolGalleryWhereInput
    isNot?: SchoolGalleryWhereInput
  }

  export type SchoolGalleryImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    galleryId?: SortOrder
  }

  export type SchoolGalleryImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    galleryId?: SortOrder
  }

  export type SchoolGalleryImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    galleryId?: SortOrder
  }

  export type SchoolLocationImageListRelationFilter = {
    every?: SchoolLocationImageWhereInput
    some?: SchoolLocationImageWhereInput
    none?: SchoolLocationImageWhereInput
  }

  export type SchoolLocationContactListRelationFilter = {
    every?: SchoolLocationContactWhereInput
    some?: SchoolLocationContactWhereInput
    none?: SchoolLocationContactWhereInput
  }

  export type StudentSchoolLocationListRelationFilter = {
    every?: StudentSchoolLocationWhereInput
    some?: StudentSchoolLocationWhereInput
    none?: StudentSchoolLocationWhereInput
  }

  export type SchoolLocationImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolLocationContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSchoolLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolLocationCountOrderByAggregateInput = {
    id?: SortOrder
    cover?: SortOrder
    name?: SortOrder
    address?: SortOrder
    isMain?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    cover?: SortOrder
    name?: SortOrder
    address?: SortOrder
    isMain?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolLocationMinOrderByAggregateInput = {
    id?: SortOrder
    cover?: SortOrder
    name?: SortOrder
    address?: SortOrder
    isMain?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolLocationRelationFilter = {
    is?: SchoolLocationWhereInput
    isNot?: SchoolLocationWhereInput
  }

  export type SchoolLocationImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    locationId?: SortOrder
  }

  export type SchoolLocationImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    locationId?: SortOrder
  }

  export type SchoolLocationImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    locationId?: SortOrder
  }

  export type SchoolLocationContactCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    hours?: SortOrder
    fax?: SortOrder
    email?: SortOrder
    url?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolLocationContactMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    hours?: SortOrder
    fax?: SortOrder
    email?: SortOrder
    url?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolLocationContactMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    hours?: SortOrder
    fax?: SortOrder
    email?: SortOrder
    url?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSchoolProgramListRelationFilter = {
    every?: StudentSchoolProgramWhereInput
    some?: StudentSchoolProgramWhereInput
    none?: StudentSchoolProgramWhereInput
  }

  export type SchoolProgramImageListRelationFilter = {
    every?: SchoolProgramImageWhereInput
    some?: SchoolProgramImageWhereInput
    none?: SchoolProgramImageWhereInput
  }

  export type StudentSchoolProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolProgramImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolProgramSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type SchoolProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolProgramRelationFilter = {
    is?: SchoolProgramWhereInput
    isNot?: SchoolProgramWhereInput
  }

  export type SchoolProgramImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    programId?: SortOrder
  }

  export type SchoolProgramImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    programId?: SortOrder
  }

  export type SchoolProgramImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    programId?: SortOrder
  }

  export type StudentSchoolProgramStudentIdProgramIdCompoundUniqueInput = {
    studentId: string
    programId: string
  }

  export type StudentSchoolProgramCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSchoolProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSchoolProgramMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSchoolLocationStudentIdLocationIdCompoundUniqueInput = {
    studentId: string
    locationId: string
  }

  export type StudentSchoolLocationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSchoolLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSchoolLocationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDegreeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DegreeType | EnumDegreeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DegreeType[] | ListEnumDegreeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DegreeType[] | ListEnumDegreeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDegreeTypeFilter<$PrismaModel> | $Enums.DegreeType
  }

  export type EnumCertificateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeFilter<$PrismaModel> | $Enums.CertificateType
  }

  export type EnumGradeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeFilter<$PrismaModel> | $Enums.GradeType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type StudentSchoolProgramNullableRelationFilter = {
    is?: StudentSchoolProgramWhereInput | null
    isNot?: StudentSchoolProgramWhereInput | null
  }

  export type StudentSchoolLocationNullableRelationFilter = {
    is?: StudentSchoolLocationWhereInput | null
    isNot?: StudentSchoolLocationWhereInput | null
  }

  export type NewsNotificationListRelationFilter = {
    every?: NewsNotificationWhereInput
    some?: NewsNotificationWhereInput
    none?: NewsNotificationWhereInput
  }

  export type StudentFollowListRelationFilter = {
    every?: StudentFollowWhereInput
    some?: StudentFollowWhereInput
    none?: StudentFollowWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentFollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    studentCode?: SortOrder
    degreeType?: SortOrder
    certificateType?: SortOrder
    certificateImg?: SortOrder
    gradeType?: SortOrder
    gradeScore?: SortOrder
    cover?: SortOrder
    additional?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    gradeScore?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentCode?: SortOrder
    degreeType?: SortOrder
    certificateType?: SortOrder
    certificateImg?: SortOrder
    gradeType?: SortOrder
    gradeScore?: SortOrder
    cover?: SortOrder
    additional?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    studentCode?: SortOrder
    degreeType?: SortOrder
    certificateType?: SortOrder
    certificateImg?: SortOrder
    gradeType?: SortOrder
    gradeScore?: SortOrder
    cover?: SortOrder
    additional?: SortOrder
    status?: SortOrder
    accountId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    gradeScore?: SortOrder
  }

  export type EnumDegreeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DegreeType | EnumDegreeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DegreeType[] | ListEnumDegreeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DegreeType[] | ListEnumDegreeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDegreeTypeWithAggregatesFilter<$PrismaModel> | $Enums.DegreeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDegreeTypeFilter<$PrismaModel>
    _max?: NestedEnumDegreeTypeFilter<$PrismaModel>
  }

  export type EnumCertificateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeWithAggregatesFilter<$PrismaModel> | $Enums.CertificateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificateTypeFilter<$PrismaModel>
    _max?: NestedEnumCertificateTypeFilter<$PrismaModel>
  }

  export type EnumGradeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeWithAggregatesFilter<$PrismaModel> | $Enums.GradeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGradeTypeFilter<$PrismaModel>
    _max?: NestedEnumGradeTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creatAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creatAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creatAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ChatRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    studentCode?: SortOrder
    chatId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    studentCode?: SortOrder
    chatId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    studentCode?: SortOrder
    chatId?: SortOrder
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type EventProfileListRelationFilter = {
    every?: EventProfileWhereInput
    some?: EventProfileWhereInput
    none?: EventProfileWhereInput
  }

  export type EventProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventProfileEventIdProfileIdCompoundUniqueInput = {
    eventId: string
    profileId: string
  }

  export type EventProfileCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventProfileMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileStatus | EnumProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileStatusFilter<$PrismaModel> | $Enums.ProfileStatus
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type ProfileBiographyNullableRelationFilter = {
    is?: ProfileBiographyWhereInput | null
    isNot?: ProfileBiographyWhereInput | null
  }

  export type ProfileFriendListRelationFilter = {
    every?: ProfileFriendWhereInput
    some?: ProfileFriendWhereInput
    none?: ProfileFriendWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type ProfileGroupListRelationFilter = {
    every?: ProfileGroupWhereInput
    some?: ProfileGroupWhereInput
    none?: ProfileGroupWhereInput
  }

  export type ProfileBlogListRelationFilter = {
    every?: ProfileBlogWhereInput
    some?: ProfileBlogWhereInput
    none?: ProfileBlogWhereInput
  }

  export type PostCommentListRelationFilter = {
    every?: PostCommentWhereInput
    some?: PostCommentWhereInput
    none?: PostCommentWhereInput
  }

  export type PostCommentLikeListRelationFilter = {
    every?: PostCommentLikeWhereInput
    some?: PostCommentLikeWhereInput
    none?: PostCommentLikeWhereInput
  }

  export type PostLikeListRelationFilter = {
    every?: PostLikeWhereInput
    some?: PostLikeWhereInput
    none?: PostLikeWhereInput
  }

  export type PostShareListRelationFilter = {
    every?: PostShareWhereInput
    some?: PostShareWhereInput
    none?: PostShareWhereInput
  }

  export type PostSaveListRelationFilter = {
    every?: PostSaveWhereInput
    some?: PostSaveWhereInput
    none?: PostSaveWhereInput
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileFriendOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileBlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCommentLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostSaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileStatus | EnumProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumProfileStatusFilter<$PrismaModel>
  }

  export type ProfileFriendCountOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    profileIdOne?: SortOrder
    profileIdTwo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileFriendMaxOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    profileIdOne?: SortOrder
    profileIdTwo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileFriendMinOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    profileIdOne?: SortOrder
    profileIdTwo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBiographyAreaListRelationFilter = {
    every?: ProfileBiographyAreaWhereInput
    some?: ProfileBiographyAreaWhereInput
    none?: ProfileBiographyAreaWhereInput
  }

  export type ProfileBiographyAreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AreaMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AreaMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBiographySocialListRelationFilter = {
    every?: ProfileBiographySocialWhereInput
    some?: ProfileBiographySocialWhereInput
    none?: ProfileBiographySocialWhereInput
  }

  export type ProfileBiographySocialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileBiographyCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBiographyMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBiographyMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBiographyRelationFilter = {
    is?: ProfileBiographyWhereInput
    isNot?: ProfileBiographyWhereInput
  }

  export type AreaRelationFilter = {
    is?: AreaWhereInput
    isNot?: AreaWhereInput
  }

  export type ProfileBiographyAreaBiographyIdAreaIdCompoundUniqueInput = {
    biographyId: string
    areaId: string
  }

  export type ProfileBiographyAreaCountOrderByAggregateInput = {
    id?: SortOrder
    biographyId?: SortOrder
    areaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBiographyAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    biographyId?: SortOrder
    areaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBiographyAreaMinOrderByAggregateInput = {
    id?: SortOrder
    biographyId?: SortOrder
    areaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSocialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialType | EnumSocialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialType[] | ListEnumSocialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialType[] | ListEnumSocialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialTypeFilter<$PrismaModel> | $Enums.SocialType
  }

  export type ProfileBiographySocialTypeHrefCompoundUniqueInput = {
    type: $Enums.SocialType
    href: string
  }

  export type ProfileBiographySocialCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    href?: SortOrder
    profileBiographyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBiographySocialMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    href?: SortOrder
    profileBiographyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBiographySocialMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    href?: SortOrder
    profileBiographyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSocialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialType | EnumSocialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialType[] | ListEnumSocialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialType[] | ListEnumSocialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialTypeWithAggregatesFilter<$PrismaModel> | $Enums.SocialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialTypeFilter<$PrismaModel>
    _max?: NestedEnumSocialTypeFilter<$PrismaModel>
  }

  export type ProfileBlogImageListRelationFilter = {
    every?: ProfileBlogImageWhereInput
    some?: ProfileBlogImageWhereInput
    none?: ProfileBlogImageWhereInput
  }

  export type ProfileBlogImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileBlogCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBlogMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBlogMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileBlogRelationFilter = {
    is?: ProfileBlogWhereInput
    isNot?: ProfileBlogWhereInput
  }

  export type ProfileBlogImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    profileBlogId?: SortOrder
  }

  export type ProfileBlogImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    profileBlogId?: SortOrder
  }

  export type ProfileBlogImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    profileBlogId?: SortOrder
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type PostImageListRelationFilter = {
    every?: PostImageWhereInput
    some?: PostImageWhereInput
    none?: PostImageWhereInput
  }

  export type PostImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type PostImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    postId?: SortOrder
  }

  export type PostImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    postId?: SortOrder
  }

  export type PostImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    postId?: SortOrder
  }

  export type PostLikeProfileIdPostIdCompoundUniqueInput = {
    profileId: string
    postId: string
  }

  export type PostLikeCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
  }

  export type PostLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
  }

  export type PostLikeMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
  }

  export type PostShareProfileIdPostIdCompoundUniqueInput = {
    profileId: string
    postId: string
  }

  export type PostShareCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
  }

  export type PostShareMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
  }

  export type PostShareMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
  }

  export type PostSaveProfileIdPostIdCompoundUniqueInput = {
    profileId: string
    postId: string
  }

  export type PostSaveCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
  }

  export type PostSaveMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
  }

  export type PostSaveMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
  }

  export type PostCommentNullableRelationFilter = {
    is?: PostCommentWhereInput | null
    isNot?: PostCommentWhereInput | null
  }

  export type PostCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    image?: SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    image?: SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    image?: SortOrder
    isArchived?: SortOrder
    profileId?: SortOrder
    postId?: SortOrder
    parentCommentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostCommentRelationFilter = {
    is?: PostCommentWhereInput
    isNot?: PostCommentWhereInput
  }

  export type PostCommentLikeProfileIdPostCommentIdCompoundUniqueInput = {
    profileId: string
    postCommentId: string
  }

  export type PostCommentLikeCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postCommentId?: SortOrder
  }

  export type PostCommentLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postCommentId?: SortOrder
  }

  export type PostCommentLikeMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    postCommentId?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type ProfileGroupProfileIdGroupIdCompoundUniqueInput = {
    profileId: string
    groupId: string
  }

  export type ProfileGroupCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileGroupMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNewsTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NewsType | EnumNewsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NewsType[] | ListEnumNewsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NewsType[] | ListEnumNewsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNewsTypeFilter<$PrismaModel> | $Enums.NewsType
  }

  export type SchoolNullableRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type NewsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    cover?: SortOrder
    isPublished?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNewsTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NewsType | EnumNewsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NewsType[] | ListEnumNewsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NewsType[] | ListEnumNewsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNewsTypeWithAggregatesFilter<$PrismaModel> | $Enums.NewsType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNewsTypeFilter<$PrismaModel>
    _max?: NestedEnumNewsTypeFilter<$PrismaModel>
  }

  export type NewsRelationFilter = {
    is?: NewsWhereInput
    isNot?: NewsWhereInput
  }

  export type NewsNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    studentId?: SortOrder
    fromId?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    studentId?: SortOrder
    fromId?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    studentId?: SortOrder
    fromId?: SortOrder
    newsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentFollowStudentIdFollowerIdCompoundUniqueInput = {
    studentId: string
    followerId: string
  }

  export type StudentFollowCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    followerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentFollowMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    followerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentFollowMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    followerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactTitleFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTitle | EnumContactTitleFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTitle[] | ListEnumContactTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTitle[] | ListEnumContactTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTitleFilter<$PrismaModel> | $Enums.ContactTitle
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactTitleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTitle | EnumContactTitleFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTitle[] | ListEnumContactTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTitle[] | ListEnumContactTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTitleWithAggregatesFilter<$PrismaModel> | $Enums.ContactTitle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTitleFilter<$PrismaModel>
    _max?: NestedEnumContactTitleFilter<$PrismaModel>
  }

  export type TwoFactorConfirmationCreateNestedOneWithoutAccountInput = {
    create?: XOR<TwoFactorConfirmationCreateWithoutAccountInput, TwoFactorConfirmationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: TwoFactorConfirmationCreateOrConnectWithoutAccountInput
    connect?: TwoFactorConfirmationWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAccountInput = {
    create?: XOR<StudentCreateWithoutAccountInput, StudentUncheckedCreateWithoutAccountInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAccountInput
    connect?: StudentWhereUniqueInput
  }

  export type TwoFactorConfirmationUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<TwoFactorConfirmationCreateWithoutAccountInput, TwoFactorConfirmationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: TwoFactorConfirmationCreateOrConnectWithoutAccountInput
    connect?: TwoFactorConfirmationWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<StudentCreateWithoutAccountInput, StudentUncheckedCreateWithoutAccountInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAccountInput
    connect?: StudentWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TwoFactorConfirmationUpdateOneWithoutAccountNestedInput = {
    create?: XOR<TwoFactorConfirmationCreateWithoutAccountInput, TwoFactorConfirmationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: TwoFactorConfirmationCreateOrConnectWithoutAccountInput
    upsert?: TwoFactorConfirmationUpsertWithoutAccountInput
    disconnect?: TwoFactorConfirmationWhereInput | boolean
    delete?: TwoFactorConfirmationWhereInput | boolean
    connect?: TwoFactorConfirmationWhereUniqueInput
    update?: XOR<XOR<TwoFactorConfirmationUpdateToOneWithWhereWithoutAccountInput, TwoFactorConfirmationUpdateWithoutAccountInput>, TwoFactorConfirmationUncheckedUpdateWithoutAccountInput>
  }

  export type StudentUpdateOneWithoutAccountNestedInput = {
    create?: XOR<StudentCreateWithoutAccountInput, StudentUncheckedCreateWithoutAccountInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAccountInput
    upsert?: StudentUpsertWithoutAccountInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAccountInput, StudentUpdateWithoutAccountInput>, StudentUncheckedUpdateWithoutAccountInput>
  }

  export type TwoFactorConfirmationUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<TwoFactorConfirmationCreateWithoutAccountInput, TwoFactorConfirmationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: TwoFactorConfirmationCreateOrConnectWithoutAccountInput
    upsert?: TwoFactorConfirmationUpsertWithoutAccountInput
    disconnect?: TwoFactorConfirmationWhereInput | boolean
    delete?: TwoFactorConfirmationWhereInput | boolean
    connect?: TwoFactorConfirmationWhereUniqueInput
    update?: XOR<XOR<TwoFactorConfirmationUpdateToOneWithWhereWithoutAccountInput, TwoFactorConfirmationUpdateWithoutAccountInput>, TwoFactorConfirmationUncheckedUpdateWithoutAccountInput>
  }

  export type StudentUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<StudentCreateWithoutAccountInput, StudentUncheckedCreateWithoutAccountInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAccountInput
    upsert?: StudentUpsertWithoutAccountInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAccountInput, StudentUpdateWithoutAccountInput>, StudentUncheckedUpdateWithoutAccountInput>
  }

  export type AccountCreateNestedOneWithoutTwoFactorConfirmationInput = {
    create?: XOR<AccountCreateWithoutTwoFactorConfirmationInput, AccountUncheckedCreateWithoutTwoFactorConfirmationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTwoFactorConfirmationInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutTwoFactorConfirmationNestedInput = {
    create?: XOR<AccountCreateWithoutTwoFactorConfirmationInput, AccountUncheckedCreateWithoutTwoFactorConfirmationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTwoFactorConfirmationInput
    upsert?: AccountUpsertWithoutTwoFactorConfirmationInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTwoFactorConfirmationInput, AccountUpdateWithoutTwoFactorConfirmationInput>, AccountUncheckedUpdateWithoutTwoFactorConfirmationInput>
  }

  export type StudentCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SchoolLocationCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolLocationCreateWithoutSchoolInput, SchoolLocationUncheckedCreateWithoutSchoolInput> | SchoolLocationCreateWithoutSchoolInput[] | SchoolLocationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutSchoolInput | SchoolLocationCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolLocationCreateManySchoolInputEnvelope
    connect?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
  }

  export type SchoolProgramCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolProgramCreateWithoutSchoolInput, SchoolProgramUncheckedCreateWithoutSchoolInput> | SchoolProgramCreateWithoutSchoolInput[] | SchoolProgramUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolProgramCreateOrConnectWithoutSchoolInput | SchoolProgramCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolProgramCreateManySchoolInputEnvelope
    connect?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
  }

  export type SchoolGalleryCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolGalleryCreateWithoutSchoolInput, SchoolGalleryUncheckedCreateWithoutSchoolInput> | SchoolGalleryCreateWithoutSchoolInput[] | SchoolGalleryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolGalleryCreateOrConnectWithoutSchoolInput | SchoolGalleryCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolGalleryCreateManySchoolInputEnvelope
    connect?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
  }

  export type SchoolScholarshipCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolScholarshipCreateWithoutSchoolInput, SchoolScholarshipUncheckedCreateWithoutSchoolInput> | SchoolScholarshipCreateWithoutSchoolInput[] | SchoolScholarshipUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolScholarshipCreateOrConnectWithoutSchoolInput | SchoolScholarshipCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolScholarshipCreateManySchoolInputEnvelope
    connect?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
  }

  export type NewsCreateNestedManyWithoutSchoolInput = {
    create?: XOR<NewsCreateWithoutSchoolInput, NewsUncheckedCreateWithoutSchoolInput> | NewsCreateWithoutSchoolInput[] | NewsUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutSchoolInput | NewsCreateOrConnectWithoutSchoolInput[]
    createMany?: NewsCreateManySchoolInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ContactCreateWithoutSchoolInput, ContactUncheckedCreateWithoutSchoolInput> | ContactCreateWithoutSchoolInput[] | ContactUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSchoolInput | ContactCreateOrConnectWithoutSchoolInput[]
    createMany?: ContactCreateManySchoolInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SchoolLocationUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolLocationCreateWithoutSchoolInput, SchoolLocationUncheckedCreateWithoutSchoolInput> | SchoolLocationCreateWithoutSchoolInput[] | SchoolLocationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutSchoolInput | SchoolLocationCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolLocationCreateManySchoolInputEnvelope
    connect?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
  }

  export type SchoolProgramUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolProgramCreateWithoutSchoolInput, SchoolProgramUncheckedCreateWithoutSchoolInput> | SchoolProgramCreateWithoutSchoolInput[] | SchoolProgramUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolProgramCreateOrConnectWithoutSchoolInput | SchoolProgramCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolProgramCreateManySchoolInputEnvelope
    connect?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
  }

  export type SchoolGalleryUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolGalleryCreateWithoutSchoolInput, SchoolGalleryUncheckedCreateWithoutSchoolInput> | SchoolGalleryCreateWithoutSchoolInput[] | SchoolGalleryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolGalleryCreateOrConnectWithoutSchoolInput | SchoolGalleryCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolGalleryCreateManySchoolInputEnvelope
    connect?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
  }

  export type SchoolScholarshipUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SchoolScholarshipCreateWithoutSchoolInput, SchoolScholarshipUncheckedCreateWithoutSchoolInput> | SchoolScholarshipCreateWithoutSchoolInput[] | SchoolScholarshipUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolScholarshipCreateOrConnectWithoutSchoolInput | SchoolScholarshipCreateOrConnectWithoutSchoolInput[]
    createMany?: SchoolScholarshipCreateManySchoolInputEnvelope
    connect?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
  }

  export type NewsUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<NewsCreateWithoutSchoolInput, NewsUncheckedCreateWithoutSchoolInput> | NewsCreateWithoutSchoolInput[] | NewsUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutSchoolInput | NewsCreateOrConnectWithoutSchoolInput[]
    createMany?: NewsCreateManySchoolInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ContactCreateWithoutSchoolInput, ContactUncheckedCreateWithoutSchoolInput> | ContactCreateWithoutSchoolInput[] | ContactUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSchoolInput | ContactCreateOrConnectWithoutSchoolInput[]
    createMany?: ContactCreateManySchoolInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type EnumCountryFieldUpdateOperationsInput = {
    set?: $Enums.Country
  }

  export type StudentUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SchoolLocationUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolLocationCreateWithoutSchoolInput, SchoolLocationUncheckedCreateWithoutSchoolInput> | SchoolLocationCreateWithoutSchoolInput[] | SchoolLocationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutSchoolInput | SchoolLocationCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolLocationUpsertWithWhereUniqueWithoutSchoolInput | SchoolLocationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolLocationCreateManySchoolInputEnvelope
    set?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
    disconnect?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
    delete?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
    connect?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
    update?: SchoolLocationUpdateWithWhereUniqueWithoutSchoolInput | SchoolLocationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolLocationUpdateManyWithWhereWithoutSchoolInput | SchoolLocationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolLocationScalarWhereInput | SchoolLocationScalarWhereInput[]
  }

  export type SchoolProgramUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolProgramCreateWithoutSchoolInput, SchoolProgramUncheckedCreateWithoutSchoolInput> | SchoolProgramCreateWithoutSchoolInput[] | SchoolProgramUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolProgramCreateOrConnectWithoutSchoolInput | SchoolProgramCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolProgramUpsertWithWhereUniqueWithoutSchoolInput | SchoolProgramUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolProgramCreateManySchoolInputEnvelope
    set?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
    disconnect?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
    delete?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
    connect?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
    update?: SchoolProgramUpdateWithWhereUniqueWithoutSchoolInput | SchoolProgramUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolProgramUpdateManyWithWhereWithoutSchoolInput | SchoolProgramUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolProgramScalarWhereInput | SchoolProgramScalarWhereInput[]
  }

  export type SchoolGalleryUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolGalleryCreateWithoutSchoolInput, SchoolGalleryUncheckedCreateWithoutSchoolInput> | SchoolGalleryCreateWithoutSchoolInput[] | SchoolGalleryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolGalleryCreateOrConnectWithoutSchoolInput | SchoolGalleryCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolGalleryUpsertWithWhereUniqueWithoutSchoolInput | SchoolGalleryUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolGalleryCreateManySchoolInputEnvelope
    set?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
    disconnect?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
    delete?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
    connect?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
    update?: SchoolGalleryUpdateWithWhereUniqueWithoutSchoolInput | SchoolGalleryUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolGalleryUpdateManyWithWhereWithoutSchoolInput | SchoolGalleryUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolGalleryScalarWhereInput | SchoolGalleryScalarWhereInput[]
  }

  export type SchoolScholarshipUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolScholarshipCreateWithoutSchoolInput, SchoolScholarshipUncheckedCreateWithoutSchoolInput> | SchoolScholarshipCreateWithoutSchoolInput[] | SchoolScholarshipUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolScholarshipCreateOrConnectWithoutSchoolInput | SchoolScholarshipCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolScholarshipUpsertWithWhereUniqueWithoutSchoolInput | SchoolScholarshipUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolScholarshipCreateManySchoolInputEnvelope
    set?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
    disconnect?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
    delete?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
    connect?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
    update?: SchoolScholarshipUpdateWithWhereUniqueWithoutSchoolInput | SchoolScholarshipUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolScholarshipUpdateManyWithWhereWithoutSchoolInput | SchoolScholarshipUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolScholarshipScalarWhereInput | SchoolScholarshipScalarWhereInput[]
  }

  export type NewsUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<NewsCreateWithoutSchoolInput, NewsUncheckedCreateWithoutSchoolInput> | NewsCreateWithoutSchoolInput[] | NewsUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutSchoolInput | NewsCreateOrConnectWithoutSchoolInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutSchoolInput | NewsUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: NewsCreateManySchoolInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutSchoolInput | NewsUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutSchoolInput | NewsUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ContactCreateWithoutSchoolInput, ContactUncheckedCreateWithoutSchoolInput> | ContactCreateWithoutSchoolInput[] | ContactUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSchoolInput | ContactCreateOrConnectWithoutSchoolInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutSchoolInput | ContactUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ContactCreateManySchoolInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutSchoolInput | ContactUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutSchoolInput | ContactUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput> | StudentCreateWithoutSchoolInput[] | StudentUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutSchoolInput | StudentCreateOrConnectWithoutSchoolInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutSchoolInput | StudentUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: StudentCreateManySchoolInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutSchoolInput | StudentUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutSchoolInput | StudentUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SchoolLocationUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolLocationCreateWithoutSchoolInput, SchoolLocationUncheckedCreateWithoutSchoolInput> | SchoolLocationCreateWithoutSchoolInput[] | SchoolLocationUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutSchoolInput | SchoolLocationCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolLocationUpsertWithWhereUniqueWithoutSchoolInput | SchoolLocationUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolLocationCreateManySchoolInputEnvelope
    set?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
    disconnect?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
    delete?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
    connect?: SchoolLocationWhereUniqueInput | SchoolLocationWhereUniqueInput[]
    update?: SchoolLocationUpdateWithWhereUniqueWithoutSchoolInput | SchoolLocationUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolLocationUpdateManyWithWhereWithoutSchoolInput | SchoolLocationUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolLocationScalarWhereInput | SchoolLocationScalarWhereInput[]
  }

  export type SchoolProgramUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolProgramCreateWithoutSchoolInput, SchoolProgramUncheckedCreateWithoutSchoolInput> | SchoolProgramCreateWithoutSchoolInput[] | SchoolProgramUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolProgramCreateOrConnectWithoutSchoolInput | SchoolProgramCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolProgramUpsertWithWhereUniqueWithoutSchoolInput | SchoolProgramUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolProgramCreateManySchoolInputEnvelope
    set?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
    disconnect?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
    delete?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
    connect?: SchoolProgramWhereUniqueInput | SchoolProgramWhereUniqueInput[]
    update?: SchoolProgramUpdateWithWhereUniqueWithoutSchoolInput | SchoolProgramUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolProgramUpdateManyWithWhereWithoutSchoolInput | SchoolProgramUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolProgramScalarWhereInput | SchoolProgramScalarWhereInput[]
  }

  export type SchoolGalleryUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolGalleryCreateWithoutSchoolInput, SchoolGalleryUncheckedCreateWithoutSchoolInput> | SchoolGalleryCreateWithoutSchoolInput[] | SchoolGalleryUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolGalleryCreateOrConnectWithoutSchoolInput | SchoolGalleryCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolGalleryUpsertWithWhereUniqueWithoutSchoolInput | SchoolGalleryUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolGalleryCreateManySchoolInputEnvelope
    set?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
    disconnect?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
    delete?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
    connect?: SchoolGalleryWhereUniqueInput | SchoolGalleryWhereUniqueInput[]
    update?: SchoolGalleryUpdateWithWhereUniqueWithoutSchoolInput | SchoolGalleryUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolGalleryUpdateManyWithWhereWithoutSchoolInput | SchoolGalleryUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolGalleryScalarWhereInput | SchoolGalleryScalarWhereInput[]
  }

  export type SchoolScholarshipUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SchoolScholarshipCreateWithoutSchoolInput, SchoolScholarshipUncheckedCreateWithoutSchoolInput> | SchoolScholarshipCreateWithoutSchoolInput[] | SchoolScholarshipUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SchoolScholarshipCreateOrConnectWithoutSchoolInput | SchoolScholarshipCreateOrConnectWithoutSchoolInput[]
    upsert?: SchoolScholarshipUpsertWithWhereUniqueWithoutSchoolInput | SchoolScholarshipUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SchoolScholarshipCreateManySchoolInputEnvelope
    set?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
    disconnect?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
    delete?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
    connect?: SchoolScholarshipWhereUniqueInput | SchoolScholarshipWhereUniqueInput[]
    update?: SchoolScholarshipUpdateWithWhereUniqueWithoutSchoolInput | SchoolScholarshipUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SchoolScholarshipUpdateManyWithWhereWithoutSchoolInput | SchoolScholarshipUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SchoolScholarshipScalarWhereInput | SchoolScholarshipScalarWhereInput[]
  }

  export type NewsUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<NewsCreateWithoutSchoolInput, NewsUncheckedCreateWithoutSchoolInput> | NewsCreateWithoutSchoolInput[] | NewsUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutSchoolInput | NewsCreateOrConnectWithoutSchoolInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutSchoolInput | NewsUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: NewsCreateManySchoolInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutSchoolInput | NewsUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutSchoolInput | NewsUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ContactCreateWithoutSchoolInput, ContactUncheckedCreateWithoutSchoolInput> | ContactCreateWithoutSchoolInput[] | ContactUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSchoolInput | ContactCreateOrConnectWithoutSchoolInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutSchoolInput | ContactUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ContactCreateManySchoolInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutSchoolInput | ContactUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutSchoolInput | ContactUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutScholarshipsInput = {
    create?: XOR<SchoolCreateWithoutScholarshipsInput, SchoolUncheckedCreateWithoutScholarshipsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutScholarshipsInput
    connect?: SchoolWhereUniqueInput
  }

  export type StudentSchoolScholarshipCreateNestedManyWithoutScholarshipInput = {
    create?: XOR<StudentSchoolScholarshipCreateWithoutScholarshipInput, StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput> | StudentSchoolScholarshipCreateWithoutScholarshipInput[] | StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: StudentSchoolScholarshipCreateOrConnectWithoutScholarshipInput | StudentSchoolScholarshipCreateOrConnectWithoutScholarshipInput[]
    createMany?: StudentSchoolScholarshipCreateManyScholarshipInputEnvelope
    connect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
  }

  export type SchoolScholarshipImageCreateNestedManyWithoutScholarshipInput = {
    create?: XOR<SchoolScholarshipImageCreateWithoutScholarshipInput, SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput> | SchoolScholarshipImageCreateWithoutScholarshipInput[] | SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: SchoolScholarshipImageCreateOrConnectWithoutScholarshipInput | SchoolScholarshipImageCreateOrConnectWithoutScholarshipInput[]
    createMany?: SchoolScholarshipImageCreateManyScholarshipInputEnvelope
    connect?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
  }

  export type StudentSchoolScholarshipUncheckedCreateNestedManyWithoutScholarshipInput = {
    create?: XOR<StudentSchoolScholarshipCreateWithoutScholarshipInput, StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput> | StudentSchoolScholarshipCreateWithoutScholarshipInput[] | StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: StudentSchoolScholarshipCreateOrConnectWithoutScholarshipInput | StudentSchoolScholarshipCreateOrConnectWithoutScholarshipInput[]
    createMany?: StudentSchoolScholarshipCreateManyScholarshipInputEnvelope
    connect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
  }

  export type SchoolScholarshipImageUncheckedCreateNestedManyWithoutScholarshipInput = {
    create?: XOR<SchoolScholarshipImageCreateWithoutScholarshipInput, SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput> | SchoolScholarshipImageCreateWithoutScholarshipInput[] | SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: SchoolScholarshipImageCreateOrConnectWithoutScholarshipInput | SchoolScholarshipImageCreateOrConnectWithoutScholarshipInput[]
    createMany?: SchoolScholarshipImageCreateManyScholarshipInputEnvelope
    connect?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutScholarshipsNestedInput = {
    create?: XOR<SchoolCreateWithoutScholarshipsInput, SchoolUncheckedCreateWithoutScholarshipsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutScholarshipsInput
    upsert?: SchoolUpsertWithoutScholarshipsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutScholarshipsInput, SchoolUpdateWithoutScholarshipsInput>, SchoolUncheckedUpdateWithoutScholarshipsInput>
  }

  export type StudentSchoolScholarshipUpdateManyWithoutScholarshipNestedInput = {
    create?: XOR<StudentSchoolScholarshipCreateWithoutScholarshipInput, StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput> | StudentSchoolScholarshipCreateWithoutScholarshipInput[] | StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: StudentSchoolScholarshipCreateOrConnectWithoutScholarshipInput | StudentSchoolScholarshipCreateOrConnectWithoutScholarshipInput[]
    upsert?: StudentSchoolScholarshipUpsertWithWhereUniqueWithoutScholarshipInput | StudentSchoolScholarshipUpsertWithWhereUniqueWithoutScholarshipInput[]
    createMany?: StudentSchoolScholarshipCreateManyScholarshipInputEnvelope
    set?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    disconnect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    delete?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    connect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    update?: StudentSchoolScholarshipUpdateWithWhereUniqueWithoutScholarshipInput | StudentSchoolScholarshipUpdateWithWhereUniqueWithoutScholarshipInput[]
    updateMany?: StudentSchoolScholarshipUpdateManyWithWhereWithoutScholarshipInput | StudentSchoolScholarshipUpdateManyWithWhereWithoutScholarshipInput[]
    deleteMany?: StudentSchoolScholarshipScalarWhereInput | StudentSchoolScholarshipScalarWhereInput[]
  }

  export type SchoolScholarshipImageUpdateManyWithoutScholarshipNestedInput = {
    create?: XOR<SchoolScholarshipImageCreateWithoutScholarshipInput, SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput> | SchoolScholarshipImageCreateWithoutScholarshipInput[] | SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: SchoolScholarshipImageCreateOrConnectWithoutScholarshipInput | SchoolScholarshipImageCreateOrConnectWithoutScholarshipInput[]
    upsert?: SchoolScholarshipImageUpsertWithWhereUniqueWithoutScholarshipInput | SchoolScholarshipImageUpsertWithWhereUniqueWithoutScholarshipInput[]
    createMany?: SchoolScholarshipImageCreateManyScholarshipInputEnvelope
    set?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
    disconnect?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
    delete?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
    connect?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
    update?: SchoolScholarshipImageUpdateWithWhereUniqueWithoutScholarshipInput | SchoolScholarshipImageUpdateWithWhereUniqueWithoutScholarshipInput[]
    updateMany?: SchoolScholarshipImageUpdateManyWithWhereWithoutScholarshipInput | SchoolScholarshipImageUpdateManyWithWhereWithoutScholarshipInput[]
    deleteMany?: SchoolScholarshipImageScalarWhereInput | SchoolScholarshipImageScalarWhereInput[]
  }

  export type StudentSchoolScholarshipUncheckedUpdateManyWithoutScholarshipNestedInput = {
    create?: XOR<StudentSchoolScholarshipCreateWithoutScholarshipInput, StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput> | StudentSchoolScholarshipCreateWithoutScholarshipInput[] | StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: StudentSchoolScholarshipCreateOrConnectWithoutScholarshipInput | StudentSchoolScholarshipCreateOrConnectWithoutScholarshipInput[]
    upsert?: StudentSchoolScholarshipUpsertWithWhereUniqueWithoutScholarshipInput | StudentSchoolScholarshipUpsertWithWhereUniqueWithoutScholarshipInput[]
    createMany?: StudentSchoolScholarshipCreateManyScholarshipInputEnvelope
    set?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    disconnect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    delete?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    connect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    update?: StudentSchoolScholarshipUpdateWithWhereUniqueWithoutScholarshipInput | StudentSchoolScholarshipUpdateWithWhereUniqueWithoutScholarshipInput[]
    updateMany?: StudentSchoolScholarshipUpdateManyWithWhereWithoutScholarshipInput | StudentSchoolScholarshipUpdateManyWithWhereWithoutScholarshipInput[]
    deleteMany?: StudentSchoolScholarshipScalarWhereInput | StudentSchoolScholarshipScalarWhereInput[]
  }

  export type SchoolScholarshipImageUncheckedUpdateManyWithoutScholarshipNestedInput = {
    create?: XOR<SchoolScholarshipImageCreateWithoutScholarshipInput, SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput> | SchoolScholarshipImageCreateWithoutScholarshipInput[] | SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: SchoolScholarshipImageCreateOrConnectWithoutScholarshipInput | SchoolScholarshipImageCreateOrConnectWithoutScholarshipInput[]
    upsert?: SchoolScholarshipImageUpsertWithWhereUniqueWithoutScholarshipInput | SchoolScholarshipImageUpsertWithWhereUniqueWithoutScholarshipInput[]
    createMany?: SchoolScholarshipImageCreateManyScholarshipInputEnvelope
    set?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
    disconnect?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
    delete?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
    connect?: SchoolScholarshipImageWhereUniqueInput | SchoolScholarshipImageWhereUniqueInput[]
    update?: SchoolScholarshipImageUpdateWithWhereUniqueWithoutScholarshipInput | SchoolScholarshipImageUpdateWithWhereUniqueWithoutScholarshipInput[]
    updateMany?: SchoolScholarshipImageUpdateManyWithWhereWithoutScholarshipInput | SchoolScholarshipImageUpdateManyWithWhereWithoutScholarshipInput[]
    deleteMany?: SchoolScholarshipImageScalarWhereInput | SchoolScholarshipImageScalarWhereInput[]
  }

  export type SchoolScholarshipCreateNestedOneWithoutImagesInput = {
    create?: XOR<SchoolScholarshipCreateWithoutImagesInput, SchoolScholarshipUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SchoolScholarshipCreateOrConnectWithoutImagesInput
    connect?: SchoolScholarshipWhereUniqueInput
  }

  export type SchoolScholarshipUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<SchoolScholarshipCreateWithoutImagesInput, SchoolScholarshipUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SchoolScholarshipCreateOrConnectWithoutImagesInput
    upsert?: SchoolScholarshipUpsertWithoutImagesInput
    connect?: SchoolScholarshipWhereUniqueInput
    update?: XOR<XOR<SchoolScholarshipUpdateToOneWithWhereWithoutImagesInput, SchoolScholarshipUpdateWithoutImagesInput>, SchoolScholarshipUncheckedUpdateWithoutImagesInput>
  }

  export type StudentCreateNestedOneWithoutScholarshipInput = {
    create?: XOR<StudentCreateWithoutScholarshipInput, StudentUncheckedCreateWithoutScholarshipInput>
    connectOrCreate?: StudentCreateOrConnectWithoutScholarshipInput
    connect?: StudentWhereUniqueInput
  }

  export type SchoolScholarshipCreateNestedOneWithoutOwnersInput = {
    create?: XOR<SchoolScholarshipCreateWithoutOwnersInput, SchoolScholarshipUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: SchoolScholarshipCreateOrConnectWithoutOwnersInput
    connect?: SchoolScholarshipWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutScholarshipNestedInput = {
    create?: XOR<StudentCreateWithoutScholarshipInput, StudentUncheckedCreateWithoutScholarshipInput>
    connectOrCreate?: StudentCreateOrConnectWithoutScholarshipInput
    upsert?: StudentUpsertWithoutScholarshipInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutScholarshipInput, StudentUpdateWithoutScholarshipInput>, StudentUncheckedUpdateWithoutScholarshipInput>
  }

  export type SchoolScholarshipUpdateOneRequiredWithoutOwnersNestedInput = {
    create?: XOR<SchoolScholarshipCreateWithoutOwnersInput, SchoolScholarshipUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: SchoolScholarshipCreateOrConnectWithoutOwnersInput
    upsert?: SchoolScholarshipUpsertWithoutOwnersInput
    connect?: SchoolScholarshipWhereUniqueInput
    update?: XOR<XOR<SchoolScholarshipUpdateToOneWithWhereWithoutOwnersInput, SchoolScholarshipUpdateWithoutOwnersInput>, SchoolScholarshipUncheckedUpdateWithoutOwnersInput>
  }

  export type SchoolGalleryImageCreateNestedManyWithoutGalleryInput = {
    create?: XOR<SchoolGalleryImageCreateWithoutGalleryInput, SchoolGalleryImageUncheckedCreateWithoutGalleryInput> | SchoolGalleryImageCreateWithoutGalleryInput[] | SchoolGalleryImageUncheckedCreateWithoutGalleryInput[]
    connectOrCreate?: SchoolGalleryImageCreateOrConnectWithoutGalleryInput | SchoolGalleryImageCreateOrConnectWithoutGalleryInput[]
    createMany?: SchoolGalleryImageCreateManyGalleryInputEnvelope
    connect?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
  }

  export type SchoolCreateNestedOneWithoutGalleriesInput = {
    create?: XOR<SchoolCreateWithoutGalleriesInput, SchoolUncheckedCreateWithoutGalleriesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutGalleriesInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolGalleryImageUncheckedCreateNestedManyWithoutGalleryInput = {
    create?: XOR<SchoolGalleryImageCreateWithoutGalleryInput, SchoolGalleryImageUncheckedCreateWithoutGalleryInput> | SchoolGalleryImageCreateWithoutGalleryInput[] | SchoolGalleryImageUncheckedCreateWithoutGalleryInput[]
    connectOrCreate?: SchoolGalleryImageCreateOrConnectWithoutGalleryInput | SchoolGalleryImageCreateOrConnectWithoutGalleryInput[]
    createMany?: SchoolGalleryImageCreateManyGalleryInputEnvelope
    connect?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
  }

  export type SchoolGalleryImageUpdateManyWithoutGalleryNestedInput = {
    create?: XOR<SchoolGalleryImageCreateWithoutGalleryInput, SchoolGalleryImageUncheckedCreateWithoutGalleryInput> | SchoolGalleryImageCreateWithoutGalleryInput[] | SchoolGalleryImageUncheckedCreateWithoutGalleryInput[]
    connectOrCreate?: SchoolGalleryImageCreateOrConnectWithoutGalleryInput | SchoolGalleryImageCreateOrConnectWithoutGalleryInput[]
    upsert?: SchoolGalleryImageUpsertWithWhereUniqueWithoutGalleryInput | SchoolGalleryImageUpsertWithWhereUniqueWithoutGalleryInput[]
    createMany?: SchoolGalleryImageCreateManyGalleryInputEnvelope
    set?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
    disconnect?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
    delete?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
    connect?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
    update?: SchoolGalleryImageUpdateWithWhereUniqueWithoutGalleryInput | SchoolGalleryImageUpdateWithWhereUniqueWithoutGalleryInput[]
    updateMany?: SchoolGalleryImageUpdateManyWithWhereWithoutGalleryInput | SchoolGalleryImageUpdateManyWithWhereWithoutGalleryInput[]
    deleteMany?: SchoolGalleryImageScalarWhereInput | SchoolGalleryImageScalarWhereInput[]
  }

  export type SchoolUpdateOneRequiredWithoutGalleriesNestedInput = {
    create?: XOR<SchoolCreateWithoutGalleriesInput, SchoolUncheckedCreateWithoutGalleriesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutGalleriesInput
    upsert?: SchoolUpsertWithoutGalleriesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutGalleriesInput, SchoolUpdateWithoutGalleriesInput>, SchoolUncheckedUpdateWithoutGalleriesInput>
  }

  export type SchoolGalleryImageUncheckedUpdateManyWithoutGalleryNestedInput = {
    create?: XOR<SchoolGalleryImageCreateWithoutGalleryInput, SchoolGalleryImageUncheckedCreateWithoutGalleryInput> | SchoolGalleryImageCreateWithoutGalleryInput[] | SchoolGalleryImageUncheckedCreateWithoutGalleryInput[]
    connectOrCreate?: SchoolGalleryImageCreateOrConnectWithoutGalleryInput | SchoolGalleryImageCreateOrConnectWithoutGalleryInput[]
    upsert?: SchoolGalleryImageUpsertWithWhereUniqueWithoutGalleryInput | SchoolGalleryImageUpsertWithWhereUniqueWithoutGalleryInput[]
    createMany?: SchoolGalleryImageCreateManyGalleryInputEnvelope
    set?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
    disconnect?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
    delete?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
    connect?: SchoolGalleryImageWhereUniqueInput | SchoolGalleryImageWhereUniqueInput[]
    update?: SchoolGalleryImageUpdateWithWhereUniqueWithoutGalleryInput | SchoolGalleryImageUpdateWithWhereUniqueWithoutGalleryInput[]
    updateMany?: SchoolGalleryImageUpdateManyWithWhereWithoutGalleryInput | SchoolGalleryImageUpdateManyWithWhereWithoutGalleryInput[]
    deleteMany?: SchoolGalleryImageScalarWhereInput | SchoolGalleryImageScalarWhereInput[]
  }

  export type SchoolGalleryCreateNestedOneWithoutImagesInput = {
    create?: XOR<SchoolGalleryCreateWithoutImagesInput, SchoolGalleryUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SchoolGalleryCreateOrConnectWithoutImagesInput
    connect?: SchoolGalleryWhereUniqueInput
  }

  export type SchoolGalleryUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<SchoolGalleryCreateWithoutImagesInput, SchoolGalleryUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SchoolGalleryCreateOrConnectWithoutImagesInput
    upsert?: SchoolGalleryUpsertWithoutImagesInput
    connect?: SchoolGalleryWhereUniqueInput
    update?: XOR<XOR<SchoolGalleryUpdateToOneWithWhereWithoutImagesInput, SchoolGalleryUpdateWithoutImagesInput>, SchoolGalleryUncheckedUpdateWithoutImagesInput>
  }

  export type SchoolLocationImageCreateNestedManyWithoutLocationInput = {
    create?: XOR<SchoolLocationImageCreateWithoutLocationInput, SchoolLocationImageUncheckedCreateWithoutLocationInput> | SchoolLocationImageCreateWithoutLocationInput[] | SchoolLocationImageUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SchoolLocationImageCreateOrConnectWithoutLocationInput | SchoolLocationImageCreateOrConnectWithoutLocationInput[]
    createMany?: SchoolLocationImageCreateManyLocationInputEnvelope
    connect?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
  }

  export type SchoolLocationContactCreateNestedManyWithoutLocationInput = {
    create?: XOR<SchoolLocationContactCreateWithoutLocationInput, SchoolLocationContactUncheckedCreateWithoutLocationInput> | SchoolLocationContactCreateWithoutLocationInput[] | SchoolLocationContactUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SchoolLocationContactCreateOrConnectWithoutLocationInput | SchoolLocationContactCreateOrConnectWithoutLocationInput[]
    createMany?: SchoolLocationContactCreateManyLocationInputEnvelope
    connect?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
  }

  export type StudentSchoolLocationCreateNestedManyWithoutLocationInput = {
    create?: XOR<StudentSchoolLocationCreateWithoutLocationInput, StudentSchoolLocationUncheckedCreateWithoutLocationInput> | StudentSchoolLocationCreateWithoutLocationInput[] | StudentSchoolLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StudentSchoolLocationCreateOrConnectWithoutLocationInput | StudentSchoolLocationCreateOrConnectWithoutLocationInput[]
    createMany?: StudentSchoolLocationCreateManyLocationInputEnvelope
    connect?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
  }

  export type SchoolCreateNestedOneWithoutLocationsInput = {
    create?: XOR<SchoolCreateWithoutLocationsInput, SchoolUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutLocationsInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolLocationImageUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<SchoolLocationImageCreateWithoutLocationInput, SchoolLocationImageUncheckedCreateWithoutLocationInput> | SchoolLocationImageCreateWithoutLocationInput[] | SchoolLocationImageUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SchoolLocationImageCreateOrConnectWithoutLocationInput | SchoolLocationImageCreateOrConnectWithoutLocationInput[]
    createMany?: SchoolLocationImageCreateManyLocationInputEnvelope
    connect?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
  }

  export type SchoolLocationContactUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<SchoolLocationContactCreateWithoutLocationInput, SchoolLocationContactUncheckedCreateWithoutLocationInput> | SchoolLocationContactCreateWithoutLocationInput[] | SchoolLocationContactUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SchoolLocationContactCreateOrConnectWithoutLocationInput | SchoolLocationContactCreateOrConnectWithoutLocationInput[]
    createMany?: SchoolLocationContactCreateManyLocationInputEnvelope
    connect?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
  }

  export type StudentSchoolLocationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<StudentSchoolLocationCreateWithoutLocationInput, StudentSchoolLocationUncheckedCreateWithoutLocationInput> | StudentSchoolLocationCreateWithoutLocationInput[] | StudentSchoolLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StudentSchoolLocationCreateOrConnectWithoutLocationInput | StudentSchoolLocationCreateOrConnectWithoutLocationInput[]
    createMany?: StudentSchoolLocationCreateManyLocationInputEnvelope
    connect?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
  }

  export type SchoolLocationImageUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SchoolLocationImageCreateWithoutLocationInput, SchoolLocationImageUncheckedCreateWithoutLocationInput> | SchoolLocationImageCreateWithoutLocationInput[] | SchoolLocationImageUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SchoolLocationImageCreateOrConnectWithoutLocationInput | SchoolLocationImageCreateOrConnectWithoutLocationInput[]
    upsert?: SchoolLocationImageUpsertWithWhereUniqueWithoutLocationInput | SchoolLocationImageUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SchoolLocationImageCreateManyLocationInputEnvelope
    set?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
    disconnect?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
    delete?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
    connect?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
    update?: SchoolLocationImageUpdateWithWhereUniqueWithoutLocationInput | SchoolLocationImageUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SchoolLocationImageUpdateManyWithWhereWithoutLocationInput | SchoolLocationImageUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SchoolLocationImageScalarWhereInput | SchoolLocationImageScalarWhereInput[]
  }

  export type SchoolLocationContactUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SchoolLocationContactCreateWithoutLocationInput, SchoolLocationContactUncheckedCreateWithoutLocationInput> | SchoolLocationContactCreateWithoutLocationInput[] | SchoolLocationContactUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SchoolLocationContactCreateOrConnectWithoutLocationInput | SchoolLocationContactCreateOrConnectWithoutLocationInput[]
    upsert?: SchoolLocationContactUpsertWithWhereUniqueWithoutLocationInput | SchoolLocationContactUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SchoolLocationContactCreateManyLocationInputEnvelope
    set?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
    disconnect?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
    delete?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
    connect?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
    update?: SchoolLocationContactUpdateWithWhereUniqueWithoutLocationInput | SchoolLocationContactUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SchoolLocationContactUpdateManyWithWhereWithoutLocationInput | SchoolLocationContactUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SchoolLocationContactScalarWhereInput | SchoolLocationContactScalarWhereInput[]
  }

  export type StudentSchoolLocationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StudentSchoolLocationCreateWithoutLocationInput, StudentSchoolLocationUncheckedCreateWithoutLocationInput> | StudentSchoolLocationCreateWithoutLocationInput[] | StudentSchoolLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StudentSchoolLocationCreateOrConnectWithoutLocationInput | StudentSchoolLocationCreateOrConnectWithoutLocationInput[]
    upsert?: StudentSchoolLocationUpsertWithWhereUniqueWithoutLocationInput | StudentSchoolLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StudentSchoolLocationCreateManyLocationInputEnvelope
    set?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
    disconnect?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
    delete?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
    connect?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
    update?: StudentSchoolLocationUpdateWithWhereUniqueWithoutLocationInput | StudentSchoolLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StudentSchoolLocationUpdateManyWithWhereWithoutLocationInput | StudentSchoolLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StudentSchoolLocationScalarWhereInput | StudentSchoolLocationScalarWhereInput[]
  }

  export type SchoolUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<SchoolCreateWithoutLocationsInput, SchoolUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutLocationsInput
    upsert?: SchoolUpsertWithoutLocationsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutLocationsInput, SchoolUpdateWithoutLocationsInput>, SchoolUncheckedUpdateWithoutLocationsInput>
  }

  export type SchoolLocationImageUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SchoolLocationImageCreateWithoutLocationInput, SchoolLocationImageUncheckedCreateWithoutLocationInput> | SchoolLocationImageCreateWithoutLocationInput[] | SchoolLocationImageUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SchoolLocationImageCreateOrConnectWithoutLocationInput | SchoolLocationImageCreateOrConnectWithoutLocationInput[]
    upsert?: SchoolLocationImageUpsertWithWhereUniqueWithoutLocationInput | SchoolLocationImageUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SchoolLocationImageCreateManyLocationInputEnvelope
    set?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
    disconnect?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
    delete?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
    connect?: SchoolLocationImageWhereUniqueInput | SchoolLocationImageWhereUniqueInput[]
    update?: SchoolLocationImageUpdateWithWhereUniqueWithoutLocationInput | SchoolLocationImageUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SchoolLocationImageUpdateManyWithWhereWithoutLocationInput | SchoolLocationImageUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SchoolLocationImageScalarWhereInput | SchoolLocationImageScalarWhereInput[]
  }

  export type SchoolLocationContactUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SchoolLocationContactCreateWithoutLocationInput, SchoolLocationContactUncheckedCreateWithoutLocationInput> | SchoolLocationContactCreateWithoutLocationInput[] | SchoolLocationContactUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SchoolLocationContactCreateOrConnectWithoutLocationInput | SchoolLocationContactCreateOrConnectWithoutLocationInput[]
    upsert?: SchoolLocationContactUpsertWithWhereUniqueWithoutLocationInput | SchoolLocationContactUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SchoolLocationContactCreateManyLocationInputEnvelope
    set?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
    disconnect?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
    delete?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
    connect?: SchoolLocationContactWhereUniqueInput | SchoolLocationContactWhereUniqueInput[]
    update?: SchoolLocationContactUpdateWithWhereUniqueWithoutLocationInput | SchoolLocationContactUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SchoolLocationContactUpdateManyWithWhereWithoutLocationInput | SchoolLocationContactUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SchoolLocationContactScalarWhereInput | SchoolLocationContactScalarWhereInput[]
  }

  export type StudentSchoolLocationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StudentSchoolLocationCreateWithoutLocationInput, StudentSchoolLocationUncheckedCreateWithoutLocationInput> | StudentSchoolLocationCreateWithoutLocationInput[] | StudentSchoolLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StudentSchoolLocationCreateOrConnectWithoutLocationInput | StudentSchoolLocationCreateOrConnectWithoutLocationInput[]
    upsert?: StudentSchoolLocationUpsertWithWhereUniqueWithoutLocationInput | StudentSchoolLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StudentSchoolLocationCreateManyLocationInputEnvelope
    set?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
    disconnect?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
    delete?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
    connect?: StudentSchoolLocationWhereUniqueInput | StudentSchoolLocationWhereUniqueInput[]
    update?: StudentSchoolLocationUpdateWithWhereUniqueWithoutLocationInput | StudentSchoolLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StudentSchoolLocationUpdateManyWithWhereWithoutLocationInput | StudentSchoolLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StudentSchoolLocationScalarWhereInput | StudentSchoolLocationScalarWhereInput[]
  }

  export type SchoolLocationCreateNestedOneWithoutImagesInput = {
    create?: XOR<SchoolLocationCreateWithoutImagesInput, SchoolLocationUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutImagesInput
    connect?: SchoolLocationWhereUniqueInput
  }

  export type SchoolLocationUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<SchoolLocationCreateWithoutImagesInput, SchoolLocationUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutImagesInput
    upsert?: SchoolLocationUpsertWithoutImagesInput
    connect?: SchoolLocationWhereUniqueInput
    update?: XOR<XOR<SchoolLocationUpdateToOneWithWhereWithoutImagesInput, SchoolLocationUpdateWithoutImagesInput>, SchoolLocationUncheckedUpdateWithoutImagesInput>
  }

  export type SchoolLocationCreateNestedOneWithoutContactsInput = {
    create?: XOR<SchoolLocationCreateWithoutContactsInput, SchoolLocationUncheckedCreateWithoutContactsInput>
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutContactsInput
    connect?: SchoolLocationWhereUniqueInput
  }

  export type SchoolLocationUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<SchoolLocationCreateWithoutContactsInput, SchoolLocationUncheckedCreateWithoutContactsInput>
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutContactsInput
    upsert?: SchoolLocationUpsertWithoutContactsInput
    connect?: SchoolLocationWhereUniqueInput
    update?: XOR<XOR<SchoolLocationUpdateToOneWithWhereWithoutContactsInput, SchoolLocationUpdateWithoutContactsInput>, SchoolLocationUncheckedUpdateWithoutContactsInput>
  }

  export type SchoolCreateNestedOneWithoutProgramsInput = {
    create?: XOR<SchoolCreateWithoutProgramsInput, SchoolUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutProgramsInput
    connect?: SchoolWhereUniqueInput
  }

  export type StudentSchoolProgramCreateNestedManyWithoutProgramInput = {
    create?: XOR<StudentSchoolProgramCreateWithoutProgramInput, StudentSchoolProgramUncheckedCreateWithoutProgramInput> | StudentSchoolProgramCreateWithoutProgramInput[] | StudentSchoolProgramUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentSchoolProgramCreateOrConnectWithoutProgramInput | StudentSchoolProgramCreateOrConnectWithoutProgramInput[]
    createMany?: StudentSchoolProgramCreateManyProgramInputEnvelope
    connect?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
  }

  export type SchoolProgramImageCreateNestedManyWithoutProgramInput = {
    create?: XOR<SchoolProgramImageCreateWithoutProgramInput, SchoolProgramImageUncheckedCreateWithoutProgramInput> | SchoolProgramImageCreateWithoutProgramInput[] | SchoolProgramImageUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SchoolProgramImageCreateOrConnectWithoutProgramInput | SchoolProgramImageCreateOrConnectWithoutProgramInput[]
    createMany?: SchoolProgramImageCreateManyProgramInputEnvelope
    connect?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
  }

  export type StudentSchoolProgramUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<StudentSchoolProgramCreateWithoutProgramInput, StudentSchoolProgramUncheckedCreateWithoutProgramInput> | StudentSchoolProgramCreateWithoutProgramInput[] | StudentSchoolProgramUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentSchoolProgramCreateOrConnectWithoutProgramInput | StudentSchoolProgramCreateOrConnectWithoutProgramInput[]
    createMany?: StudentSchoolProgramCreateManyProgramInputEnvelope
    connect?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
  }

  export type SchoolProgramImageUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<SchoolProgramImageCreateWithoutProgramInput, SchoolProgramImageUncheckedCreateWithoutProgramInput> | SchoolProgramImageCreateWithoutProgramInput[] | SchoolProgramImageUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SchoolProgramImageCreateOrConnectWithoutProgramInput | SchoolProgramImageCreateOrConnectWithoutProgramInput[]
    createMany?: SchoolProgramImageCreateManyProgramInputEnvelope
    connect?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<SchoolCreateWithoutProgramsInput, SchoolUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutProgramsInput
    upsert?: SchoolUpsertWithoutProgramsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutProgramsInput, SchoolUpdateWithoutProgramsInput>, SchoolUncheckedUpdateWithoutProgramsInput>
  }

  export type StudentSchoolProgramUpdateManyWithoutProgramNestedInput = {
    create?: XOR<StudentSchoolProgramCreateWithoutProgramInput, StudentSchoolProgramUncheckedCreateWithoutProgramInput> | StudentSchoolProgramCreateWithoutProgramInput[] | StudentSchoolProgramUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentSchoolProgramCreateOrConnectWithoutProgramInput | StudentSchoolProgramCreateOrConnectWithoutProgramInput[]
    upsert?: StudentSchoolProgramUpsertWithWhereUniqueWithoutProgramInput | StudentSchoolProgramUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: StudentSchoolProgramCreateManyProgramInputEnvelope
    set?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
    disconnect?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
    delete?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
    connect?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
    update?: StudentSchoolProgramUpdateWithWhereUniqueWithoutProgramInput | StudentSchoolProgramUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: StudentSchoolProgramUpdateManyWithWhereWithoutProgramInput | StudentSchoolProgramUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: StudentSchoolProgramScalarWhereInput | StudentSchoolProgramScalarWhereInput[]
  }

  export type SchoolProgramImageUpdateManyWithoutProgramNestedInput = {
    create?: XOR<SchoolProgramImageCreateWithoutProgramInput, SchoolProgramImageUncheckedCreateWithoutProgramInput> | SchoolProgramImageCreateWithoutProgramInput[] | SchoolProgramImageUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SchoolProgramImageCreateOrConnectWithoutProgramInput | SchoolProgramImageCreateOrConnectWithoutProgramInput[]
    upsert?: SchoolProgramImageUpsertWithWhereUniqueWithoutProgramInput | SchoolProgramImageUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: SchoolProgramImageCreateManyProgramInputEnvelope
    set?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
    disconnect?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
    delete?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
    connect?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
    update?: SchoolProgramImageUpdateWithWhereUniqueWithoutProgramInput | SchoolProgramImageUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: SchoolProgramImageUpdateManyWithWhereWithoutProgramInput | SchoolProgramImageUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: SchoolProgramImageScalarWhereInput | SchoolProgramImageScalarWhereInput[]
  }

  export type StudentSchoolProgramUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<StudentSchoolProgramCreateWithoutProgramInput, StudentSchoolProgramUncheckedCreateWithoutProgramInput> | StudentSchoolProgramCreateWithoutProgramInput[] | StudentSchoolProgramUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentSchoolProgramCreateOrConnectWithoutProgramInput | StudentSchoolProgramCreateOrConnectWithoutProgramInput[]
    upsert?: StudentSchoolProgramUpsertWithWhereUniqueWithoutProgramInput | StudentSchoolProgramUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: StudentSchoolProgramCreateManyProgramInputEnvelope
    set?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
    disconnect?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
    delete?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
    connect?: StudentSchoolProgramWhereUniqueInput | StudentSchoolProgramWhereUniqueInput[]
    update?: StudentSchoolProgramUpdateWithWhereUniqueWithoutProgramInput | StudentSchoolProgramUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: StudentSchoolProgramUpdateManyWithWhereWithoutProgramInput | StudentSchoolProgramUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: StudentSchoolProgramScalarWhereInput | StudentSchoolProgramScalarWhereInput[]
  }

  export type SchoolProgramImageUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<SchoolProgramImageCreateWithoutProgramInput, SchoolProgramImageUncheckedCreateWithoutProgramInput> | SchoolProgramImageCreateWithoutProgramInput[] | SchoolProgramImageUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SchoolProgramImageCreateOrConnectWithoutProgramInput | SchoolProgramImageCreateOrConnectWithoutProgramInput[]
    upsert?: SchoolProgramImageUpsertWithWhereUniqueWithoutProgramInput | SchoolProgramImageUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: SchoolProgramImageCreateManyProgramInputEnvelope
    set?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
    disconnect?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
    delete?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
    connect?: SchoolProgramImageWhereUniqueInput | SchoolProgramImageWhereUniqueInput[]
    update?: SchoolProgramImageUpdateWithWhereUniqueWithoutProgramInput | SchoolProgramImageUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: SchoolProgramImageUpdateManyWithWhereWithoutProgramInput | SchoolProgramImageUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: SchoolProgramImageScalarWhereInput | SchoolProgramImageScalarWhereInput[]
  }

  export type SchoolProgramCreateNestedOneWithoutImagesInput = {
    create?: XOR<SchoolProgramCreateWithoutImagesInput, SchoolProgramUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SchoolProgramCreateOrConnectWithoutImagesInput
    connect?: SchoolProgramWhereUniqueInput
  }

  export type SchoolProgramUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<SchoolProgramCreateWithoutImagesInput, SchoolProgramUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SchoolProgramCreateOrConnectWithoutImagesInput
    upsert?: SchoolProgramUpsertWithoutImagesInput
    connect?: SchoolProgramWhereUniqueInput
    update?: XOR<XOR<SchoolProgramUpdateToOneWithWhereWithoutImagesInput, SchoolProgramUpdateWithoutImagesInput>, SchoolProgramUncheckedUpdateWithoutImagesInput>
  }

  export type StudentCreateNestedOneWithoutProgramInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput
    connect?: StudentWhereUniqueInput
  }

  export type SchoolProgramCreateNestedOneWithoutStudentProgramsInput = {
    create?: XOR<SchoolProgramCreateWithoutStudentProgramsInput, SchoolProgramUncheckedCreateWithoutStudentProgramsInput>
    connectOrCreate?: SchoolProgramCreateOrConnectWithoutStudentProgramsInput
    connect?: SchoolProgramWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutProgramNestedInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput
    upsert?: StudentUpsertWithoutProgramInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutProgramInput, StudentUpdateWithoutProgramInput>, StudentUncheckedUpdateWithoutProgramInput>
  }

  export type SchoolProgramUpdateOneRequiredWithoutStudentProgramsNestedInput = {
    create?: XOR<SchoolProgramCreateWithoutStudentProgramsInput, SchoolProgramUncheckedCreateWithoutStudentProgramsInput>
    connectOrCreate?: SchoolProgramCreateOrConnectWithoutStudentProgramsInput
    upsert?: SchoolProgramUpsertWithoutStudentProgramsInput
    connect?: SchoolProgramWhereUniqueInput
    update?: XOR<XOR<SchoolProgramUpdateToOneWithWhereWithoutStudentProgramsInput, SchoolProgramUpdateWithoutStudentProgramsInput>, SchoolProgramUncheckedUpdateWithoutStudentProgramsInput>
  }

  export type StudentCreateNestedOneWithoutLocationInput = {
    create?: XOR<StudentCreateWithoutLocationInput, StudentUncheckedCreateWithoutLocationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLocationInput
    connect?: StudentWhereUniqueInput
  }

  export type SchoolLocationCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SchoolLocationCreateWithoutStudentsInput, SchoolLocationUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutStudentsInput
    connect?: SchoolLocationWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutLocationNestedInput = {
    create?: XOR<StudentCreateWithoutLocationInput, StudentUncheckedCreateWithoutLocationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLocationInput
    upsert?: StudentUpsertWithoutLocationInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutLocationInput, StudentUpdateWithoutLocationInput>, StudentUncheckedUpdateWithoutLocationInput>
  }

  export type SchoolLocationUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<SchoolLocationCreateWithoutStudentsInput, SchoolLocationUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolLocationCreateOrConnectWithoutStudentsInput
    upsert?: SchoolLocationUpsertWithoutStudentsInput
    connect?: SchoolLocationWhereUniqueInput
    update?: XOR<XOR<SchoolLocationUpdateToOneWithWhereWithoutStudentsInput, SchoolLocationUpdateWithoutStudentsInput>, SchoolLocationUncheckedUpdateWithoutStudentsInput>
  }

  export type AccountCreateNestedOneWithoutStudentInput = {
    create?: XOR<AccountCreateWithoutStudentInput, AccountUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AccountCreateOrConnectWithoutStudentInput
    connect?: AccountWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentsInput
    connect?: SchoolWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutStudentInput = {
    create?: XOR<MessageCreateWithoutStudentInput, MessageUncheckedCreateWithoutStudentInput> | MessageCreateWithoutStudentInput[] | MessageUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutStudentInput | MessageCreateOrConnectWithoutStudentInput[]
    createMany?: MessageCreateManyStudentInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutStudentsInput = {
    create?: XOR<ChatCreateWithoutStudentsInput, ChatUncheckedCreateWithoutStudentsInput> | ChatCreateWithoutStudentsInput[] | ChatUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStudentsInput | ChatCreateOrConnectWithoutStudentsInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutStudentInput = {
    create?: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStudentInput
    connect?: ProfileWhereUniqueInput
  }

  export type StudentSchoolProgramCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentSchoolProgramCreateWithoutStudentInput, StudentSchoolProgramUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolProgramCreateOrConnectWithoutStudentInput
    connect?: StudentSchoolProgramWhereUniqueInput
  }

  export type StudentSchoolLocationCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentSchoolLocationCreateWithoutStudentInput, StudentSchoolLocationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolLocationCreateOrConnectWithoutStudentInput
    connect?: StudentSchoolLocationWhereUniqueInput
  }

  export type StudentSchoolScholarshipCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSchoolScholarshipCreateWithoutStudentInput, StudentSchoolScholarshipUncheckedCreateWithoutStudentInput> | StudentSchoolScholarshipCreateWithoutStudentInput[] | StudentSchoolScholarshipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSchoolScholarshipCreateOrConnectWithoutStudentInput | StudentSchoolScholarshipCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSchoolScholarshipCreateManyStudentInputEnvelope
    connect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
  }

  export type NewsNotificationCreateNestedManyWithoutStudentInput = {
    create?: XOR<NewsNotificationCreateWithoutStudentInput, NewsNotificationUncheckedCreateWithoutStudentInput> | NewsNotificationCreateWithoutStudentInput[] | NewsNotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutStudentInput | NewsNotificationCreateOrConnectWithoutStudentInput[]
    createMany?: NewsNotificationCreateManyStudentInputEnvelope
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
  }

  export type NewsNotificationCreateNestedManyWithoutFromStudentInput = {
    create?: XOR<NewsNotificationCreateWithoutFromStudentInput, NewsNotificationUncheckedCreateWithoutFromStudentInput> | NewsNotificationCreateWithoutFromStudentInput[] | NewsNotificationUncheckedCreateWithoutFromStudentInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutFromStudentInput | NewsNotificationCreateOrConnectWithoutFromStudentInput[]
    createMany?: NewsNotificationCreateManyFromStudentInputEnvelope
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
  }

  export type StudentFollowCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentFollowCreateWithoutStudentInput, StudentFollowUncheckedCreateWithoutStudentInput> | StudentFollowCreateWithoutStudentInput[] | StudentFollowUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFollowCreateOrConnectWithoutStudentInput | StudentFollowCreateOrConnectWithoutStudentInput[]
    createMany?: StudentFollowCreateManyStudentInputEnvelope
    connect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
  }

  export type StudentFollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<StudentFollowCreateWithoutFollowerInput, StudentFollowUncheckedCreateWithoutFollowerInput> | StudentFollowCreateWithoutFollowerInput[] | StudentFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: StudentFollowCreateOrConnectWithoutFollowerInput | StudentFollowCreateOrConnectWithoutFollowerInput[]
    createMany?: StudentFollowCreateManyFollowerInputEnvelope
    connect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<MessageCreateWithoutStudentInput, MessageUncheckedCreateWithoutStudentInput> | MessageCreateWithoutStudentInput[] | MessageUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutStudentInput | MessageCreateOrConnectWithoutStudentInput[]
    createMany?: MessageCreateManyStudentInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<ChatCreateWithoutStudentsInput, ChatUncheckedCreateWithoutStudentsInput> | ChatCreateWithoutStudentsInput[] | ChatUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStudentsInput | ChatCreateOrConnectWithoutStudentsInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStudentInput
    connect?: ProfileWhereUniqueInput
  }

  export type StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentSchoolProgramCreateWithoutStudentInput, StudentSchoolProgramUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolProgramCreateOrConnectWithoutStudentInput
    connect?: StudentSchoolProgramWhereUniqueInput
  }

  export type StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentSchoolLocationCreateWithoutStudentInput, StudentSchoolLocationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolLocationCreateOrConnectWithoutStudentInput
    connect?: StudentSchoolLocationWhereUniqueInput
  }

  export type StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSchoolScholarshipCreateWithoutStudentInput, StudentSchoolScholarshipUncheckedCreateWithoutStudentInput> | StudentSchoolScholarshipCreateWithoutStudentInput[] | StudentSchoolScholarshipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSchoolScholarshipCreateOrConnectWithoutStudentInput | StudentSchoolScholarshipCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSchoolScholarshipCreateManyStudentInputEnvelope
    connect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
  }

  export type NewsNotificationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<NewsNotificationCreateWithoutStudentInput, NewsNotificationUncheckedCreateWithoutStudentInput> | NewsNotificationCreateWithoutStudentInput[] | NewsNotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutStudentInput | NewsNotificationCreateOrConnectWithoutStudentInput[]
    createMany?: NewsNotificationCreateManyStudentInputEnvelope
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
  }

  export type NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput = {
    create?: XOR<NewsNotificationCreateWithoutFromStudentInput, NewsNotificationUncheckedCreateWithoutFromStudentInput> | NewsNotificationCreateWithoutFromStudentInput[] | NewsNotificationUncheckedCreateWithoutFromStudentInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutFromStudentInput | NewsNotificationCreateOrConnectWithoutFromStudentInput[]
    createMany?: NewsNotificationCreateManyFromStudentInputEnvelope
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
  }

  export type StudentFollowUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentFollowCreateWithoutStudentInput, StudentFollowUncheckedCreateWithoutStudentInput> | StudentFollowCreateWithoutStudentInput[] | StudentFollowUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFollowCreateOrConnectWithoutStudentInput | StudentFollowCreateOrConnectWithoutStudentInput[]
    createMany?: StudentFollowCreateManyStudentInputEnvelope
    connect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
  }

  export type StudentFollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<StudentFollowCreateWithoutFollowerInput, StudentFollowUncheckedCreateWithoutFollowerInput> | StudentFollowCreateWithoutFollowerInput[] | StudentFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: StudentFollowCreateOrConnectWithoutFollowerInput | StudentFollowCreateOrConnectWithoutFollowerInput[]
    createMany?: StudentFollowCreateManyFollowerInputEnvelope
    connect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
  }

  export type EnumDegreeTypeFieldUpdateOperationsInput = {
    set?: $Enums.DegreeType
  }

  export type EnumCertificateTypeFieldUpdateOperationsInput = {
    set?: $Enums.CertificateType
  }

  export type EnumGradeTypeFieldUpdateOperationsInput = {
    set?: $Enums.GradeType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumStudentStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentStatus
  }

  export type AccountUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<AccountCreateWithoutStudentInput, AccountUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AccountCreateOrConnectWithoutStudentInput
    upsert?: AccountUpsertWithoutStudentInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutStudentInput, AccountUpdateWithoutStudentInput>, AccountUncheckedUpdateWithoutStudentInput>
  }

  export type SchoolUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutStudentsInput
    upsert?: SchoolUpsertWithoutStudentsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutStudentsInput, SchoolUpdateWithoutStudentsInput>, SchoolUncheckedUpdateWithoutStudentsInput>
  }

  export type MessageUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MessageCreateWithoutStudentInput, MessageUncheckedCreateWithoutStudentInput> | MessageCreateWithoutStudentInput[] | MessageUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutStudentInput | MessageCreateOrConnectWithoutStudentInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutStudentInput | MessageUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MessageCreateManyStudentInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutStudentInput | MessageUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutStudentInput | MessageUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<ChatCreateWithoutStudentsInput, ChatUncheckedCreateWithoutStudentsInput> | ChatCreateWithoutStudentsInput[] | ChatUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStudentsInput | ChatCreateOrConnectWithoutStudentsInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutStudentsInput | ChatUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutStudentsInput | ChatUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutStudentsInput | ChatUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutStudentNestedInput = {
    create?: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStudentInput
    upsert?: ProfileUpsertWithoutStudentInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutStudentInput, ProfileUpdateWithoutStudentInput>, ProfileUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSchoolProgramUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentSchoolProgramCreateWithoutStudentInput, StudentSchoolProgramUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolProgramCreateOrConnectWithoutStudentInput
    upsert?: StudentSchoolProgramUpsertWithoutStudentInput
    disconnect?: StudentSchoolProgramWhereInput | boolean
    delete?: StudentSchoolProgramWhereInput | boolean
    connect?: StudentSchoolProgramWhereUniqueInput
    update?: XOR<XOR<StudentSchoolProgramUpdateToOneWithWhereWithoutStudentInput, StudentSchoolProgramUpdateWithoutStudentInput>, StudentSchoolProgramUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSchoolLocationUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentSchoolLocationCreateWithoutStudentInput, StudentSchoolLocationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolLocationCreateOrConnectWithoutStudentInput
    upsert?: StudentSchoolLocationUpsertWithoutStudentInput
    disconnect?: StudentSchoolLocationWhereInput | boolean
    delete?: StudentSchoolLocationWhereInput | boolean
    connect?: StudentSchoolLocationWhereUniqueInput
    update?: XOR<XOR<StudentSchoolLocationUpdateToOneWithWhereWithoutStudentInput, StudentSchoolLocationUpdateWithoutStudentInput>, StudentSchoolLocationUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSchoolScholarshipCreateWithoutStudentInput, StudentSchoolScholarshipUncheckedCreateWithoutStudentInput> | StudentSchoolScholarshipCreateWithoutStudentInput[] | StudentSchoolScholarshipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSchoolScholarshipCreateOrConnectWithoutStudentInput | StudentSchoolScholarshipCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSchoolScholarshipUpsertWithWhereUniqueWithoutStudentInput | StudentSchoolScholarshipUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSchoolScholarshipCreateManyStudentInputEnvelope
    set?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    disconnect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    delete?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    connect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    update?: StudentSchoolScholarshipUpdateWithWhereUniqueWithoutStudentInput | StudentSchoolScholarshipUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSchoolScholarshipUpdateManyWithWhereWithoutStudentInput | StudentSchoolScholarshipUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSchoolScholarshipScalarWhereInput | StudentSchoolScholarshipScalarWhereInput[]
  }

  export type NewsNotificationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NewsNotificationCreateWithoutStudentInput, NewsNotificationUncheckedCreateWithoutStudentInput> | NewsNotificationCreateWithoutStudentInput[] | NewsNotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutStudentInput | NewsNotificationCreateOrConnectWithoutStudentInput[]
    upsert?: NewsNotificationUpsertWithWhereUniqueWithoutStudentInput | NewsNotificationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NewsNotificationCreateManyStudentInputEnvelope
    set?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    disconnect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    delete?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    update?: NewsNotificationUpdateWithWhereUniqueWithoutStudentInput | NewsNotificationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NewsNotificationUpdateManyWithWhereWithoutStudentInput | NewsNotificationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NewsNotificationScalarWhereInput | NewsNotificationScalarWhereInput[]
  }

  export type NewsNotificationUpdateManyWithoutFromStudentNestedInput = {
    create?: XOR<NewsNotificationCreateWithoutFromStudentInput, NewsNotificationUncheckedCreateWithoutFromStudentInput> | NewsNotificationCreateWithoutFromStudentInput[] | NewsNotificationUncheckedCreateWithoutFromStudentInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutFromStudentInput | NewsNotificationCreateOrConnectWithoutFromStudentInput[]
    upsert?: NewsNotificationUpsertWithWhereUniqueWithoutFromStudentInput | NewsNotificationUpsertWithWhereUniqueWithoutFromStudentInput[]
    createMany?: NewsNotificationCreateManyFromStudentInputEnvelope
    set?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    disconnect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    delete?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    update?: NewsNotificationUpdateWithWhereUniqueWithoutFromStudentInput | NewsNotificationUpdateWithWhereUniqueWithoutFromStudentInput[]
    updateMany?: NewsNotificationUpdateManyWithWhereWithoutFromStudentInput | NewsNotificationUpdateManyWithWhereWithoutFromStudentInput[]
    deleteMany?: NewsNotificationScalarWhereInput | NewsNotificationScalarWhereInput[]
  }

  export type StudentFollowUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentFollowCreateWithoutStudentInput, StudentFollowUncheckedCreateWithoutStudentInput> | StudentFollowCreateWithoutStudentInput[] | StudentFollowUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFollowCreateOrConnectWithoutStudentInput | StudentFollowCreateOrConnectWithoutStudentInput[]
    upsert?: StudentFollowUpsertWithWhereUniqueWithoutStudentInput | StudentFollowUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentFollowCreateManyStudentInputEnvelope
    set?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    disconnect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    delete?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    connect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    update?: StudentFollowUpdateWithWhereUniqueWithoutStudentInput | StudentFollowUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentFollowUpdateManyWithWhereWithoutStudentInput | StudentFollowUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentFollowScalarWhereInput | StudentFollowScalarWhereInput[]
  }

  export type StudentFollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<StudentFollowCreateWithoutFollowerInput, StudentFollowUncheckedCreateWithoutFollowerInput> | StudentFollowCreateWithoutFollowerInput[] | StudentFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: StudentFollowCreateOrConnectWithoutFollowerInput | StudentFollowCreateOrConnectWithoutFollowerInput[]
    upsert?: StudentFollowUpsertWithWhereUniqueWithoutFollowerInput | StudentFollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: StudentFollowCreateManyFollowerInputEnvelope
    set?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    disconnect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    delete?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    connect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    update?: StudentFollowUpdateWithWhereUniqueWithoutFollowerInput | StudentFollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: StudentFollowUpdateManyWithWhereWithoutFollowerInput | StudentFollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: StudentFollowScalarWhereInput | StudentFollowScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MessageCreateWithoutStudentInput, MessageUncheckedCreateWithoutStudentInput> | MessageCreateWithoutStudentInput[] | MessageUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutStudentInput | MessageCreateOrConnectWithoutStudentInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutStudentInput | MessageUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MessageCreateManyStudentInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutStudentInput | MessageUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutStudentInput | MessageUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<ChatCreateWithoutStudentsInput, ChatUncheckedCreateWithoutStudentsInput> | ChatCreateWithoutStudentsInput[] | ChatUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStudentsInput | ChatCreateOrConnectWithoutStudentsInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutStudentsInput | ChatUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutStudentsInput | ChatUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutStudentsInput | ChatUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStudentInput
    upsert?: ProfileUpsertWithoutStudentInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutStudentInput, ProfileUpdateWithoutStudentInput>, ProfileUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentSchoolProgramCreateWithoutStudentInput, StudentSchoolProgramUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolProgramCreateOrConnectWithoutStudentInput
    upsert?: StudentSchoolProgramUpsertWithoutStudentInput
    disconnect?: StudentSchoolProgramWhereInput | boolean
    delete?: StudentSchoolProgramWhereInput | boolean
    connect?: StudentSchoolProgramWhereUniqueInput
    update?: XOR<XOR<StudentSchoolProgramUpdateToOneWithWhereWithoutStudentInput, StudentSchoolProgramUpdateWithoutStudentInput>, StudentSchoolProgramUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentSchoolLocationCreateWithoutStudentInput, StudentSchoolLocationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSchoolLocationCreateOrConnectWithoutStudentInput
    upsert?: StudentSchoolLocationUpsertWithoutStudentInput
    disconnect?: StudentSchoolLocationWhereInput | boolean
    delete?: StudentSchoolLocationWhereInput | boolean
    connect?: StudentSchoolLocationWhereUniqueInput
    update?: XOR<XOR<StudentSchoolLocationUpdateToOneWithWhereWithoutStudentInput, StudentSchoolLocationUpdateWithoutStudentInput>, StudentSchoolLocationUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSchoolScholarshipCreateWithoutStudentInput, StudentSchoolScholarshipUncheckedCreateWithoutStudentInput> | StudentSchoolScholarshipCreateWithoutStudentInput[] | StudentSchoolScholarshipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSchoolScholarshipCreateOrConnectWithoutStudentInput | StudentSchoolScholarshipCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSchoolScholarshipUpsertWithWhereUniqueWithoutStudentInput | StudentSchoolScholarshipUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSchoolScholarshipCreateManyStudentInputEnvelope
    set?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    disconnect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    delete?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    connect?: StudentSchoolScholarshipWhereUniqueInput | StudentSchoolScholarshipWhereUniqueInput[]
    update?: StudentSchoolScholarshipUpdateWithWhereUniqueWithoutStudentInput | StudentSchoolScholarshipUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSchoolScholarshipUpdateManyWithWhereWithoutStudentInput | StudentSchoolScholarshipUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSchoolScholarshipScalarWhereInput | StudentSchoolScholarshipScalarWhereInput[]
  }

  export type NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NewsNotificationCreateWithoutStudentInput, NewsNotificationUncheckedCreateWithoutStudentInput> | NewsNotificationCreateWithoutStudentInput[] | NewsNotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutStudentInput | NewsNotificationCreateOrConnectWithoutStudentInput[]
    upsert?: NewsNotificationUpsertWithWhereUniqueWithoutStudentInput | NewsNotificationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NewsNotificationCreateManyStudentInputEnvelope
    set?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    disconnect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    delete?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    update?: NewsNotificationUpdateWithWhereUniqueWithoutStudentInput | NewsNotificationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NewsNotificationUpdateManyWithWhereWithoutStudentInput | NewsNotificationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NewsNotificationScalarWhereInput | NewsNotificationScalarWhereInput[]
  }

  export type NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput = {
    create?: XOR<NewsNotificationCreateWithoutFromStudentInput, NewsNotificationUncheckedCreateWithoutFromStudentInput> | NewsNotificationCreateWithoutFromStudentInput[] | NewsNotificationUncheckedCreateWithoutFromStudentInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutFromStudentInput | NewsNotificationCreateOrConnectWithoutFromStudentInput[]
    upsert?: NewsNotificationUpsertWithWhereUniqueWithoutFromStudentInput | NewsNotificationUpsertWithWhereUniqueWithoutFromStudentInput[]
    createMany?: NewsNotificationCreateManyFromStudentInputEnvelope
    set?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    disconnect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    delete?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    update?: NewsNotificationUpdateWithWhereUniqueWithoutFromStudentInput | NewsNotificationUpdateWithWhereUniqueWithoutFromStudentInput[]
    updateMany?: NewsNotificationUpdateManyWithWhereWithoutFromStudentInput | NewsNotificationUpdateManyWithWhereWithoutFromStudentInput[]
    deleteMany?: NewsNotificationScalarWhereInput | NewsNotificationScalarWhereInput[]
  }

  export type StudentFollowUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentFollowCreateWithoutStudentInput, StudentFollowUncheckedCreateWithoutStudentInput> | StudentFollowCreateWithoutStudentInput[] | StudentFollowUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFollowCreateOrConnectWithoutStudentInput | StudentFollowCreateOrConnectWithoutStudentInput[]
    upsert?: StudentFollowUpsertWithWhereUniqueWithoutStudentInput | StudentFollowUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentFollowCreateManyStudentInputEnvelope
    set?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    disconnect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    delete?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    connect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    update?: StudentFollowUpdateWithWhereUniqueWithoutStudentInput | StudentFollowUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentFollowUpdateManyWithWhereWithoutStudentInput | StudentFollowUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentFollowScalarWhereInput | StudentFollowScalarWhereInput[]
  }

  export type StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<StudentFollowCreateWithoutFollowerInput, StudentFollowUncheckedCreateWithoutFollowerInput> | StudentFollowCreateWithoutFollowerInput[] | StudentFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: StudentFollowCreateOrConnectWithoutFollowerInput | StudentFollowCreateOrConnectWithoutFollowerInput[]
    upsert?: StudentFollowUpsertWithWhereUniqueWithoutFollowerInput | StudentFollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: StudentFollowCreateManyFollowerInputEnvelope
    set?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    disconnect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    delete?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    connect?: StudentFollowWhereUniqueInput | StudentFollowWhereUniqueInput[]
    update?: StudentFollowUpdateWithWhereUniqueWithoutFollowerInput | StudentFollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: StudentFollowUpdateManyWithWhereWithoutFollowerInput | StudentFollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: StudentFollowScalarWhereInput | StudentFollowScalarWhereInput[]
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutChatsInput = {
    create?: XOR<StudentCreateWithoutChatsInput, StudentUncheckedCreateWithoutChatsInput> | StudentCreateWithoutChatsInput[] | StudentUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutChatsInput | StudentCreateOrConnectWithoutChatsInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutChatsInput = {
    create?: XOR<StudentCreateWithoutChatsInput, StudentUncheckedCreateWithoutChatsInput> | StudentCreateWithoutChatsInput[] | StudentUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutChatsInput | StudentCreateOrConnectWithoutChatsInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutChatsNestedInput = {
    create?: XOR<StudentCreateWithoutChatsInput, StudentUncheckedCreateWithoutChatsInput> | StudentCreateWithoutChatsInput[] | StudentUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutChatsInput | StudentCreateOrConnectWithoutChatsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutChatsInput | StudentUpsertWithWhereUniqueWithoutChatsInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutChatsInput | StudentUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutChatsInput | StudentUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutChatsNestedInput = {
    create?: XOR<StudentCreateWithoutChatsInput, StudentUncheckedCreateWithoutChatsInput> | StudentCreateWithoutChatsInput[] | StudentUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutChatsInput | StudentCreateOrConnectWithoutChatsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutChatsInput | StudentUpsertWithWhereUniqueWithoutChatsInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutChatsInput | StudentUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutChatsInput | StudentUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutMesseagesInput = {
    create?: XOR<StudentCreateWithoutMesseagesInput, StudentUncheckedCreateWithoutMesseagesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMesseagesInput
    connect?: StudentWhereUniqueInput
  }

  export type ChatCreateNestedOneWithoutMessegesInput = {
    create?: XOR<ChatCreateWithoutMessegesInput, ChatUncheckedCreateWithoutMessegesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessegesInput
    connect?: ChatWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutMesseagesNestedInput = {
    create?: XOR<StudentCreateWithoutMesseagesInput, StudentUncheckedCreateWithoutMesseagesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMesseagesInput
    upsert?: StudentUpsertWithoutMesseagesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutMesseagesInput, StudentUpdateWithoutMesseagesInput>, StudentUncheckedUpdateWithoutMesseagesInput>
  }

  export type ChatUpdateOneRequiredWithoutMessegesNestedInput = {
    create?: XOR<ChatCreateWithoutMessegesInput, ChatUncheckedCreateWithoutMessegesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessegesInput
    upsert?: ChatUpsertWithoutMessegesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessegesInput, ChatUpdateWithoutMessegesInput>, ChatUncheckedUpdateWithoutMessegesInput>
  }

  export type ProfileCreateNestedOneWithoutHostedEventsInput = {
    create?: XOR<ProfileCreateWithoutHostedEventsInput, ProfileUncheckedCreateWithoutHostedEventsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutHostedEventsInput
    connect?: ProfileWhereUniqueInput
  }

  export type EventProfileCreateNestedManyWithoutEventInput = {
    create?: XOR<EventProfileCreateWithoutEventInput, EventProfileUncheckedCreateWithoutEventInput> | EventProfileCreateWithoutEventInput[] | EventProfileUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventProfileCreateOrConnectWithoutEventInput | EventProfileCreateOrConnectWithoutEventInput[]
    createMany?: EventProfileCreateManyEventInputEnvelope
    connect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
  }

  export type EventProfileUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventProfileCreateWithoutEventInput, EventProfileUncheckedCreateWithoutEventInput> | EventProfileCreateWithoutEventInput[] | EventProfileUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventProfileCreateOrConnectWithoutEventInput | EventProfileCreateOrConnectWithoutEventInput[]
    createMany?: EventProfileCreateManyEventInputEnvelope
    connect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
  }

  export type ProfileUpdateOneRequiredWithoutHostedEventsNestedInput = {
    create?: XOR<ProfileCreateWithoutHostedEventsInput, ProfileUncheckedCreateWithoutHostedEventsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutHostedEventsInput
    upsert?: ProfileUpsertWithoutHostedEventsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutHostedEventsInput, ProfileUpdateWithoutHostedEventsInput>, ProfileUncheckedUpdateWithoutHostedEventsInput>
  }

  export type EventProfileUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventProfileCreateWithoutEventInput, EventProfileUncheckedCreateWithoutEventInput> | EventProfileCreateWithoutEventInput[] | EventProfileUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventProfileCreateOrConnectWithoutEventInput | EventProfileCreateOrConnectWithoutEventInput[]
    upsert?: EventProfileUpsertWithWhereUniqueWithoutEventInput | EventProfileUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventProfileCreateManyEventInputEnvelope
    set?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    disconnect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    delete?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    connect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    update?: EventProfileUpdateWithWhereUniqueWithoutEventInput | EventProfileUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventProfileUpdateManyWithWhereWithoutEventInput | EventProfileUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventProfileScalarWhereInput | EventProfileScalarWhereInput[]
  }

  export type EventProfileUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventProfileCreateWithoutEventInput, EventProfileUncheckedCreateWithoutEventInput> | EventProfileCreateWithoutEventInput[] | EventProfileUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventProfileCreateOrConnectWithoutEventInput | EventProfileCreateOrConnectWithoutEventInput[]
    upsert?: EventProfileUpsertWithWhereUniqueWithoutEventInput | EventProfileUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventProfileCreateManyEventInputEnvelope
    set?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    disconnect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    delete?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    connect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    update?: EventProfileUpdateWithWhereUniqueWithoutEventInput | EventProfileUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventProfileUpdateManyWithWhereWithoutEventInput | EventProfileUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventProfileScalarWhereInput | EventProfileScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<EventCreateWithoutParticipantsInput, EventUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EventCreateOrConnectWithoutParticipantsInput
    connect?: EventWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutParticipatedEventsInput = {
    create?: XOR<ProfileCreateWithoutParticipatedEventsInput, ProfileUncheckedCreateWithoutParticipatedEventsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutParticipatedEventsInput
    connect?: ProfileWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<EventCreateWithoutParticipantsInput, EventUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EventCreateOrConnectWithoutParticipantsInput
    upsert?: EventUpsertWithoutParticipantsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutParticipantsInput, EventUpdateWithoutParticipantsInput>, EventUncheckedUpdateWithoutParticipantsInput>
  }

  export type ProfileUpdateOneRequiredWithoutParticipatedEventsNestedInput = {
    create?: XOR<ProfileCreateWithoutParticipatedEventsInput, ProfileUncheckedCreateWithoutParticipatedEventsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutParticipatedEventsInput
    upsert?: ProfileUpsertWithoutParticipatedEventsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutParticipatedEventsInput, ProfileUpdateWithoutParticipatedEventsInput>, ProfileUncheckedUpdateWithoutParticipatedEventsInput>
  }

  export type StudentCreateNestedOneWithoutProfileInput = {
    create?: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProfileInput
    connect?: StudentWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutHostInput = {
    create?: XOR<EventCreateWithoutHostInput, EventUncheckedCreateWithoutHostInput> | EventCreateWithoutHostInput[] | EventUncheckedCreateWithoutHostInput[]
    connectOrCreate?: EventCreateOrConnectWithoutHostInput | EventCreateOrConnectWithoutHostInput[]
    createMany?: EventCreateManyHostInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventProfileCreateNestedManyWithoutProfileInput = {
    create?: XOR<EventProfileCreateWithoutProfileInput, EventProfileUncheckedCreateWithoutProfileInput> | EventProfileCreateWithoutProfileInput[] | EventProfileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EventProfileCreateOrConnectWithoutProfileInput | EventProfileCreateOrConnectWithoutProfileInput[]
    createMany?: EventProfileCreateManyProfileInputEnvelope
    connect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostCreateWithoutProfileInput, PostUncheckedCreateWithoutProfileInput> | PostCreateWithoutProfileInput[] | PostUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCreateOrConnectWithoutProfileInput | PostCreateOrConnectWithoutProfileInput[]
    createMany?: PostCreateManyProfileInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ProfileBiographyCreateNestedOneWithoutProfileInput = {
    create?: XOR<ProfileBiographyCreateWithoutProfileInput, ProfileBiographyUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileBiographyCreateOrConnectWithoutProfileInput
    connect?: ProfileBiographyWhereUniqueInput
  }

  export type ProfileFriendCreateNestedManyWithoutProfileOneInput = {
    create?: XOR<ProfileFriendCreateWithoutProfileOneInput, ProfileFriendUncheckedCreateWithoutProfileOneInput> | ProfileFriendCreateWithoutProfileOneInput[] | ProfileFriendUncheckedCreateWithoutProfileOneInput[]
    connectOrCreate?: ProfileFriendCreateOrConnectWithoutProfileOneInput | ProfileFriendCreateOrConnectWithoutProfileOneInput[]
    createMany?: ProfileFriendCreateManyProfileOneInputEnvelope
    connect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
  }

  export type ProfileFriendCreateNestedManyWithoutProfileTwoInput = {
    create?: XOR<ProfileFriendCreateWithoutProfileTwoInput, ProfileFriendUncheckedCreateWithoutProfileTwoInput> | ProfileFriendCreateWithoutProfileTwoInput[] | ProfileFriendUncheckedCreateWithoutProfileTwoInput[]
    connectOrCreate?: ProfileFriendCreateOrConnectWithoutProfileTwoInput | ProfileFriendCreateOrConnectWithoutProfileTwoInput[]
    createMany?: ProfileFriendCreateManyProfileTwoInputEnvelope
    connect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutOwnerInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ProfileGroupCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileGroupCreateWithoutProfileInput, ProfileGroupUncheckedCreateWithoutProfileInput> | ProfileGroupCreateWithoutProfileInput[] | ProfileGroupUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileGroupCreateOrConnectWithoutProfileInput | ProfileGroupCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileGroupCreateManyProfileInputEnvelope
    connect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
  }

  export type ProfileBlogCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileBlogCreateWithoutProfileInput, ProfileBlogUncheckedCreateWithoutProfileInput> | ProfileBlogCreateWithoutProfileInput[] | ProfileBlogUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileBlogCreateOrConnectWithoutProfileInput | ProfileBlogCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileBlogCreateManyProfileInputEnvelope
    connect?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
  }

  export type PostCommentCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostCommentCreateWithoutProfileInput, PostCommentUncheckedCreateWithoutProfileInput> | PostCommentCreateWithoutProfileInput[] | PostCommentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutProfileInput | PostCommentCreateOrConnectWithoutProfileInput[]
    createMany?: PostCommentCreateManyProfileInputEnvelope
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
  }

  export type PostCommentLikeCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostCommentLikeCreateWithoutProfileInput, PostCommentLikeUncheckedCreateWithoutProfileInput> | PostCommentLikeCreateWithoutProfileInput[] | PostCommentLikeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCommentLikeCreateOrConnectWithoutProfileInput | PostCommentLikeCreateOrConnectWithoutProfileInput[]
    createMany?: PostCommentLikeCreateManyProfileInputEnvelope
    connect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
  }

  export type PostLikeCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostLikeCreateWithoutProfileInput, PostLikeUncheckedCreateWithoutProfileInput> | PostLikeCreateWithoutProfileInput[] | PostLikeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutProfileInput | PostLikeCreateOrConnectWithoutProfileInput[]
    createMany?: PostLikeCreateManyProfileInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type PostShareCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostShareCreateWithoutProfileInput, PostShareUncheckedCreateWithoutProfileInput> | PostShareCreateWithoutProfileInput[] | PostShareUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostShareCreateOrConnectWithoutProfileInput | PostShareCreateOrConnectWithoutProfileInput[]
    createMany?: PostShareCreateManyProfileInputEnvelope
    connect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
  }

  export type PostSaveCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostSaveCreateWithoutProfileInput, PostSaveUncheckedCreateWithoutProfileInput> | PostSaveCreateWithoutProfileInput[] | PostSaveUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostSaveCreateOrConnectWithoutProfileInput | PostSaveCreateOrConnectWithoutProfileInput[]
    createMany?: PostSaveCreateManyProfileInputEnvelope
    connect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<EventCreateWithoutHostInput, EventUncheckedCreateWithoutHostInput> | EventCreateWithoutHostInput[] | EventUncheckedCreateWithoutHostInput[]
    connectOrCreate?: EventCreateOrConnectWithoutHostInput | EventCreateOrConnectWithoutHostInput[]
    createMany?: EventCreateManyHostInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventProfileUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<EventProfileCreateWithoutProfileInput, EventProfileUncheckedCreateWithoutProfileInput> | EventProfileCreateWithoutProfileInput[] | EventProfileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EventProfileCreateOrConnectWithoutProfileInput | EventProfileCreateOrConnectWithoutProfileInput[]
    createMany?: EventProfileCreateManyProfileInputEnvelope
    connect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostCreateWithoutProfileInput, PostUncheckedCreateWithoutProfileInput> | PostCreateWithoutProfileInput[] | PostUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCreateOrConnectWithoutProfileInput | PostCreateOrConnectWithoutProfileInput[]
    createMany?: PostCreateManyProfileInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<ProfileBiographyCreateWithoutProfileInput, ProfileBiographyUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileBiographyCreateOrConnectWithoutProfileInput
    connect?: ProfileBiographyWhereUniqueInput
  }

  export type ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput = {
    create?: XOR<ProfileFriendCreateWithoutProfileOneInput, ProfileFriendUncheckedCreateWithoutProfileOneInput> | ProfileFriendCreateWithoutProfileOneInput[] | ProfileFriendUncheckedCreateWithoutProfileOneInput[]
    connectOrCreate?: ProfileFriendCreateOrConnectWithoutProfileOneInput | ProfileFriendCreateOrConnectWithoutProfileOneInput[]
    createMany?: ProfileFriendCreateManyProfileOneInputEnvelope
    connect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
  }

  export type ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput = {
    create?: XOR<ProfileFriendCreateWithoutProfileTwoInput, ProfileFriendUncheckedCreateWithoutProfileTwoInput> | ProfileFriendCreateWithoutProfileTwoInput[] | ProfileFriendUncheckedCreateWithoutProfileTwoInput[]
    connectOrCreate?: ProfileFriendCreateOrConnectWithoutProfileTwoInput | ProfileFriendCreateOrConnectWithoutProfileTwoInput[]
    createMany?: ProfileFriendCreateManyProfileTwoInputEnvelope
    connect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ProfileGroupUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileGroupCreateWithoutProfileInput, ProfileGroupUncheckedCreateWithoutProfileInput> | ProfileGroupCreateWithoutProfileInput[] | ProfileGroupUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileGroupCreateOrConnectWithoutProfileInput | ProfileGroupCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileGroupCreateManyProfileInputEnvelope
    connect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
  }

  export type ProfileBlogUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileBlogCreateWithoutProfileInput, ProfileBlogUncheckedCreateWithoutProfileInput> | ProfileBlogCreateWithoutProfileInput[] | ProfileBlogUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileBlogCreateOrConnectWithoutProfileInput | ProfileBlogCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileBlogCreateManyProfileInputEnvelope
    connect?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
  }

  export type PostCommentUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostCommentCreateWithoutProfileInput, PostCommentUncheckedCreateWithoutProfileInput> | PostCommentCreateWithoutProfileInput[] | PostCommentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutProfileInput | PostCommentCreateOrConnectWithoutProfileInput[]
    createMany?: PostCommentCreateManyProfileInputEnvelope
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
  }

  export type PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostCommentLikeCreateWithoutProfileInput, PostCommentLikeUncheckedCreateWithoutProfileInput> | PostCommentLikeCreateWithoutProfileInput[] | PostCommentLikeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCommentLikeCreateOrConnectWithoutProfileInput | PostCommentLikeCreateOrConnectWithoutProfileInput[]
    createMany?: PostCommentLikeCreateManyProfileInputEnvelope
    connect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
  }

  export type PostLikeUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostLikeCreateWithoutProfileInput, PostLikeUncheckedCreateWithoutProfileInput> | PostLikeCreateWithoutProfileInput[] | PostLikeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutProfileInput | PostLikeCreateOrConnectWithoutProfileInput[]
    createMany?: PostLikeCreateManyProfileInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type PostShareUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostShareCreateWithoutProfileInput, PostShareUncheckedCreateWithoutProfileInput> | PostShareCreateWithoutProfileInput[] | PostShareUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostShareCreateOrConnectWithoutProfileInput | PostShareCreateOrConnectWithoutProfileInput[]
    createMany?: PostShareCreateManyProfileInputEnvelope
    connect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
  }

  export type PostSaveUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostSaveCreateWithoutProfileInput, PostSaveUncheckedCreateWithoutProfileInput> | PostSaveCreateWithoutProfileInput[] | PostSaveUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostSaveCreateOrConnectWithoutProfileInput | PostSaveCreateOrConnectWithoutProfileInput[]
    createMany?: PostSaveCreateManyProfileInputEnvelope
    connect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
  }

  export type EnumProfileStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProfileStatus
  }

  export type StudentUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProfileInput
    upsert?: StudentUpsertWithoutProfileInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutProfileInput, StudentUpdateWithoutProfileInput>, StudentUncheckedUpdateWithoutProfileInput>
  }

  export type EventUpdateManyWithoutHostNestedInput = {
    create?: XOR<EventCreateWithoutHostInput, EventUncheckedCreateWithoutHostInput> | EventCreateWithoutHostInput[] | EventUncheckedCreateWithoutHostInput[]
    connectOrCreate?: EventCreateOrConnectWithoutHostInput | EventCreateOrConnectWithoutHostInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutHostInput | EventUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: EventCreateManyHostInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutHostInput | EventUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: EventUpdateManyWithWhereWithoutHostInput | EventUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventProfileUpdateManyWithoutProfileNestedInput = {
    create?: XOR<EventProfileCreateWithoutProfileInput, EventProfileUncheckedCreateWithoutProfileInput> | EventProfileCreateWithoutProfileInput[] | EventProfileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EventProfileCreateOrConnectWithoutProfileInput | EventProfileCreateOrConnectWithoutProfileInput[]
    upsert?: EventProfileUpsertWithWhereUniqueWithoutProfileInput | EventProfileUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: EventProfileCreateManyProfileInputEnvelope
    set?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    disconnect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    delete?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    connect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    update?: EventProfileUpdateWithWhereUniqueWithoutProfileInput | EventProfileUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: EventProfileUpdateManyWithWhereWithoutProfileInput | EventProfileUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: EventProfileScalarWhereInput | EventProfileScalarWhereInput[]
  }

  export type PostUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostCreateWithoutProfileInput, PostUncheckedCreateWithoutProfileInput> | PostCreateWithoutProfileInput[] | PostUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCreateOrConnectWithoutProfileInput | PostCreateOrConnectWithoutProfileInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutProfileInput | PostUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostCreateManyProfileInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutProfileInput | PostUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostUpdateManyWithWhereWithoutProfileInput | PostUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ProfileBiographyUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ProfileBiographyCreateWithoutProfileInput, ProfileBiographyUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileBiographyCreateOrConnectWithoutProfileInput
    upsert?: ProfileBiographyUpsertWithoutProfileInput
    disconnect?: ProfileBiographyWhereInput | boolean
    delete?: ProfileBiographyWhereInput | boolean
    connect?: ProfileBiographyWhereUniqueInput
    update?: XOR<XOR<ProfileBiographyUpdateToOneWithWhereWithoutProfileInput, ProfileBiographyUpdateWithoutProfileInput>, ProfileBiographyUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileFriendUpdateManyWithoutProfileOneNestedInput = {
    create?: XOR<ProfileFriendCreateWithoutProfileOneInput, ProfileFriendUncheckedCreateWithoutProfileOneInput> | ProfileFriendCreateWithoutProfileOneInput[] | ProfileFriendUncheckedCreateWithoutProfileOneInput[]
    connectOrCreate?: ProfileFriendCreateOrConnectWithoutProfileOneInput | ProfileFriendCreateOrConnectWithoutProfileOneInput[]
    upsert?: ProfileFriendUpsertWithWhereUniqueWithoutProfileOneInput | ProfileFriendUpsertWithWhereUniqueWithoutProfileOneInput[]
    createMany?: ProfileFriendCreateManyProfileOneInputEnvelope
    set?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    disconnect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    delete?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    connect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    update?: ProfileFriendUpdateWithWhereUniqueWithoutProfileOneInput | ProfileFriendUpdateWithWhereUniqueWithoutProfileOneInput[]
    updateMany?: ProfileFriendUpdateManyWithWhereWithoutProfileOneInput | ProfileFriendUpdateManyWithWhereWithoutProfileOneInput[]
    deleteMany?: ProfileFriendScalarWhereInput | ProfileFriendScalarWhereInput[]
  }

  export type ProfileFriendUpdateManyWithoutProfileTwoNestedInput = {
    create?: XOR<ProfileFriendCreateWithoutProfileTwoInput, ProfileFriendUncheckedCreateWithoutProfileTwoInput> | ProfileFriendCreateWithoutProfileTwoInput[] | ProfileFriendUncheckedCreateWithoutProfileTwoInput[]
    connectOrCreate?: ProfileFriendCreateOrConnectWithoutProfileTwoInput | ProfileFriendCreateOrConnectWithoutProfileTwoInput[]
    upsert?: ProfileFriendUpsertWithWhereUniqueWithoutProfileTwoInput | ProfileFriendUpsertWithWhereUniqueWithoutProfileTwoInput[]
    createMany?: ProfileFriendCreateManyProfileTwoInputEnvelope
    set?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    disconnect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    delete?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    connect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    update?: ProfileFriendUpdateWithWhereUniqueWithoutProfileTwoInput | ProfileFriendUpdateWithWhereUniqueWithoutProfileTwoInput[]
    updateMany?: ProfileFriendUpdateManyWithWhereWithoutProfileTwoInput | ProfileFriendUpdateManyWithWhereWithoutProfileTwoInput[]
    deleteMany?: ProfileFriendScalarWhereInput | ProfileFriendScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutOwnerInput | GroupUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutOwnerInput | GroupUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutOwnerInput | GroupUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ProfileGroupUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileGroupCreateWithoutProfileInput, ProfileGroupUncheckedCreateWithoutProfileInput> | ProfileGroupCreateWithoutProfileInput[] | ProfileGroupUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileGroupCreateOrConnectWithoutProfileInput | ProfileGroupCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileGroupUpsertWithWhereUniqueWithoutProfileInput | ProfileGroupUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileGroupCreateManyProfileInputEnvelope
    set?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    disconnect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    delete?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    connect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    update?: ProfileGroupUpdateWithWhereUniqueWithoutProfileInput | ProfileGroupUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileGroupUpdateManyWithWhereWithoutProfileInput | ProfileGroupUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileGroupScalarWhereInput | ProfileGroupScalarWhereInput[]
  }

  export type ProfileBlogUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileBlogCreateWithoutProfileInput, ProfileBlogUncheckedCreateWithoutProfileInput> | ProfileBlogCreateWithoutProfileInput[] | ProfileBlogUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileBlogCreateOrConnectWithoutProfileInput | ProfileBlogCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileBlogUpsertWithWhereUniqueWithoutProfileInput | ProfileBlogUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileBlogCreateManyProfileInputEnvelope
    set?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
    disconnect?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
    delete?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
    connect?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
    update?: ProfileBlogUpdateWithWhereUniqueWithoutProfileInput | ProfileBlogUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileBlogUpdateManyWithWhereWithoutProfileInput | ProfileBlogUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileBlogScalarWhereInput | ProfileBlogScalarWhereInput[]
  }

  export type PostCommentUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostCommentCreateWithoutProfileInput, PostCommentUncheckedCreateWithoutProfileInput> | PostCommentCreateWithoutProfileInput[] | PostCommentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutProfileInput | PostCommentCreateOrConnectWithoutProfileInput[]
    upsert?: PostCommentUpsertWithWhereUniqueWithoutProfileInput | PostCommentUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostCommentCreateManyProfileInputEnvelope
    set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    update?: PostCommentUpdateWithWhereUniqueWithoutProfileInput | PostCommentUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostCommentUpdateManyWithWhereWithoutProfileInput | PostCommentUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
  }

  export type PostCommentLikeUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostCommentLikeCreateWithoutProfileInput, PostCommentLikeUncheckedCreateWithoutProfileInput> | PostCommentLikeCreateWithoutProfileInput[] | PostCommentLikeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCommentLikeCreateOrConnectWithoutProfileInput | PostCommentLikeCreateOrConnectWithoutProfileInput[]
    upsert?: PostCommentLikeUpsertWithWhereUniqueWithoutProfileInput | PostCommentLikeUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostCommentLikeCreateManyProfileInputEnvelope
    set?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    disconnect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    delete?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    connect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    update?: PostCommentLikeUpdateWithWhereUniqueWithoutProfileInput | PostCommentLikeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostCommentLikeUpdateManyWithWhereWithoutProfileInput | PostCommentLikeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostCommentLikeScalarWhereInput | PostCommentLikeScalarWhereInput[]
  }

  export type PostLikeUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostLikeCreateWithoutProfileInput, PostLikeUncheckedCreateWithoutProfileInput> | PostLikeCreateWithoutProfileInput[] | PostLikeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutProfileInput | PostLikeCreateOrConnectWithoutProfileInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutProfileInput | PostLikeUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostLikeCreateManyProfileInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutProfileInput | PostLikeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutProfileInput | PostLikeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type PostShareUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostShareCreateWithoutProfileInput, PostShareUncheckedCreateWithoutProfileInput> | PostShareCreateWithoutProfileInput[] | PostShareUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostShareCreateOrConnectWithoutProfileInput | PostShareCreateOrConnectWithoutProfileInput[]
    upsert?: PostShareUpsertWithWhereUniqueWithoutProfileInput | PostShareUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostShareCreateManyProfileInputEnvelope
    set?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    disconnect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    delete?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    connect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    update?: PostShareUpdateWithWhereUniqueWithoutProfileInput | PostShareUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostShareUpdateManyWithWhereWithoutProfileInput | PostShareUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostShareScalarWhereInput | PostShareScalarWhereInput[]
  }

  export type PostSaveUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostSaveCreateWithoutProfileInput, PostSaveUncheckedCreateWithoutProfileInput> | PostSaveCreateWithoutProfileInput[] | PostSaveUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostSaveCreateOrConnectWithoutProfileInput | PostSaveCreateOrConnectWithoutProfileInput[]
    upsert?: PostSaveUpsertWithWhereUniqueWithoutProfileInput | PostSaveUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostSaveCreateManyProfileInputEnvelope
    set?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    disconnect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    delete?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    connect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    update?: PostSaveUpdateWithWhereUniqueWithoutProfileInput | PostSaveUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostSaveUpdateManyWithWhereWithoutProfileInput | PostSaveUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostSaveScalarWhereInput | PostSaveScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<EventCreateWithoutHostInput, EventUncheckedCreateWithoutHostInput> | EventCreateWithoutHostInput[] | EventUncheckedCreateWithoutHostInput[]
    connectOrCreate?: EventCreateOrConnectWithoutHostInput | EventCreateOrConnectWithoutHostInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutHostInput | EventUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: EventCreateManyHostInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutHostInput | EventUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: EventUpdateManyWithWhereWithoutHostInput | EventUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventProfileUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<EventProfileCreateWithoutProfileInput, EventProfileUncheckedCreateWithoutProfileInput> | EventProfileCreateWithoutProfileInput[] | EventProfileUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EventProfileCreateOrConnectWithoutProfileInput | EventProfileCreateOrConnectWithoutProfileInput[]
    upsert?: EventProfileUpsertWithWhereUniqueWithoutProfileInput | EventProfileUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: EventProfileCreateManyProfileInputEnvelope
    set?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    disconnect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    delete?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    connect?: EventProfileWhereUniqueInput | EventProfileWhereUniqueInput[]
    update?: EventProfileUpdateWithWhereUniqueWithoutProfileInput | EventProfileUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: EventProfileUpdateManyWithWhereWithoutProfileInput | EventProfileUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: EventProfileScalarWhereInput | EventProfileScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostCreateWithoutProfileInput, PostUncheckedCreateWithoutProfileInput> | PostCreateWithoutProfileInput[] | PostUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCreateOrConnectWithoutProfileInput | PostCreateOrConnectWithoutProfileInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutProfileInput | PostUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostCreateManyProfileInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutProfileInput | PostUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostUpdateManyWithWhereWithoutProfileInput | PostUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ProfileBiographyCreateWithoutProfileInput, ProfileBiographyUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileBiographyCreateOrConnectWithoutProfileInput
    upsert?: ProfileBiographyUpsertWithoutProfileInput
    disconnect?: ProfileBiographyWhereInput | boolean
    delete?: ProfileBiographyWhereInput | boolean
    connect?: ProfileBiographyWhereUniqueInput
    update?: XOR<XOR<ProfileBiographyUpdateToOneWithWhereWithoutProfileInput, ProfileBiographyUpdateWithoutProfileInput>, ProfileBiographyUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput = {
    create?: XOR<ProfileFriendCreateWithoutProfileOneInput, ProfileFriendUncheckedCreateWithoutProfileOneInput> | ProfileFriendCreateWithoutProfileOneInput[] | ProfileFriendUncheckedCreateWithoutProfileOneInput[]
    connectOrCreate?: ProfileFriendCreateOrConnectWithoutProfileOneInput | ProfileFriendCreateOrConnectWithoutProfileOneInput[]
    upsert?: ProfileFriendUpsertWithWhereUniqueWithoutProfileOneInput | ProfileFriendUpsertWithWhereUniqueWithoutProfileOneInput[]
    createMany?: ProfileFriendCreateManyProfileOneInputEnvelope
    set?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    disconnect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    delete?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    connect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    update?: ProfileFriendUpdateWithWhereUniqueWithoutProfileOneInput | ProfileFriendUpdateWithWhereUniqueWithoutProfileOneInput[]
    updateMany?: ProfileFriendUpdateManyWithWhereWithoutProfileOneInput | ProfileFriendUpdateManyWithWhereWithoutProfileOneInput[]
    deleteMany?: ProfileFriendScalarWhereInput | ProfileFriendScalarWhereInput[]
  }

  export type ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput = {
    create?: XOR<ProfileFriendCreateWithoutProfileTwoInput, ProfileFriendUncheckedCreateWithoutProfileTwoInput> | ProfileFriendCreateWithoutProfileTwoInput[] | ProfileFriendUncheckedCreateWithoutProfileTwoInput[]
    connectOrCreate?: ProfileFriendCreateOrConnectWithoutProfileTwoInput | ProfileFriendCreateOrConnectWithoutProfileTwoInput[]
    upsert?: ProfileFriendUpsertWithWhereUniqueWithoutProfileTwoInput | ProfileFriendUpsertWithWhereUniqueWithoutProfileTwoInput[]
    createMany?: ProfileFriendCreateManyProfileTwoInputEnvelope
    set?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    disconnect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    delete?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    connect?: ProfileFriendWhereUniqueInput | ProfileFriendWhereUniqueInput[]
    update?: ProfileFriendUpdateWithWhereUniqueWithoutProfileTwoInput | ProfileFriendUpdateWithWhereUniqueWithoutProfileTwoInput[]
    updateMany?: ProfileFriendUpdateManyWithWhereWithoutProfileTwoInput | ProfileFriendUpdateManyWithWhereWithoutProfileTwoInput[]
    deleteMany?: ProfileFriendScalarWhereInput | ProfileFriendScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutOwnerInput | GroupUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutOwnerInput | GroupUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutOwnerInput | GroupUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileGroupCreateWithoutProfileInput, ProfileGroupUncheckedCreateWithoutProfileInput> | ProfileGroupCreateWithoutProfileInput[] | ProfileGroupUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileGroupCreateOrConnectWithoutProfileInput | ProfileGroupCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileGroupUpsertWithWhereUniqueWithoutProfileInput | ProfileGroupUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileGroupCreateManyProfileInputEnvelope
    set?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    disconnect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    delete?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    connect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    update?: ProfileGroupUpdateWithWhereUniqueWithoutProfileInput | ProfileGroupUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileGroupUpdateManyWithWhereWithoutProfileInput | ProfileGroupUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileGroupScalarWhereInput | ProfileGroupScalarWhereInput[]
  }

  export type ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileBlogCreateWithoutProfileInput, ProfileBlogUncheckedCreateWithoutProfileInput> | ProfileBlogCreateWithoutProfileInput[] | ProfileBlogUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileBlogCreateOrConnectWithoutProfileInput | ProfileBlogCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileBlogUpsertWithWhereUniqueWithoutProfileInput | ProfileBlogUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileBlogCreateManyProfileInputEnvelope
    set?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
    disconnect?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
    delete?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
    connect?: ProfileBlogWhereUniqueInput | ProfileBlogWhereUniqueInput[]
    update?: ProfileBlogUpdateWithWhereUniqueWithoutProfileInput | ProfileBlogUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileBlogUpdateManyWithWhereWithoutProfileInput | ProfileBlogUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileBlogScalarWhereInput | ProfileBlogScalarWhereInput[]
  }

  export type PostCommentUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostCommentCreateWithoutProfileInput, PostCommentUncheckedCreateWithoutProfileInput> | PostCommentCreateWithoutProfileInput[] | PostCommentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutProfileInput | PostCommentCreateOrConnectWithoutProfileInput[]
    upsert?: PostCommentUpsertWithWhereUniqueWithoutProfileInput | PostCommentUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostCommentCreateManyProfileInputEnvelope
    set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    update?: PostCommentUpdateWithWhereUniqueWithoutProfileInput | PostCommentUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostCommentUpdateManyWithWhereWithoutProfileInput | PostCommentUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
  }

  export type PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostCommentLikeCreateWithoutProfileInput, PostCommentLikeUncheckedCreateWithoutProfileInput> | PostCommentLikeCreateWithoutProfileInput[] | PostCommentLikeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostCommentLikeCreateOrConnectWithoutProfileInput | PostCommentLikeCreateOrConnectWithoutProfileInput[]
    upsert?: PostCommentLikeUpsertWithWhereUniqueWithoutProfileInput | PostCommentLikeUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostCommentLikeCreateManyProfileInputEnvelope
    set?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    disconnect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    delete?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    connect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    update?: PostCommentLikeUpdateWithWhereUniqueWithoutProfileInput | PostCommentLikeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostCommentLikeUpdateManyWithWhereWithoutProfileInput | PostCommentLikeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostCommentLikeScalarWhereInput | PostCommentLikeScalarWhereInput[]
  }

  export type PostLikeUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostLikeCreateWithoutProfileInput, PostLikeUncheckedCreateWithoutProfileInput> | PostLikeCreateWithoutProfileInput[] | PostLikeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutProfileInput | PostLikeCreateOrConnectWithoutProfileInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutProfileInput | PostLikeUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostLikeCreateManyProfileInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutProfileInput | PostLikeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutProfileInput | PostLikeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type PostShareUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostShareCreateWithoutProfileInput, PostShareUncheckedCreateWithoutProfileInput> | PostShareCreateWithoutProfileInput[] | PostShareUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostShareCreateOrConnectWithoutProfileInput | PostShareCreateOrConnectWithoutProfileInput[]
    upsert?: PostShareUpsertWithWhereUniqueWithoutProfileInput | PostShareUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostShareCreateManyProfileInputEnvelope
    set?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    disconnect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    delete?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    connect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    update?: PostShareUpdateWithWhereUniqueWithoutProfileInput | PostShareUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostShareUpdateManyWithWhereWithoutProfileInput | PostShareUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostShareScalarWhereInput | PostShareScalarWhereInput[]
  }

  export type PostSaveUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostSaveCreateWithoutProfileInput, PostSaveUncheckedCreateWithoutProfileInput> | PostSaveCreateWithoutProfileInput[] | PostSaveUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostSaveCreateOrConnectWithoutProfileInput | PostSaveCreateOrConnectWithoutProfileInput[]
    upsert?: PostSaveUpsertWithWhereUniqueWithoutProfileInput | PostSaveUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostSaveCreateManyProfileInputEnvelope
    set?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    disconnect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    delete?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    connect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    update?: PostSaveUpdateWithWhereUniqueWithoutProfileInput | PostSaveUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostSaveUpdateManyWithWhereWithoutProfileInput | PostSaveUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostSaveScalarWhereInput | PostSaveScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutFriendRequestsInput = {
    create?: XOR<ProfileCreateWithoutFriendRequestsInput, ProfileUncheckedCreateWithoutFriendRequestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFriendRequestsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutFriendReceivedInput = {
    create?: XOR<ProfileCreateWithoutFriendReceivedInput, ProfileUncheckedCreateWithoutFriendReceivedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFriendReceivedInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutFriendRequestsNestedInput = {
    create?: XOR<ProfileCreateWithoutFriendRequestsInput, ProfileUncheckedCreateWithoutFriendRequestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFriendRequestsInput
    upsert?: ProfileUpsertWithoutFriendRequestsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutFriendRequestsInput, ProfileUpdateWithoutFriendRequestsInput>, ProfileUncheckedUpdateWithoutFriendRequestsInput>
  }

  export type ProfileUpdateOneRequiredWithoutFriendReceivedNestedInput = {
    create?: XOR<ProfileCreateWithoutFriendReceivedInput, ProfileUncheckedCreateWithoutFriendReceivedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFriendReceivedInput
    upsert?: ProfileUpsertWithoutFriendReceivedInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutFriendReceivedInput, ProfileUpdateWithoutFriendReceivedInput>, ProfileUncheckedUpdateWithoutFriendReceivedInput>
  }

  export type ProfileBiographyAreaCreateNestedManyWithoutAreaInput = {
    create?: XOR<ProfileBiographyAreaCreateWithoutAreaInput, ProfileBiographyAreaUncheckedCreateWithoutAreaInput> | ProfileBiographyAreaCreateWithoutAreaInput[] | ProfileBiographyAreaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ProfileBiographyAreaCreateOrConnectWithoutAreaInput | ProfileBiographyAreaCreateOrConnectWithoutAreaInput[]
    createMany?: ProfileBiographyAreaCreateManyAreaInputEnvelope
    connect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
  }

  export type ProfileBiographyAreaUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<ProfileBiographyAreaCreateWithoutAreaInput, ProfileBiographyAreaUncheckedCreateWithoutAreaInput> | ProfileBiographyAreaCreateWithoutAreaInput[] | ProfileBiographyAreaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ProfileBiographyAreaCreateOrConnectWithoutAreaInput | ProfileBiographyAreaCreateOrConnectWithoutAreaInput[]
    createMany?: ProfileBiographyAreaCreateManyAreaInputEnvelope
    connect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
  }

  export type ProfileBiographyAreaUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ProfileBiographyAreaCreateWithoutAreaInput, ProfileBiographyAreaUncheckedCreateWithoutAreaInput> | ProfileBiographyAreaCreateWithoutAreaInput[] | ProfileBiographyAreaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ProfileBiographyAreaCreateOrConnectWithoutAreaInput | ProfileBiographyAreaCreateOrConnectWithoutAreaInput[]
    upsert?: ProfileBiographyAreaUpsertWithWhereUniqueWithoutAreaInput | ProfileBiographyAreaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ProfileBiographyAreaCreateManyAreaInputEnvelope
    set?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    disconnect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    delete?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    connect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    update?: ProfileBiographyAreaUpdateWithWhereUniqueWithoutAreaInput | ProfileBiographyAreaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ProfileBiographyAreaUpdateManyWithWhereWithoutAreaInput | ProfileBiographyAreaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ProfileBiographyAreaScalarWhereInput | ProfileBiographyAreaScalarWhereInput[]
  }

  export type ProfileBiographyAreaUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ProfileBiographyAreaCreateWithoutAreaInput, ProfileBiographyAreaUncheckedCreateWithoutAreaInput> | ProfileBiographyAreaCreateWithoutAreaInput[] | ProfileBiographyAreaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ProfileBiographyAreaCreateOrConnectWithoutAreaInput | ProfileBiographyAreaCreateOrConnectWithoutAreaInput[]
    upsert?: ProfileBiographyAreaUpsertWithWhereUniqueWithoutAreaInput | ProfileBiographyAreaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ProfileBiographyAreaCreateManyAreaInputEnvelope
    set?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    disconnect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    delete?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    connect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    update?: ProfileBiographyAreaUpdateWithWhereUniqueWithoutAreaInput | ProfileBiographyAreaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ProfileBiographyAreaUpdateManyWithWhereWithoutAreaInput | ProfileBiographyAreaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ProfileBiographyAreaScalarWhereInput | ProfileBiographyAreaScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutBiographyInput = {
    create?: XOR<ProfileCreateWithoutBiographyInput, ProfileUncheckedCreateWithoutBiographyInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBiographyInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileBiographyAreaCreateNestedManyWithoutBiographyInput = {
    create?: XOR<ProfileBiographyAreaCreateWithoutBiographyInput, ProfileBiographyAreaUncheckedCreateWithoutBiographyInput> | ProfileBiographyAreaCreateWithoutBiographyInput[] | ProfileBiographyAreaUncheckedCreateWithoutBiographyInput[]
    connectOrCreate?: ProfileBiographyAreaCreateOrConnectWithoutBiographyInput | ProfileBiographyAreaCreateOrConnectWithoutBiographyInput[]
    createMany?: ProfileBiographyAreaCreateManyBiographyInputEnvelope
    connect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
  }

  export type ProfileBiographySocialCreateNestedManyWithoutProfileBiographyInput = {
    create?: XOR<ProfileBiographySocialCreateWithoutProfileBiographyInput, ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput> | ProfileBiographySocialCreateWithoutProfileBiographyInput[] | ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput[]
    connectOrCreate?: ProfileBiographySocialCreateOrConnectWithoutProfileBiographyInput | ProfileBiographySocialCreateOrConnectWithoutProfileBiographyInput[]
    createMany?: ProfileBiographySocialCreateManyProfileBiographyInputEnvelope
    connect?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
  }

  export type ProfileBiographyAreaUncheckedCreateNestedManyWithoutBiographyInput = {
    create?: XOR<ProfileBiographyAreaCreateWithoutBiographyInput, ProfileBiographyAreaUncheckedCreateWithoutBiographyInput> | ProfileBiographyAreaCreateWithoutBiographyInput[] | ProfileBiographyAreaUncheckedCreateWithoutBiographyInput[]
    connectOrCreate?: ProfileBiographyAreaCreateOrConnectWithoutBiographyInput | ProfileBiographyAreaCreateOrConnectWithoutBiographyInput[]
    createMany?: ProfileBiographyAreaCreateManyBiographyInputEnvelope
    connect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
  }

  export type ProfileBiographySocialUncheckedCreateNestedManyWithoutProfileBiographyInput = {
    create?: XOR<ProfileBiographySocialCreateWithoutProfileBiographyInput, ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput> | ProfileBiographySocialCreateWithoutProfileBiographyInput[] | ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput[]
    connectOrCreate?: ProfileBiographySocialCreateOrConnectWithoutProfileBiographyInput | ProfileBiographySocialCreateOrConnectWithoutProfileBiographyInput[]
    createMany?: ProfileBiographySocialCreateManyProfileBiographyInputEnvelope
    connect?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
  }

  export type ProfileUpdateOneRequiredWithoutBiographyNestedInput = {
    create?: XOR<ProfileCreateWithoutBiographyInput, ProfileUncheckedCreateWithoutBiographyInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBiographyInput
    upsert?: ProfileUpsertWithoutBiographyInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutBiographyInput, ProfileUpdateWithoutBiographyInput>, ProfileUncheckedUpdateWithoutBiographyInput>
  }

  export type ProfileBiographyAreaUpdateManyWithoutBiographyNestedInput = {
    create?: XOR<ProfileBiographyAreaCreateWithoutBiographyInput, ProfileBiographyAreaUncheckedCreateWithoutBiographyInput> | ProfileBiographyAreaCreateWithoutBiographyInput[] | ProfileBiographyAreaUncheckedCreateWithoutBiographyInput[]
    connectOrCreate?: ProfileBiographyAreaCreateOrConnectWithoutBiographyInput | ProfileBiographyAreaCreateOrConnectWithoutBiographyInput[]
    upsert?: ProfileBiographyAreaUpsertWithWhereUniqueWithoutBiographyInput | ProfileBiographyAreaUpsertWithWhereUniqueWithoutBiographyInput[]
    createMany?: ProfileBiographyAreaCreateManyBiographyInputEnvelope
    set?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    disconnect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    delete?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    connect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    update?: ProfileBiographyAreaUpdateWithWhereUniqueWithoutBiographyInput | ProfileBiographyAreaUpdateWithWhereUniqueWithoutBiographyInput[]
    updateMany?: ProfileBiographyAreaUpdateManyWithWhereWithoutBiographyInput | ProfileBiographyAreaUpdateManyWithWhereWithoutBiographyInput[]
    deleteMany?: ProfileBiographyAreaScalarWhereInput | ProfileBiographyAreaScalarWhereInput[]
  }

  export type ProfileBiographySocialUpdateManyWithoutProfileBiographyNestedInput = {
    create?: XOR<ProfileBiographySocialCreateWithoutProfileBiographyInput, ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput> | ProfileBiographySocialCreateWithoutProfileBiographyInput[] | ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput[]
    connectOrCreate?: ProfileBiographySocialCreateOrConnectWithoutProfileBiographyInput | ProfileBiographySocialCreateOrConnectWithoutProfileBiographyInput[]
    upsert?: ProfileBiographySocialUpsertWithWhereUniqueWithoutProfileBiographyInput | ProfileBiographySocialUpsertWithWhereUniqueWithoutProfileBiographyInput[]
    createMany?: ProfileBiographySocialCreateManyProfileBiographyInputEnvelope
    set?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
    disconnect?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
    delete?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
    connect?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
    update?: ProfileBiographySocialUpdateWithWhereUniqueWithoutProfileBiographyInput | ProfileBiographySocialUpdateWithWhereUniqueWithoutProfileBiographyInput[]
    updateMany?: ProfileBiographySocialUpdateManyWithWhereWithoutProfileBiographyInput | ProfileBiographySocialUpdateManyWithWhereWithoutProfileBiographyInput[]
    deleteMany?: ProfileBiographySocialScalarWhereInput | ProfileBiographySocialScalarWhereInput[]
  }

  export type ProfileBiographyAreaUncheckedUpdateManyWithoutBiographyNestedInput = {
    create?: XOR<ProfileBiographyAreaCreateWithoutBiographyInput, ProfileBiographyAreaUncheckedCreateWithoutBiographyInput> | ProfileBiographyAreaCreateWithoutBiographyInput[] | ProfileBiographyAreaUncheckedCreateWithoutBiographyInput[]
    connectOrCreate?: ProfileBiographyAreaCreateOrConnectWithoutBiographyInput | ProfileBiographyAreaCreateOrConnectWithoutBiographyInput[]
    upsert?: ProfileBiographyAreaUpsertWithWhereUniqueWithoutBiographyInput | ProfileBiographyAreaUpsertWithWhereUniqueWithoutBiographyInput[]
    createMany?: ProfileBiographyAreaCreateManyBiographyInputEnvelope
    set?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    disconnect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    delete?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    connect?: ProfileBiographyAreaWhereUniqueInput | ProfileBiographyAreaWhereUniqueInput[]
    update?: ProfileBiographyAreaUpdateWithWhereUniqueWithoutBiographyInput | ProfileBiographyAreaUpdateWithWhereUniqueWithoutBiographyInput[]
    updateMany?: ProfileBiographyAreaUpdateManyWithWhereWithoutBiographyInput | ProfileBiographyAreaUpdateManyWithWhereWithoutBiographyInput[]
    deleteMany?: ProfileBiographyAreaScalarWhereInput | ProfileBiographyAreaScalarWhereInput[]
  }

  export type ProfileBiographySocialUncheckedUpdateManyWithoutProfileBiographyNestedInput = {
    create?: XOR<ProfileBiographySocialCreateWithoutProfileBiographyInput, ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput> | ProfileBiographySocialCreateWithoutProfileBiographyInput[] | ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput[]
    connectOrCreate?: ProfileBiographySocialCreateOrConnectWithoutProfileBiographyInput | ProfileBiographySocialCreateOrConnectWithoutProfileBiographyInput[]
    upsert?: ProfileBiographySocialUpsertWithWhereUniqueWithoutProfileBiographyInput | ProfileBiographySocialUpsertWithWhereUniqueWithoutProfileBiographyInput[]
    createMany?: ProfileBiographySocialCreateManyProfileBiographyInputEnvelope
    set?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
    disconnect?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
    delete?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
    connect?: ProfileBiographySocialWhereUniqueInput | ProfileBiographySocialWhereUniqueInput[]
    update?: ProfileBiographySocialUpdateWithWhereUniqueWithoutProfileBiographyInput | ProfileBiographySocialUpdateWithWhereUniqueWithoutProfileBiographyInput[]
    updateMany?: ProfileBiographySocialUpdateManyWithWhereWithoutProfileBiographyInput | ProfileBiographySocialUpdateManyWithWhereWithoutProfileBiographyInput[]
    deleteMany?: ProfileBiographySocialScalarWhereInput | ProfileBiographySocialScalarWhereInput[]
  }

  export type ProfileBiographyCreateNestedOneWithoutAreasInput = {
    create?: XOR<ProfileBiographyCreateWithoutAreasInput, ProfileBiographyUncheckedCreateWithoutAreasInput>
    connectOrCreate?: ProfileBiographyCreateOrConnectWithoutAreasInput
    connect?: ProfileBiographyWhereUniqueInput
  }

  export type AreaCreateNestedOneWithoutBiographiesInput = {
    create?: XOR<AreaCreateWithoutBiographiesInput, AreaUncheckedCreateWithoutBiographiesInput>
    connectOrCreate?: AreaCreateOrConnectWithoutBiographiesInput
    connect?: AreaWhereUniqueInput
  }

  export type ProfileBiographyUpdateOneRequiredWithoutAreasNestedInput = {
    create?: XOR<ProfileBiographyCreateWithoutAreasInput, ProfileBiographyUncheckedCreateWithoutAreasInput>
    connectOrCreate?: ProfileBiographyCreateOrConnectWithoutAreasInput
    upsert?: ProfileBiographyUpsertWithoutAreasInput
    connect?: ProfileBiographyWhereUniqueInput
    update?: XOR<XOR<ProfileBiographyUpdateToOneWithWhereWithoutAreasInput, ProfileBiographyUpdateWithoutAreasInput>, ProfileBiographyUncheckedUpdateWithoutAreasInput>
  }

  export type AreaUpdateOneRequiredWithoutBiographiesNestedInput = {
    create?: XOR<AreaCreateWithoutBiographiesInput, AreaUncheckedCreateWithoutBiographiesInput>
    connectOrCreate?: AreaCreateOrConnectWithoutBiographiesInput
    upsert?: AreaUpsertWithoutBiographiesInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutBiographiesInput, AreaUpdateWithoutBiographiesInput>, AreaUncheckedUpdateWithoutBiographiesInput>
  }

  export type ProfileBiographyCreateNestedOneWithoutSocialsInput = {
    create?: XOR<ProfileBiographyCreateWithoutSocialsInput, ProfileBiographyUncheckedCreateWithoutSocialsInput>
    connectOrCreate?: ProfileBiographyCreateOrConnectWithoutSocialsInput
    connect?: ProfileBiographyWhereUniqueInput
  }

  export type EnumSocialTypeFieldUpdateOperationsInput = {
    set?: $Enums.SocialType
  }

  export type ProfileBiographyUpdateOneRequiredWithoutSocialsNestedInput = {
    create?: XOR<ProfileBiographyCreateWithoutSocialsInput, ProfileBiographyUncheckedCreateWithoutSocialsInput>
    connectOrCreate?: ProfileBiographyCreateOrConnectWithoutSocialsInput
    upsert?: ProfileBiographyUpsertWithoutSocialsInput
    connect?: ProfileBiographyWhereUniqueInput
    update?: XOR<XOR<ProfileBiographyUpdateToOneWithWhereWithoutSocialsInput, ProfileBiographyUpdateWithoutSocialsInput>, ProfileBiographyUncheckedUpdateWithoutSocialsInput>
  }

  export type ProfileBlogImageCreateNestedManyWithoutProfileBlogInput = {
    create?: XOR<ProfileBlogImageCreateWithoutProfileBlogInput, ProfileBlogImageUncheckedCreateWithoutProfileBlogInput> | ProfileBlogImageCreateWithoutProfileBlogInput[] | ProfileBlogImageUncheckedCreateWithoutProfileBlogInput[]
    connectOrCreate?: ProfileBlogImageCreateOrConnectWithoutProfileBlogInput | ProfileBlogImageCreateOrConnectWithoutProfileBlogInput[]
    createMany?: ProfileBlogImageCreateManyProfileBlogInputEnvelope
    connect?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutBlogsInput = {
    create?: XOR<ProfileCreateWithoutBlogsInput, ProfileUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlogsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileBlogImageUncheckedCreateNestedManyWithoutProfileBlogInput = {
    create?: XOR<ProfileBlogImageCreateWithoutProfileBlogInput, ProfileBlogImageUncheckedCreateWithoutProfileBlogInput> | ProfileBlogImageCreateWithoutProfileBlogInput[] | ProfileBlogImageUncheckedCreateWithoutProfileBlogInput[]
    connectOrCreate?: ProfileBlogImageCreateOrConnectWithoutProfileBlogInput | ProfileBlogImageCreateOrConnectWithoutProfileBlogInput[]
    createMany?: ProfileBlogImageCreateManyProfileBlogInputEnvelope
    connect?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
  }

  export type ProfileBlogImageUpdateManyWithoutProfileBlogNestedInput = {
    create?: XOR<ProfileBlogImageCreateWithoutProfileBlogInput, ProfileBlogImageUncheckedCreateWithoutProfileBlogInput> | ProfileBlogImageCreateWithoutProfileBlogInput[] | ProfileBlogImageUncheckedCreateWithoutProfileBlogInput[]
    connectOrCreate?: ProfileBlogImageCreateOrConnectWithoutProfileBlogInput | ProfileBlogImageCreateOrConnectWithoutProfileBlogInput[]
    upsert?: ProfileBlogImageUpsertWithWhereUniqueWithoutProfileBlogInput | ProfileBlogImageUpsertWithWhereUniqueWithoutProfileBlogInput[]
    createMany?: ProfileBlogImageCreateManyProfileBlogInputEnvelope
    set?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
    disconnect?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
    delete?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
    connect?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
    update?: ProfileBlogImageUpdateWithWhereUniqueWithoutProfileBlogInput | ProfileBlogImageUpdateWithWhereUniqueWithoutProfileBlogInput[]
    updateMany?: ProfileBlogImageUpdateManyWithWhereWithoutProfileBlogInput | ProfileBlogImageUpdateManyWithWhereWithoutProfileBlogInput[]
    deleteMany?: ProfileBlogImageScalarWhereInput | ProfileBlogImageScalarWhereInput[]
  }

  export type ProfileUpdateOneRequiredWithoutBlogsNestedInput = {
    create?: XOR<ProfileCreateWithoutBlogsInput, ProfileUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlogsInput
    upsert?: ProfileUpsertWithoutBlogsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutBlogsInput, ProfileUpdateWithoutBlogsInput>, ProfileUncheckedUpdateWithoutBlogsInput>
  }

  export type ProfileBlogImageUncheckedUpdateManyWithoutProfileBlogNestedInput = {
    create?: XOR<ProfileBlogImageCreateWithoutProfileBlogInput, ProfileBlogImageUncheckedCreateWithoutProfileBlogInput> | ProfileBlogImageCreateWithoutProfileBlogInput[] | ProfileBlogImageUncheckedCreateWithoutProfileBlogInput[]
    connectOrCreate?: ProfileBlogImageCreateOrConnectWithoutProfileBlogInput | ProfileBlogImageCreateOrConnectWithoutProfileBlogInput[]
    upsert?: ProfileBlogImageUpsertWithWhereUniqueWithoutProfileBlogInput | ProfileBlogImageUpsertWithWhereUniqueWithoutProfileBlogInput[]
    createMany?: ProfileBlogImageCreateManyProfileBlogInputEnvelope
    set?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
    disconnect?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
    delete?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
    connect?: ProfileBlogImageWhereUniqueInput | ProfileBlogImageWhereUniqueInput[]
    update?: ProfileBlogImageUpdateWithWhereUniqueWithoutProfileBlogInput | ProfileBlogImageUpdateWithWhereUniqueWithoutProfileBlogInput[]
    updateMany?: ProfileBlogImageUpdateManyWithWhereWithoutProfileBlogInput | ProfileBlogImageUpdateManyWithWhereWithoutProfileBlogInput[]
    deleteMany?: ProfileBlogImageScalarWhereInput | ProfileBlogImageScalarWhereInput[]
  }

  export type ProfileBlogCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProfileBlogCreateWithoutImagesInput, ProfileBlogUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProfileBlogCreateOrConnectWithoutImagesInput
    connect?: ProfileBlogWhereUniqueInput
  }

  export type ProfileBlogUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ProfileBlogCreateWithoutImagesInput, ProfileBlogUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProfileBlogCreateOrConnectWithoutImagesInput
    upsert?: ProfileBlogUpsertWithoutImagesInput
    connect?: ProfileBlogWhereUniqueInput
    update?: XOR<XOR<ProfileBlogUpdateToOneWithWhereWithoutImagesInput, ProfileBlogUpdateWithoutImagesInput>, ProfileBlogUncheckedUpdateWithoutImagesInput>
  }

  export type ProfileCreateNestedOneWithoutPostsInput = {
    create?: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostsInput
    connect?: ProfileWhereUniqueInput
  }

  export type PostImageCreateNestedManyWithoutPostInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
  }

  export type PostCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput> | PostCommentCreateWithoutPostInput[] | PostCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutPostInput | PostCommentCreateOrConnectWithoutPostInput[]
    createMany?: PostCommentCreateManyPostInputEnvelope
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
  }

  export type PostLikeCreateNestedManyWithoutPostInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type PostShareCreateNestedManyWithoutPostInput = {
    create?: XOR<PostShareCreateWithoutPostInput, PostShareUncheckedCreateWithoutPostInput> | PostShareCreateWithoutPostInput[] | PostShareUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostShareCreateOrConnectWithoutPostInput | PostShareCreateOrConnectWithoutPostInput[]
    createMany?: PostShareCreateManyPostInputEnvelope
    connect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
  }

  export type PostSaveCreateNestedManyWithoutPostInput = {
    create?: XOR<PostSaveCreateWithoutPostInput, PostSaveUncheckedCreateWithoutPostInput> | PostSaveCreateWithoutPostInput[] | PostSaveUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostSaveCreateOrConnectWithoutPostInput | PostSaveCreateOrConnectWithoutPostInput[]
    createMany?: PostSaveCreateManyPostInputEnvelope
    connect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
  }

  export type PostImageUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
  }

  export type PostCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput> | PostCommentCreateWithoutPostInput[] | PostCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutPostInput | PostCommentCreateOrConnectWithoutPostInput[]
    createMany?: PostCommentCreateManyPostInputEnvelope
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
  }

  export type PostLikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type PostShareUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostShareCreateWithoutPostInput, PostShareUncheckedCreateWithoutPostInput> | PostShareCreateWithoutPostInput[] | PostShareUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostShareCreateOrConnectWithoutPostInput | PostShareCreateOrConnectWithoutPostInput[]
    createMany?: PostShareCreateManyPostInputEnvelope
    connect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
  }

  export type PostSaveUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostSaveCreateWithoutPostInput, PostSaveUncheckedCreateWithoutPostInput> | PostSaveCreateWithoutPostInput[] | PostSaveUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostSaveCreateOrConnectWithoutPostInput | PostSaveCreateOrConnectWithoutPostInput[]
    createMany?: PostSaveCreateManyPostInputEnvelope
    connect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type ProfileUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostsInput
    upsert?: ProfileUpsertWithoutPostsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostsInput, ProfileUpdateWithoutPostsInput>, ProfileUncheckedUpdateWithoutPostsInput>
  }

  export type PostImageUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    upsert?: PostImageUpsertWithWhereUniqueWithoutPostInput | PostImageUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    set?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    disconnect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    delete?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    update?: PostImageUpdateWithWhereUniqueWithoutPostInput | PostImageUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostImageUpdateManyWithWhereWithoutPostInput | PostImageUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
  }

  export type PostCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput> | PostCommentCreateWithoutPostInput[] | PostCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutPostInput | PostCommentCreateOrConnectWithoutPostInput[]
    upsert?: PostCommentUpsertWithWhereUniqueWithoutPostInput | PostCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostCommentCreateManyPostInputEnvelope
    set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    update?: PostCommentUpdateWithWhereUniqueWithoutPostInput | PostCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostCommentUpdateManyWithWhereWithoutPostInput | PostCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
  }

  export type PostLikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type PostShareUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostShareCreateWithoutPostInput, PostShareUncheckedCreateWithoutPostInput> | PostShareCreateWithoutPostInput[] | PostShareUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostShareCreateOrConnectWithoutPostInput | PostShareCreateOrConnectWithoutPostInput[]
    upsert?: PostShareUpsertWithWhereUniqueWithoutPostInput | PostShareUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostShareCreateManyPostInputEnvelope
    set?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    disconnect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    delete?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    connect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    update?: PostShareUpdateWithWhereUniqueWithoutPostInput | PostShareUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostShareUpdateManyWithWhereWithoutPostInput | PostShareUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostShareScalarWhereInput | PostShareScalarWhereInput[]
  }

  export type PostSaveUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostSaveCreateWithoutPostInput, PostSaveUncheckedCreateWithoutPostInput> | PostSaveCreateWithoutPostInput[] | PostSaveUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostSaveCreateOrConnectWithoutPostInput | PostSaveCreateOrConnectWithoutPostInput[]
    upsert?: PostSaveUpsertWithWhereUniqueWithoutPostInput | PostSaveUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostSaveCreateManyPostInputEnvelope
    set?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    disconnect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    delete?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    connect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    update?: PostSaveUpdateWithWhereUniqueWithoutPostInput | PostSaveUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostSaveUpdateManyWithWhereWithoutPostInput | PostSaveUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostSaveScalarWhereInput | PostSaveScalarWhereInput[]
  }

  export type PostImageUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    upsert?: PostImageUpsertWithWhereUniqueWithoutPostInput | PostImageUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    set?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    disconnect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    delete?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    update?: PostImageUpdateWithWhereUniqueWithoutPostInput | PostImageUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostImageUpdateManyWithWhereWithoutPostInput | PostImageUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
  }

  export type PostCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput> | PostCommentCreateWithoutPostInput[] | PostCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutPostInput | PostCommentCreateOrConnectWithoutPostInput[]
    upsert?: PostCommentUpsertWithWhereUniqueWithoutPostInput | PostCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostCommentCreateManyPostInputEnvelope
    set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    update?: PostCommentUpdateWithWhereUniqueWithoutPostInput | PostCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostCommentUpdateManyWithWhereWithoutPostInput | PostCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
  }

  export type PostLikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type PostShareUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostShareCreateWithoutPostInput, PostShareUncheckedCreateWithoutPostInput> | PostShareCreateWithoutPostInput[] | PostShareUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostShareCreateOrConnectWithoutPostInput | PostShareCreateOrConnectWithoutPostInput[]
    upsert?: PostShareUpsertWithWhereUniqueWithoutPostInput | PostShareUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostShareCreateManyPostInputEnvelope
    set?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    disconnect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    delete?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    connect?: PostShareWhereUniqueInput | PostShareWhereUniqueInput[]
    update?: PostShareUpdateWithWhereUniqueWithoutPostInput | PostShareUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostShareUpdateManyWithWhereWithoutPostInput | PostShareUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostShareScalarWhereInput | PostShareScalarWhereInput[]
  }

  export type PostSaveUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostSaveCreateWithoutPostInput, PostSaveUncheckedCreateWithoutPostInput> | PostSaveCreateWithoutPostInput[] | PostSaveUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostSaveCreateOrConnectWithoutPostInput | PostSaveCreateOrConnectWithoutPostInput[]
    upsert?: PostSaveUpsertWithWhereUniqueWithoutPostInput | PostSaveUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostSaveCreateManyPostInputEnvelope
    set?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    disconnect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    delete?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    connect?: PostSaveWhereUniqueInput | PostSaveWhereUniqueInput[]
    update?: PostSaveUpdateWithWhereUniqueWithoutPostInput | PostSaveUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostSaveUpdateManyWithWhereWithoutPostInput | PostSaveUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostSaveScalarWhereInput | PostSaveScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutImagesInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    upsert?: PostUpsertWithoutImagesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutImagesInput, PostUpdateWithoutImagesInput>, PostUncheckedUpdateWithoutImagesInput>
  }

  export type ProfileCreateNestedOneWithoutPostLikesInput = {
    create?: XOR<ProfileCreateWithoutPostLikesInput, ProfileUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostLikesInput
    connect?: ProfileWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    connect?: PostWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutPostLikesNestedInput = {
    create?: XOR<ProfileCreateWithoutPostLikesInput, ProfileUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostLikesInput
    upsert?: ProfileUpsertWithoutPostLikesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostLikesInput, ProfileUpdateWithoutPostLikesInput>, ProfileUncheckedUpdateWithoutPostLikesInput>
  }

  export type PostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    upsert?: PostUpsertWithoutLikesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutLikesInput, PostUpdateWithoutLikesInput>, PostUncheckedUpdateWithoutLikesInput>
  }

  export type ProfileCreateNestedOneWithoutPostSharesInput = {
    create?: XOR<ProfileCreateWithoutPostSharesInput, ProfileUncheckedCreateWithoutPostSharesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostSharesInput
    connect?: ProfileWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutSharesInput = {
    create?: XOR<PostCreateWithoutSharesInput, PostUncheckedCreateWithoutSharesInput>
    connectOrCreate?: PostCreateOrConnectWithoutSharesInput
    connect?: PostWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutPostSharesNestedInput = {
    create?: XOR<ProfileCreateWithoutPostSharesInput, ProfileUncheckedCreateWithoutPostSharesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostSharesInput
    upsert?: ProfileUpsertWithoutPostSharesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostSharesInput, ProfileUpdateWithoutPostSharesInput>, ProfileUncheckedUpdateWithoutPostSharesInput>
  }

  export type PostUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<PostCreateWithoutSharesInput, PostUncheckedCreateWithoutSharesInput>
    connectOrCreate?: PostCreateOrConnectWithoutSharesInput
    upsert?: PostUpsertWithoutSharesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutSharesInput, PostUpdateWithoutSharesInput>, PostUncheckedUpdateWithoutSharesInput>
  }

  export type ProfileCreateNestedOneWithoutPostSavedInput = {
    create?: XOR<ProfileCreateWithoutPostSavedInput, ProfileUncheckedCreateWithoutPostSavedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostSavedInput
    connect?: ProfileWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutSavesInput = {
    create?: XOR<PostCreateWithoutSavesInput, PostUncheckedCreateWithoutSavesInput>
    connectOrCreate?: PostCreateOrConnectWithoutSavesInput
    connect?: PostWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutPostSavedNestedInput = {
    create?: XOR<ProfileCreateWithoutPostSavedInput, ProfileUncheckedCreateWithoutPostSavedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostSavedInput
    upsert?: ProfileUpsertWithoutPostSavedInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostSavedInput, ProfileUpdateWithoutPostSavedInput>, ProfileUncheckedUpdateWithoutPostSavedInput>
  }

  export type PostUpdateOneRequiredWithoutSavesNestedInput = {
    create?: XOR<PostCreateWithoutSavesInput, PostUncheckedCreateWithoutSavesInput>
    connectOrCreate?: PostCreateOrConnectWithoutSavesInput
    upsert?: PostUpsertWithoutSavesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutSavesInput, PostUpdateWithoutSavesInput>, PostUncheckedUpdateWithoutSavesInput>
  }

  export type ProfileCreateNestedOneWithoutPostCommentsInput = {
    create?: XOR<ProfileCreateWithoutPostCommentsInput, ProfileUncheckedCreateWithoutPostCommentsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostCommentsInput
    connect?: ProfileWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type PostCommentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<PostCommentCreateWithoutChildrenInput, PostCommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PostCommentCreateOrConnectWithoutChildrenInput
    connect?: PostCommentWhereUniqueInput
  }

  export type PostCommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<PostCommentCreateWithoutParentCommentInput, PostCommentUncheckedCreateWithoutParentCommentInput> | PostCommentCreateWithoutParentCommentInput[] | PostCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutParentCommentInput | PostCommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: PostCommentCreateManyParentCommentInputEnvelope
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
  }

  export type PostCommentLikeCreateNestedManyWithoutPostCommentInput = {
    create?: XOR<PostCommentLikeCreateWithoutPostCommentInput, PostCommentLikeUncheckedCreateWithoutPostCommentInput> | PostCommentLikeCreateWithoutPostCommentInput[] | PostCommentLikeUncheckedCreateWithoutPostCommentInput[]
    connectOrCreate?: PostCommentLikeCreateOrConnectWithoutPostCommentInput | PostCommentLikeCreateOrConnectWithoutPostCommentInput[]
    createMany?: PostCommentLikeCreateManyPostCommentInputEnvelope
    connect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
  }

  export type PostCommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<PostCommentCreateWithoutParentCommentInput, PostCommentUncheckedCreateWithoutParentCommentInput> | PostCommentCreateWithoutParentCommentInput[] | PostCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutParentCommentInput | PostCommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: PostCommentCreateManyParentCommentInputEnvelope
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
  }

  export type PostCommentLikeUncheckedCreateNestedManyWithoutPostCommentInput = {
    create?: XOR<PostCommentLikeCreateWithoutPostCommentInput, PostCommentLikeUncheckedCreateWithoutPostCommentInput> | PostCommentLikeCreateWithoutPostCommentInput[] | PostCommentLikeUncheckedCreateWithoutPostCommentInput[]
    connectOrCreate?: PostCommentLikeCreateOrConnectWithoutPostCommentInput | PostCommentLikeCreateOrConnectWithoutPostCommentInput[]
    createMany?: PostCommentLikeCreateManyPostCommentInputEnvelope
    connect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
  }

  export type ProfileUpdateOneRequiredWithoutPostCommentsNestedInput = {
    create?: XOR<ProfileCreateWithoutPostCommentsInput, ProfileUncheckedCreateWithoutPostCommentsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostCommentsInput
    upsert?: ProfileUpsertWithoutPostCommentsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostCommentsInput, ProfileUpdateWithoutPostCommentsInput>, ProfileUncheckedUpdateWithoutPostCommentsInput>
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostCommentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<PostCommentCreateWithoutChildrenInput, PostCommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PostCommentCreateOrConnectWithoutChildrenInput
    upsert?: PostCommentUpsertWithoutChildrenInput
    disconnect?: PostCommentWhereInput | boolean
    delete?: PostCommentWhereInput | boolean
    connect?: PostCommentWhereUniqueInput
    update?: XOR<XOR<PostCommentUpdateToOneWithWhereWithoutChildrenInput, PostCommentUpdateWithoutChildrenInput>, PostCommentUncheckedUpdateWithoutChildrenInput>
  }

  export type PostCommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<PostCommentCreateWithoutParentCommentInput, PostCommentUncheckedCreateWithoutParentCommentInput> | PostCommentCreateWithoutParentCommentInput[] | PostCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutParentCommentInput | PostCommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: PostCommentUpsertWithWhereUniqueWithoutParentCommentInput | PostCommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: PostCommentCreateManyParentCommentInputEnvelope
    set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    update?: PostCommentUpdateWithWhereUniqueWithoutParentCommentInput | PostCommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: PostCommentUpdateManyWithWhereWithoutParentCommentInput | PostCommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
  }

  export type PostCommentLikeUpdateManyWithoutPostCommentNestedInput = {
    create?: XOR<PostCommentLikeCreateWithoutPostCommentInput, PostCommentLikeUncheckedCreateWithoutPostCommentInput> | PostCommentLikeCreateWithoutPostCommentInput[] | PostCommentLikeUncheckedCreateWithoutPostCommentInput[]
    connectOrCreate?: PostCommentLikeCreateOrConnectWithoutPostCommentInput | PostCommentLikeCreateOrConnectWithoutPostCommentInput[]
    upsert?: PostCommentLikeUpsertWithWhereUniqueWithoutPostCommentInput | PostCommentLikeUpsertWithWhereUniqueWithoutPostCommentInput[]
    createMany?: PostCommentLikeCreateManyPostCommentInputEnvelope
    set?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    disconnect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    delete?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    connect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    update?: PostCommentLikeUpdateWithWhereUniqueWithoutPostCommentInput | PostCommentLikeUpdateWithWhereUniqueWithoutPostCommentInput[]
    updateMany?: PostCommentLikeUpdateManyWithWhereWithoutPostCommentInput | PostCommentLikeUpdateManyWithWhereWithoutPostCommentInput[]
    deleteMany?: PostCommentLikeScalarWhereInput | PostCommentLikeScalarWhereInput[]
  }

  export type PostCommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<PostCommentCreateWithoutParentCommentInput, PostCommentUncheckedCreateWithoutParentCommentInput> | PostCommentCreateWithoutParentCommentInput[] | PostCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: PostCommentCreateOrConnectWithoutParentCommentInput | PostCommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: PostCommentUpsertWithWhereUniqueWithoutParentCommentInput | PostCommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: PostCommentCreateManyParentCommentInputEnvelope
    set?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    disconnect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    delete?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    connect?: PostCommentWhereUniqueInput | PostCommentWhereUniqueInput[]
    update?: PostCommentUpdateWithWhereUniqueWithoutParentCommentInput | PostCommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: PostCommentUpdateManyWithWhereWithoutParentCommentInput | PostCommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
  }

  export type PostCommentLikeUncheckedUpdateManyWithoutPostCommentNestedInput = {
    create?: XOR<PostCommentLikeCreateWithoutPostCommentInput, PostCommentLikeUncheckedCreateWithoutPostCommentInput> | PostCommentLikeCreateWithoutPostCommentInput[] | PostCommentLikeUncheckedCreateWithoutPostCommentInput[]
    connectOrCreate?: PostCommentLikeCreateOrConnectWithoutPostCommentInput | PostCommentLikeCreateOrConnectWithoutPostCommentInput[]
    upsert?: PostCommentLikeUpsertWithWhereUniqueWithoutPostCommentInput | PostCommentLikeUpsertWithWhereUniqueWithoutPostCommentInput[]
    createMany?: PostCommentLikeCreateManyPostCommentInputEnvelope
    set?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    disconnect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    delete?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    connect?: PostCommentLikeWhereUniqueInput | PostCommentLikeWhereUniqueInput[]
    update?: PostCommentLikeUpdateWithWhereUniqueWithoutPostCommentInput | PostCommentLikeUpdateWithWhereUniqueWithoutPostCommentInput[]
    updateMany?: PostCommentLikeUpdateManyWithWhereWithoutPostCommentInput | PostCommentLikeUpdateManyWithWhereWithoutPostCommentInput[]
    deleteMany?: PostCommentLikeScalarWhereInput | PostCommentLikeScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutPostCommentLikesInput = {
    create?: XOR<ProfileCreateWithoutPostCommentLikesInput, ProfileUncheckedCreateWithoutPostCommentLikesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostCommentLikesInput
    connect?: ProfileWhereUniqueInput
  }

  export type PostCommentCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostCommentCreateWithoutLikesInput, PostCommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCommentCreateOrConnectWithoutLikesInput
    connect?: PostCommentWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutPostCommentLikesNestedInput = {
    create?: XOR<ProfileCreateWithoutPostCommentLikesInput, ProfileUncheckedCreateWithoutPostCommentLikesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostCommentLikesInput
    upsert?: ProfileUpsertWithoutPostCommentLikesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostCommentLikesInput, ProfileUpdateWithoutPostCommentLikesInput>, ProfileUncheckedUpdateWithoutPostCommentLikesInput>
  }

  export type PostCommentUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PostCommentCreateWithoutLikesInput, PostCommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCommentCreateOrConnectWithoutLikesInput
    upsert?: PostCommentUpsertWithoutLikesInput
    connect?: PostCommentWhereUniqueInput
    update?: XOR<XOR<PostCommentUpdateToOneWithWhereWithoutLikesInput, PostCommentUpdateWithoutLikesInput>, PostCommentUncheckedUpdateWithoutLikesInput>
  }

  export type ProfileCreateNestedOneWithoutOwnedGroupsInput = {
    create?: XOR<ProfileCreateWithoutOwnedGroupsInput, ProfileUncheckedCreateWithoutOwnedGroupsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutOwnedGroupsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileGroupCreateNestedManyWithoutGroupInput = {
    create?: XOR<ProfileGroupCreateWithoutGroupInput, ProfileGroupUncheckedCreateWithoutGroupInput> | ProfileGroupCreateWithoutGroupInput[] | ProfileGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ProfileGroupCreateOrConnectWithoutGroupInput | ProfileGroupCreateOrConnectWithoutGroupInput[]
    createMany?: ProfileGroupCreateManyGroupInputEnvelope
    connect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
  }

  export type ProfileGroupUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ProfileGroupCreateWithoutGroupInput, ProfileGroupUncheckedCreateWithoutGroupInput> | ProfileGroupCreateWithoutGroupInput[] | ProfileGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ProfileGroupCreateOrConnectWithoutGroupInput | ProfileGroupCreateOrConnectWithoutGroupInput[]
    createMany?: ProfileGroupCreateManyGroupInputEnvelope
    connect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
  }

  export type ProfileUpdateOneRequiredWithoutOwnedGroupsNestedInput = {
    create?: XOR<ProfileCreateWithoutOwnedGroupsInput, ProfileUncheckedCreateWithoutOwnedGroupsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutOwnedGroupsInput
    upsert?: ProfileUpsertWithoutOwnedGroupsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutOwnedGroupsInput, ProfileUpdateWithoutOwnedGroupsInput>, ProfileUncheckedUpdateWithoutOwnedGroupsInput>
  }

  export type ProfileGroupUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ProfileGroupCreateWithoutGroupInput, ProfileGroupUncheckedCreateWithoutGroupInput> | ProfileGroupCreateWithoutGroupInput[] | ProfileGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ProfileGroupCreateOrConnectWithoutGroupInput | ProfileGroupCreateOrConnectWithoutGroupInput[]
    upsert?: ProfileGroupUpsertWithWhereUniqueWithoutGroupInput | ProfileGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ProfileGroupCreateManyGroupInputEnvelope
    set?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    disconnect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    delete?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    connect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    update?: ProfileGroupUpdateWithWhereUniqueWithoutGroupInput | ProfileGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ProfileGroupUpdateManyWithWhereWithoutGroupInput | ProfileGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ProfileGroupScalarWhereInput | ProfileGroupScalarWhereInput[]
  }

  export type ProfileGroupUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ProfileGroupCreateWithoutGroupInput, ProfileGroupUncheckedCreateWithoutGroupInput> | ProfileGroupCreateWithoutGroupInput[] | ProfileGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ProfileGroupCreateOrConnectWithoutGroupInput | ProfileGroupCreateOrConnectWithoutGroupInput[]
    upsert?: ProfileGroupUpsertWithWhereUniqueWithoutGroupInput | ProfileGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ProfileGroupCreateManyGroupInputEnvelope
    set?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    disconnect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    delete?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    connect?: ProfileGroupWhereUniqueInput | ProfileGroupWhereUniqueInput[]
    update?: ProfileGroupUpdateWithWhereUniqueWithoutGroupInput | ProfileGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ProfileGroupUpdateManyWithWhereWithoutGroupInput | ProfileGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ProfileGroupScalarWhereInput | ProfileGroupScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutGroupsInput = {
    create?: XOR<ProfileCreateWithoutGroupsInput, ProfileUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutGroupsInput
    connect?: ProfileWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutProfilesInput = {
    create?: XOR<GroupCreateWithoutProfilesInput, GroupUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutProfilesInput
    connect?: GroupWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<ProfileCreateWithoutGroupsInput, ProfileUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutGroupsInput
    upsert?: ProfileUpsertWithoutGroupsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutGroupsInput, ProfileUpdateWithoutGroupsInput>, ProfileUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<GroupCreateWithoutProfilesInput, GroupUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutProfilesInput
    upsert?: GroupUpsertWithoutProfilesInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutProfilesInput, GroupUpdateWithoutProfilesInput>, GroupUncheckedUpdateWithoutProfilesInput>
  }

  export type SchoolCreateNestedOneWithoutNewsInput = {
    create?: XOR<SchoolCreateWithoutNewsInput, SchoolUncheckedCreateWithoutNewsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutNewsInput
    connect?: SchoolWhereUniqueInput
  }

  export type NewsNotificationCreateNestedManyWithoutNewsInput = {
    create?: XOR<NewsNotificationCreateWithoutNewsInput, NewsNotificationUncheckedCreateWithoutNewsInput> | NewsNotificationCreateWithoutNewsInput[] | NewsNotificationUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutNewsInput | NewsNotificationCreateOrConnectWithoutNewsInput[]
    createMany?: NewsNotificationCreateManyNewsInputEnvelope
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
  }

  export type NewsNotificationUncheckedCreateNestedManyWithoutNewsInput = {
    create?: XOR<NewsNotificationCreateWithoutNewsInput, NewsNotificationUncheckedCreateWithoutNewsInput> | NewsNotificationCreateWithoutNewsInput[] | NewsNotificationUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutNewsInput | NewsNotificationCreateOrConnectWithoutNewsInput[]
    createMany?: NewsNotificationCreateManyNewsInputEnvelope
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
  }

  export type EnumNewsTypeFieldUpdateOperationsInput = {
    set?: $Enums.NewsType
  }

  export type SchoolUpdateOneWithoutNewsNestedInput = {
    create?: XOR<SchoolCreateWithoutNewsInput, SchoolUncheckedCreateWithoutNewsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutNewsInput
    upsert?: SchoolUpsertWithoutNewsInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutNewsInput, SchoolUpdateWithoutNewsInput>, SchoolUncheckedUpdateWithoutNewsInput>
  }

  export type NewsNotificationUpdateManyWithoutNewsNestedInput = {
    create?: XOR<NewsNotificationCreateWithoutNewsInput, NewsNotificationUncheckedCreateWithoutNewsInput> | NewsNotificationCreateWithoutNewsInput[] | NewsNotificationUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutNewsInput | NewsNotificationCreateOrConnectWithoutNewsInput[]
    upsert?: NewsNotificationUpsertWithWhereUniqueWithoutNewsInput | NewsNotificationUpsertWithWhereUniqueWithoutNewsInput[]
    createMany?: NewsNotificationCreateManyNewsInputEnvelope
    set?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    disconnect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    delete?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    update?: NewsNotificationUpdateWithWhereUniqueWithoutNewsInput | NewsNotificationUpdateWithWhereUniqueWithoutNewsInput[]
    updateMany?: NewsNotificationUpdateManyWithWhereWithoutNewsInput | NewsNotificationUpdateManyWithWhereWithoutNewsInput[]
    deleteMany?: NewsNotificationScalarWhereInput | NewsNotificationScalarWhereInput[]
  }

  export type NewsNotificationUncheckedUpdateManyWithoutNewsNestedInput = {
    create?: XOR<NewsNotificationCreateWithoutNewsInput, NewsNotificationUncheckedCreateWithoutNewsInput> | NewsNotificationCreateWithoutNewsInput[] | NewsNotificationUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: NewsNotificationCreateOrConnectWithoutNewsInput | NewsNotificationCreateOrConnectWithoutNewsInput[]
    upsert?: NewsNotificationUpsertWithWhereUniqueWithoutNewsInput | NewsNotificationUpsertWithWhereUniqueWithoutNewsInput[]
    createMany?: NewsNotificationCreateManyNewsInputEnvelope
    set?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    disconnect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    delete?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    connect?: NewsNotificationWhereUniqueInput | NewsNotificationWhereUniqueInput[]
    update?: NewsNotificationUpdateWithWhereUniqueWithoutNewsInput | NewsNotificationUpdateWithWhereUniqueWithoutNewsInput[]
    updateMany?: NewsNotificationUpdateManyWithWhereWithoutNewsInput | NewsNotificationUpdateManyWithWhereWithoutNewsInput[]
    deleteMany?: NewsNotificationScalarWhereInput | NewsNotificationScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNotificationsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutOwnedNotificationsInput = {
    create?: XOR<StudentCreateWithoutOwnedNotificationsInput, StudentUncheckedCreateWithoutOwnedNotificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutOwnedNotificationsInput
    connect?: StudentWhereUniqueInput
  }

  export type NewsCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<NewsCreateWithoutNotificationsInput, NewsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NewsCreateOrConnectWithoutNotificationsInput
    connect?: NewsWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNotificationsInput
    upsert?: StudentUpsertWithoutNotificationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutNotificationsInput, StudentUpdateWithoutNotificationsInput>, StudentUncheckedUpdateWithoutNotificationsInput>
  }

  export type StudentUpdateOneWithoutOwnedNotificationsNestedInput = {
    create?: XOR<StudentCreateWithoutOwnedNotificationsInput, StudentUncheckedCreateWithoutOwnedNotificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutOwnedNotificationsInput
    upsert?: StudentUpsertWithoutOwnedNotificationsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutOwnedNotificationsInput, StudentUpdateWithoutOwnedNotificationsInput>, StudentUncheckedUpdateWithoutOwnedNotificationsInput>
  }

  export type NewsUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<NewsCreateWithoutNotificationsInput, NewsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NewsCreateOrConnectWithoutNotificationsInput
    upsert?: NewsUpsertWithoutNotificationsInput
    connect?: NewsWhereUniqueInput
    update?: XOR<XOR<NewsUpdateToOneWithWhereWithoutNotificationsInput, NewsUpdateWithoutNotificationsInput>, NewsUncheckedUpdateWithoutNotificationsInput>
  }

  export type StudentCreateNestedOneWithoutFollowsInput = {
    create?: XOR<StudentCreateWithoutFollowsInput, StudentUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFollowsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutFollowersInput = {
    create?: XOR<StudentCreateWithoutFollowersInput, StudentUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFollowersInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutFollowsNestedInput = {
    create?: XOR<StudentCreateWithoutFollowsInput, StudentUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFollowsInput
    upsert?: StudentUpsertWithoutFollowsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFollowsInput, StudentUpdateWithoutFollowsInput>, StudentUncheckedUpdateWithoutFollowsInput>
  }

  export type StudentUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<StudentCreateWithoutFollowersInput, StudentUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFollowersInput
    upsert?: StudentUpsertWithoutFollowersInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFollowersInput, StudentUpdateWithoutFollowersInput>, StudentUncheckedUpdateWithoutFollowersInput>
  }

  export type SchoolCreateNestedOneWithoutContactsInput = {
    create?: XOR<SchoolCreateWithoutContactsInput, SchoolUncheckedCreateWithoutContactsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutContactsInput
    connect?: SchoolWhereUniqueInput
  }

  export type EnumContactTitleFieldUpdateOperationsInput = {
    set?: $Enums.ContactTitle
  }

  export type SchoolUpdateOneWithoutContactsNestedInput = {
    create?: XOR<SchoolCreateWithoutContactsInput, SchoolUncheckedCreateWithoutContactsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutContactsInput
    upsert?: SchoolUpsertWithoutContactsInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutContactsInput, SchoolUpdateWithoutContactsInput>, SchoolUncheckedUpdateWithoutContactsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCountryFilter<$PrismaModel = never> = {
    equals?: $Enums.Country | EnumCountryFieldRefInput<$PrismaModel>
    in?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    not?: NestedEnumCountryFilter<$PrismaModel> | $Enums.Country
  }

  export type NestedEnumCountryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Country | EnumCountryFieldRefInput<$PrismaModel>
    in?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    not?: NestedEnumCountryWithAggregatesFilter<$PrismaModel> | $Enums.Country
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCountryFilter<$PrismaModel>
    _max?: NestedEnumCountryFilter<$PrismaModel>
  }

  export type NestedEnumDegreeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DegreeType | EnumDegreeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DegreeType[] | ListEnumDegreeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DegreeType[] | ListEnumDegreeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDegreeTypeFilter<$PrismaModel> | $Enums.DegreeType
  }

  export type NestedEnumCertificateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeFilter<$PrismaModel> | $Enums.CertificateType
  }

  export type NestedEnumGradeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeFilter<$PrismaModel> | $Enums.GradeType
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type NestedEnumDegreeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DegreeType | EnumDegreeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DegreeType[] | ListEnumDegreeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DegreeType[] | ListEnumDegreeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDegreeTypeWithAggregatesFilter<$PrismaModel> | $Enums.DegreeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDegreeTypeFilter<$PrismaModel>
    _max?: NestedEnumDegreeTypeFilter<$PrismaModel>
  }

  export type NestedEnumCertificateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeWithAggregatesFilter<$PrismaModel> | $Enums.CertificateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificateTypeFilter<$PrismaModel>
    _max?: NestedEnumCertificateTypeFilter<$PrismaModel>
  }

  export type NestedEnumGradeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeWithAggregatesFilter<$PrismaModel> | $Enums.GradeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGradeTypeFilter<$PrismaModel>
    _max?: NestedEnumGradeTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type NestedEnumProfileStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileStatus | EnumProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileStatusFilter<$PrismaModel> | $Enums.ProfileStatus
  }

  export type NestedEnumProfileStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileStatus | EnumProfileStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileStatus[] | ListEnumProfileStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProfileStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileStatusFilter<$PrismaModel>
    _max?: NestedEnumProfileStatusFilter<$PrismaModel>
  }

  export type NestedEnumSocialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialType | EnumSocialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialType[] | ListEnumSocialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialType[] | ListEnumSocialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialTypeFilter<$PrismaModel> | $Enums.SocialType
  }

  export type NestedEnumSocialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialType | EnumSocialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SocialType[] | ListEnumSocialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialType[] | ListEnumSocialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialTypeWithAggregatesFilter<$PrismaModel> | $Enums.SocialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialTypeFilter<$PrismaModel>
    _max?: NestedEnumSocialTypeFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumNewsTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NewsType | EnumNewsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NewsType[] | ListEnumNewsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NewsType[] | ListEnumNewsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNewsTypeFilter<$PrismaModel> | $Enums.NewsType
  }

  export type NestedEnumNewsTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NewsType | EnumNewsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NewsType[] | ListEnumNewsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NewsType[] | ListEnumNewsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNewsTypeWithAggregatesFilter<$PrismaModel> | $Enums.NewsType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNewsTypeFilter<$PrismaModel>
    _max?: NestedEnumNewsTypeFilter<$PrismaModel>
  }

  export type NestedEnumContactTitleFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTitle | EnumContactTitleFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTitle[] | ListEnumContactTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTitle[] | ListEnumContactTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTitleFilter<$PrismaModel> | $Enums.ContactTitle
  }

  export type NestedEnumContactTitleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTitle | EnumContactTitleFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTitle[] | ListEnumContactTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTitle[] | ListEnumContactTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTitleWithAggregatesFilter<$PrismaModel> | $Enums.ContactTitle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTitleFilter<$PrismaModel>
    _max?: NestedEnumContactTitleFilter<$PrismaModel>
  }

  export type TwoFactorConfirmationCreateWithoutAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorConfirmationUncheckedCreateWithoutAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorConfirmationCreateOrConnectWithoutAccountInput = {
    where: TwoFactorConfirmationWhereUniqueInput
    create: XOR<TwoFactorConfirmationCreateWithoutAccountInput, TwoFactorConfirmationUncheckedCreateWithoutAccountInput>
  }

  export type StudentCreateWithoutAccountInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutAccountInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutAccountInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAccountInput, StudentUncheckedCreateWithoutAccountInput>
  }

  export type TwoFactorConfirmationUpsertWithoutAccountInput = {
    update: XOR<TwoFactorConfirmationUpdateWithoutAccountInput, TwoFactorConfirmationUncheckedUpdateWithoutAccountInput>
    create: XOR<TwoFactorConfirmationCreateWithoutAccountInput, TwoFactorConfirmationUncheckedCreateWithoutAccountInput>
    where?: TwoFactorConfirmationWhereInput
  }

  export type TwoFactorConfirmationUpdateToOneWithWhereWithoutAccountInput = {
    where?: TwoFactorConfirmationWhereInput
    data: XOR<TwoFactorConfirmationUpdateWithoutAccountInput, TwoFactorConfirmationUncheckedUpdateWithoutAccountInput>
  }

  export type TwoFactorConfirmationUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorConfirmationUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpsertWithoutAccountInput = {
    update: XOR<StudentUpdateWithoutAccountInput, StudentUncheckedUpdateWithoutAccountInput>
    create: XOR<StudentCreateWithoutAccountInput, StudentUncheckedCreateWithoutAccountInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAccountInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAccountInput, StudentUncheckedUpdateWithoutAccountInput>
  }

  export type StudentUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type AccountCreateWithoutTwoFactorConfirmationInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    password: string
    name: string
    dob: Date | string
    gender: $Enums.Gender
    phoneNumber: string
    idCardNumber: string
    address: string
    image?: string | null
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutTwoFactorConfirmationInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    password: string
    name: string
    dob: Date | string
    gender: $Enums.Gender
    phoneNumber: string
    idCardNumber: string
    address: string
    image?: string | null
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutTwoFactorConfirmationInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTwoFactorConfirmationInput, AccountUncheckedCreateWithoutTwoFactorConfirmationInput>
  }

  export type AccountUpsertWithoutTwoFactorConfirmationInput = {
    update: XOR<AccountUpdateWithoutTwoFactorConfirmationInput, AccountUncheckedUpdateWithoutTwoFactorConfirmationInput>
    create: XOR<AccountCreateWithoutTwoFactorConfirmationInput, AccountUncheckedCreateWithoutTwoFactorConfirmationInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTwoFactorConfirmationInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTwoFactorConfirmationInput, AccountUncheckedUpdateWithoutTwoFactorConfirmationInput>
  }

  export type AccountUpdateWithoutTwoFactorConfirmationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    phoneNumber?: StringFieldUpdateOperationsInput | string
    idCardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutTwoFactorConfirmationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    phoneNumber?: StringFieldUpdateOperationsInput | string
    idCardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type StudentCreateWithoutSchoolInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutSchoolInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type StudentCreateManySchoolInputEnvelope = {
    data: StudentCreateManySchoolInput | StudentCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SchoolLocationCreateWithoutSchoolInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolLocationImageCreateNestedManyWithoutLocationInput
    contacts?: SchoolLocationContactCreateNestedManyWithoutLocationInput
    students?: StudentSchoolLocationCreateNestedManyWithoutLocationInput
  }

  export type SchoolLocationUncheckedCreateWithoutSchoolInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolLocationImageUncheckedCreateNestedManyWithoutLocationInput
    contacts?: SchoolLocationContactUncheckedCreateNestedManyWithoutLocationInput
    students?: StudentSchoolLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type SchoolLocationCreateOrConnectWithoutSchoolInput = {
    where: SchoolLocationWhereUniqueInput
    create: XOR<SchoolLocationCreateWithoutSchoolInput, SchoolLocationUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolLocationCreateManySchoolInputEnvelope = {
    data: SchoolLocationCreateManySchoolInput | SchoolLocationCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SchoolProgramCreateWithoutSchoolInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentSchoolProgramCreateNestedManyWithoutProgramInput
    images?: SchoolProgramImageCreateNestedManyWithoutProgramInput
  }

  export type SchoolProgramUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentSchoolProgramUncheckedCreateNestedManyWithoutProgramInput
    images?: SchoolProgramImageUncheckedCreateNestedManyWithoutProgramInput
  }

  export type SchoolProgramCreateOrConnectWithoutSchoolInput = {
    where: SchoolProgramWhereUniqueInput
    create: XOR<SchoolProgramCreateWithoutSchoolInput, SchoolProgramUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolProgramCreateManySchoolInputEnvelope = {
    data: SchoolProgramCreateManySchoolInput | SchoolProgramCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SchoolGalleryCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolGalleryImageCreateNestedManyWithoutGalleryInput
  }

  export type SchoolGalleryUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolGalleryImageUncheckedCreateNestedManyWithoutGalleryInput
  }

  export type SchoolGalleryCreateOrConnectWithoutSchoolInput = {
    where: SchoolGalleryWhereUniqueInput
    create: XOR<SchoolGalleryCreateWithoutSchoolInput, SchoolGalleryUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolGalleryCreateManySchoolInputEnvelope = {
    data: SchoolGalleryCreateManySchoolInput | SchoolGalleryCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type SchoolScholarshipCreateWithoutSchoolInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: StudentSchoolScholarshipCreateNestedManyWithoutScholarshipInput
    images?: SchoolScholarshipImageCreateNestedManyWithoutScholarshipInput
  }

  export type SchoolScholarshipUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutScholarshipInput
    images?: SchoolScholarshipImageUncheckedCreateNestedManyWithoutScholarshipInput
  }

  export type SchoolScholarshipCreateOrConnectWithoutSchoolInput = {
    where: SchoolScholarshipWhereUniqueInput
    create: XOR<SchoolScholarshipCreateWithoutSchoolInput, SchoolScholarshipUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolScholarshipCreateManySchoolInputEnvelope = {
    data: SchoolScholarshipCreateManySchoolInput | SchoolScholarshipCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type NewsCreateWithoutSchoolInput = {
    id?: string
    title: string
    content?: string | null
    type: $Enums.NewsType
    cover: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NewsNotificationCreateNestedManyWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutSchoolInput = {
    id?: string
    title: string
    content?: string | null
    type: $Enums.NewsType
    cover: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutNewsInput
  }

  export type NewsCreateOrConnectWithoutSchoolInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutSchoolInput, NewsUncheckedCreateWithoutSchoolInput>
  }

  export type NewsCreateManySchoolInputEnvelope = {
    data: NewsCreateManySchoolInput | NewsCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutSchoolInput = {
    id?: string
    name: string
    title: $Enums.ContactTitle
    phone: string
    email: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    title: $Enums.ContactTitle
    phone: string
    email: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutSchoolInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutSchoolInput, ContactUncheckedCreateWithoutSchoolInput>
  }

  export type ContactCreateManySchoolInputEnvelope = {
    data: ContactCreateManySchoolInput | ContactCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
    create: XOR<StudentCreateWithoutSchoolInput, StudentUncheckedCreateWithoutSchoolInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutSchoolInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutSchoolInput, StudentUncheckedUpdateWithoutSchoolInput>
  }

  export type StudentUpdateManyWithWhereWithoutSchoolInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutSchoolInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    studentCode?: StringNullableFilter<"Student"> | string | null
    degreeType?: EnumDegreeTypeFilter<"Student"> | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFilter<"Student"> | $Enums.CertificateType
    certificateImg?: StringFilter<"Student"> | string
    gradeType?: EnumGradeTypeFilter<"Student"> | $Enums.GradeType
    gradeScore?: FloatFilter<"Student"> | number
    cover?: StringNullableFilter<"Student"> | string | null
    additional?: StringNullableFilter<"Student"> | string | null
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    accountId?: StringFilter<"Student"> | string
    schoolId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type SchoolLocationUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SchoolLocationWhereUniqueInput
    update: XOR<SchoolLocationUpdateWithoutSchoolInput, SchoolLocationUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolLocationCreateWithoutSchoolInput, SchoolLocationUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolLocationUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SchoolLocationWhereUniqueInput
    data: XOR<SchoolLocationUpdateWithoutSchoolInput, SchoolLocationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolLocationUpdateManyWithWhereWithoutSchoolInput = {
    where: SchoolLocationScalarWhereInput
    data: XOR<SchoolLocationUpdateManyMutationInput, SchoolLocationUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SchoolLocationScalarWhereInput = {
    AND?: SchoolLocationScalarWhereInput | SchoolLocationScalarWhereInput[]
    OR?: SchoolLocationScalarWhereInput[]
    NOT?: SchoolLocationScalarWhereInput | SchoolLocationScalarWhereInput[]
    id?: StringFilter<"SchoolLocation"> | string
    cover?: StringNullableFilter<"SchoolLocation"> | string | null
    name?: StringFilter<"SchoolLocation"> | string
    address?: StringFilter<"SchoolLocation"> | string
    isMain?: BoolFilter<"SchoolLocation"> | boolean
    schoolId?: StringFilter<"SchoolLocation"> | string
    createdAt?: DateTimeFilter<"SchoolLocation"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolLocation"> | Date | string
  }

  export type SchoolProgramUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SchoolProgramWhereUniqueInput
    update: XOR<SchoolProgramUpdateWithoutSchoolInput, SchoolProgramUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolProgramCreateWithoutSchoolInput, SchoolProgramUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolProgramUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SchoolProgramWhereUniqueInput
    data: XOR<SchoolProgramUpdateWithoutSchoolInput, SchoolProgramUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolProgramUpdateManyWithWhereWithoutSchoolInput = {
    where: SchoolProgramScalarWhereInput
    data: XOR<SchoolProgramUpdateManyMutationInput, SchoolProgramUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SchoolProgramScalarWhereInput = {
    AND?: SchoolProgramScalarWhereInput | SchoolProgramScalarWhereInput[]
    OR?: SchoolProgramScalarWhereInput[]
    NOT?: SchoolProgramScalarWhereInput | SchoolProgramScalarWhereInput[]
    id?: StringFilter<"SchoolProgram"> | string
    name?: StringFilter<"SchoolProgram"> | string
    description?: StringFilter<"SchoolProgram"> | string
    cover?: StringNullableFilter<"SchoolProgram"> | string | null
    isPublished?: BoolFilter<"SchoolProgram"> | boolean
    schoolId?: StringFilter<"SchoolProgram"> | string
    createdAt?: DateTimeFilter<"SchoolProgram"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolProgram"> | Date | string
  }

  export type SchoolGalleryUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SchoolGalleryWhereUniqueInput
    update: XOR<SchoolGalleryUpdateWithoutSchoolInput, SchoolGalleryUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolGalleryCreateWithoutSchoolInput, SchoolGalleryUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolGalleryUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SchoolGalleryWhereUniqueInput
    data: XOR<SchoolGalleryUpdateWithoutSchoolInput, SchoolGalleryUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolGalleryUpdateManyWithWhereWithoutSchoolInput = {
    where: SchoolGalleryScalarWhereInput
    data: XOR<SchoolGalleryUpdateManyMutationInput, SchoolGalleryUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SchoolGalleryScalarWhereInput = {
    AND?: SchoolGalleryScalarWhereInput | SchoolGalleryScalarWhereInput[]
    OR?: SchoolGalleryScalarWhereInput[]
    NOT?: SchoolGalleryScalarWhereInput | SchoolGalleryScalarWhereInput[]
    id?: StringFilter<"SchoolGallery"> | string
    name?: StringFilter<"SchoolGallery"> | string
    description?: StringNullableFilter<"SchoolGallery"> | string | null
    schoolId?: StringFilter<"SchoolGallery"> | string
    createdAt?: DateTimeFilter<"SchoolGallery"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolGallery"> | Date | string
  }

  export type SchoolScholarshipUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SchoolScholarshipWhereUniqueInput
    update: XOR<SchoolScholarshipUpdateWithoutSchoolInput, SchoolScholarshipUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolScholarshipCreateWithoutSchoolInput, SchoolScholarshipUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolScholarshipUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SchoolScholarshipWhereUniqueInput
    data: XOR<SchoolScholarshipUpdateWithoutSchoolInput, SchoolScholarshipUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolScholarshipUpdateManyWithWhereWithoutSchoolInput = {
    where: SchoolScholarshipScalarWhereInput
    data: XOR<SchoolScholarshipUpdateManyMutationInput, SchoolScholarshipUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SchoolScholarshipScalarWhereInput = {
    AND?: SchoolScholarshipScalarWhereInput | SchoolScholarshipScalarWhereInput[]
    OR?: SchoolScholarshipScalarWhereInput[]
    NOT?: SchoolScholarshipScalarWhereInput | SchoolScholarshipScalarWhereInput[]
    id?: StringFilter<"SchoolScholarship"> | string
    name?: StringFilter<"SchoolScholarship"> | string
    description?: StringFilter<"SchoolScholarship"> | string
    cover?: StringNullableFilter<"SchoolScholarship"> | string | null
    isPublished?: BoolFilter<"SchoolScholarship"> | boolean
    schoolId?: StringFilter<"SchoolScholarship"> | string
    createdAt?: DateTimeFilter<"SchoolScholarship"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolScholarship"> | Date | string
  }

  export type NewsUpsertWithWhereUniqueWithoutSchoolInput = {
    where: NewsWhereUniqueInput
    update: XOR<NewsUpdateWithoutSchoolInput, NewsUncheckedUpdateWithoutSchoolInput>
    create: XOR<NewsCreateWithoutSchoolInput, NewsUncheckedCreateWithoutSchoolInput>
  }

  export type NewsUpdateWithWhereUniqueWithoutSchoolInput = {
    where: NewsWhereUniqueInput
    data: XOR<NewsUpdateWithoutSchoolInput, NewsUncheckedUpdateWithoutSchoolInput>
  }

  export type NewsUpdateManyWithWhereWithoutSchoolInput = {
    where: NewsScalarWhereInput
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyWithoutSchoolInput>
  }

  export type NewsScalarWhereInput = {
    AND?: NewsScalarWhereInput | NewsScalarWhereInput[]
    OR?: NewsScalarWhereInput[]
    NOT?: NewsScalarWhereInput | NewsScalarWhereInput[]
    id?: StringFilter<"News"> | string
    title?: StringFilter<"News"> | string
    content?: StringNullableFilter<"News"> | string | null
    type?: EnumNewsTypeFilter<"News"> | $Enums.NewsType
    cover?: StringFilter<"News"> | string
    isPublished?: BoolFilter<"News"> | boolean
    schoolId?: StringNullableFilter<"News"> | string | null
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutSchoolInput, ContactUncheckedUpdateWithoutSchoolInput>
    create: XOR<ContactCreateWithoutSchoolInput, ContactUncheckedCreateWithoutSchoolInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutSchoolInput, ContactUncheckedUpdateWithoutSchoolInput>
  }

  export type ContactUpdateManyWithWhereWithoutSchoolInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    title?: EnumContactTitleFilter<"Contact"> | $Enums.ContactTitle
    phone?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    message?: StringFilter<"Contact"> | string
    isRead?: BoolFilter<"Contact"> | boolean
    schoolId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type SchoolCreateWithoutScholarshipsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryCreateNestedManyWithoutSchoolInput
    news?: NewsCreateNestedManyWithoutSchoolInput
    contacts?: ContactCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutScholarshipsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationUncheckedCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramUncheckedCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryUncheckedCreateNestedManyWithoutSchoolInput
    news?: NewsUncheckedCreateNestedManyWithoutSchoolInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutScholarshipsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutScholarshipsInput, SchoolUncheckedCreateWithoutScholarshipsInput>
  }

  export type StudentSchoolScholarshipCreateWithoutScholarshipInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutScholarshipInput
  }

  export type StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolScholarshipCreateOrConnectWithoutScholarshipInput = {
    where: StudentSchoolScholarshipWhereUniqueInput
    create: XOR<StudentSchoolScholarshipCreateWithoutScholarshipInput, StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput>
  }

  export type StudentSchoolScholarshipCreateManyScholarshipInputEnvelope = {
    data: StudentSchoolScholarshipCreateManyScholarshipInput | StudentSchoolScholarshipCreateManyScholarshipInput[]
    skipDuplicates?: boolean
  }

  export type SchoolScholarshipImageCreateWithoutScholarshipInput = {
    id?: string
    url: string
  }

  export type SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput = {
    id?: string
    url: string
  }

  export type SchoolScholarshipImageCreateOrConnectWithoutScholarshipInput = {
    where: SchoolScholarshipImageWhereUniqueInput
    create: XOR<SchoolScholarshipImageCreateWithoutScholarshipInput, SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput>
  }

  export type SchoolScholarshipImageCreateManyScholarshipInputEnvelope = {
    data: SchoolScholarshipImageCreateManyScholarshipInput | SchoolScholarshipImageCreateManyScholarshipInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutScholarshipsInput = {
    update: XOR<SchoolUpdateWithoutScholarshipsInput, SchoolUncheckedUpdateWithoutScholarshipsInput>
    create: XOR<SchoolCreateWithoutScholarshipsInput, SchoolUncheckedCreateWithoutScholarshipsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutScholarshipsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutScholarshipsInput, SchoolUncheckedUpdateWithoutScholarshipsInput>
  }

  export type SchoolUpdateWithoutScholarshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUpdateManyWithoutSchoolNestedInput
    news?: NewsUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutScholarshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUncheckedUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUncheckedUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUncheckedUpdateManyWithoutSchoolNestedInput
    news?: NewsUncheckedUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type StudentSchoolScholarshipUpsertWithWhereUniqueWithoutScholarshipInput = {
    where: StudentSchoolScholarshipWhereUniqueInput
    update: XOR<StudentSchoolScholarshipUpdateWithoutScholarshipInput, StudentSchoolScholarshipUncheckedUpdateWithoutScholarshipInput>
    create: XOR<StudentSchoolScholarshipCreateWithoutScholarshipInput, StudentSchoolScholarshipUncheckedCreateWithoutScholarshipInput>
  }

  export type StudentSchoolScholarshipUpdateWithWhereUniqueWithoutScholarshipInput = {
    where: StudentSchoolScholarshipWhereUniqueInput
    data: XOR<StudentSchoolScholarshipUpdateWithoutScholarshipInput, StudentSchoolScholarshipUncheckedUpdateWithoutScholarshipInput>
  }

  export type StudentSchoolScholarshipUpdateManyWithWhereWithoutScholarshipInput = {
    where: StudentSchoolScholarshipScalarWhereInput
    data: XOR<StudentSchoolScholarshipUpdateManyMutationInput, StudentSchoolScholarshipUncheckedUpdateManyWithoutScholarshipInput>
  }

  export type StudentSchoolScholarshipScalarWhereInput = {
    AND?: StudentSchoolScholarshipScalarWhereInput | StudentSchoolScholarshipScalarWhereInput[]
    OR?: StudentSchoolScholarshipScalarWhereInput[]
    NOT?: StudentSchoolScholarshipScalarWhereInput | StudentSchoolScholarshipScalarWhereInput[]
    id?: StringFilter<"StudentSchoolScholarship"> | string
    studentId?: StringFilter<"StudentSchoolScholarship"> | string
    scholarshipId?: StringFilter<"StudentSchoolScholarship"> | string
    createdAt?: DateTimeFilter<"StudentSchoolScholarship"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSchoolScholarship"> | Date | string
  }

  export type SchoolScholarshipImageUpsertWithWhereUniqueWithoutScholarshipInput = {
    where: SchoolScholarshipImageWhereUniqueInput
    update: XOR<SchoolScholarshipImageUpdateWithoutScholarshipInput, SchoolScholarshipImageUncheckedUpdateWithoutScholarshipInput>
    create: XOR<SchoolScholarshipImageCreateWithoutScholarshipInput, SchoolScholarshipImageUncheckedCreateWithoutScholarshipInput>
  }

  export type SchoolScholarshipImageUpdateWithWhereUniqueWithoutScholarshipInput = {
    where: SchoolScholarshipImageWhereUniqueInput
    data: XOR<SchoolScholarshipImageUpdateWithoutScholarshipInput, SchoolScholarshipImageUncheckedUpdateWithoutScholarshipInput>
  }

  export type SchoolScholarshipImageUpdateManyWithWhereWithoutScholarshipInput = {
    where: SchoolScholarshipImageScalarWhereInput
    data: XOR<SchoolScholarshipImageUpdateManyMutationInput, SchoolScholarshipImageUncheckedUpdateManyWithoutScholarshipInput>
  }

  export type SchoolScholarshipImageScalarWhereInput = {
    AND?: SchoolScholarshipImageScalarWhereInput | SchoolScholarshipImageScalarWhereInput[]
    OR?: SchoolScholarshipImageScalarWhereInput[]
    NOT?: SchoolScholarshipImageScalarWhereInput | SchoolScholarshipImageScalarWhereInput[]
    id?: StringFilter<"SchoolScholarshipImage"> | string
    url?: StringFilter<"SchoolScholarshipImage"> | string
    scholarshipId?: StringFilter<"SchoolScholarshipImage"> | string
  }

  export type SchoolScholarshipCreateWithoutImagesInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutScholarshipsInput
    owners?: StudentSchoolScholarshipCreateNestedManyWithoutScholarshipInput
  }

  export type SchoolScholarshipUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutScholarshipInput
  }

  export type SchoolScholarshipCreateOrConnectWithoutImagesInput = {
    where: SchoolScholarshipWhereUniqueInput
    create: XOR<SchoolScholarshipCreateWithoutImagesInput, SchoolScholarshipUncheckedCreateWithoutImagesInput>
  }

  export type SchoolScholarshipUpsertWithoutImagesInput = {
    update: XOR<SchoolScholarshipUpdateWithoutImagesInput, SchoolScholarshipUncheckedUpdateWithoutImagesInput>
    create: XOR<SchoolScholarshipCreateWithoutImagesInput, SchoolScholarshipUncheckedCreateWithoutImagesInput>
    where?: SchoolScholarshipWhereInput
  }

  export type SchoolScholarshipUpdateToOneWithWhereWithoutImagesInput = {
    where?: SchoolScholarshipWhereInput
    data: XOR<SchoolScholarshipUpdateWithoutImagesInput, SchoolScholarshipUncheckedUpdateWithoutImagesInput>
  }

  export type SchoolScholarshipUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutScholarshipsNestedInput
    owners?: StudentSchoolScholarshipUpdateManyWithoutScholarshipNestedInput
  }

  export type SchoolScholarshipUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: StudentSchoolScholarshipUncheckedUpdateManyWithoutScholarshipNestedInput
  }

  export type StudentCreateWithoutScholarshipInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutScholarshipInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutScholarshipInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutScholarshipInput, StudentUncheckedCreateWithoutScholarshipInput>
  }

  export type SchoolScholarshipCreateWithoutOwnersInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutScholarshipsInput
    images?: SchoolScholarshipImageCreateNestedManyWithoutScholarshipInput
  }

  export type SchoolScholarshipUncheckedCreateWithoutOwnersInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolScholarshipImageUncheckedCreateNestedManyWithoutScholarshipInput
  }

  export type SchoolScholarshipCreateOrConnectWithoutOwnersInput = {
    where: SchoolScholarshipWhereUniqueInput
    create: XOR<SchoolScholarshipCreateWithoutOwnersInput, SchoolScholarshipUncheckedCreateWithoutOwnersInput>
  }

  export type StudentUpsertWithoutScholarshipInput = {
    update: XOR<StudentUpdateWithoutScholarshipInput, StudentUncheckedUpdateWithoutScholarshipInput>
    create: XOR<StudentCreateWithoutScholarshipInput, StudentUncheckedCreateWithoutScholarshipInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutScholarshipInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutScholarshipInput, StudentUncheckedUpdateWithoutScholarshipInput>
  }

  export type StudentUpdateWithoutScholarshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutScholarshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type SchoolScholarshipUpsertWithoutOwnersInput = {
    update: XOR<SchoolScholarshipUpdateWithoutOwnersInput, SchoolScholarshipUncheckedUpdateWithoutOwnersInput>
    create: XOR<SchoolScholarshipCreateWithoutOwnersInput, SchoolScholarshipUncheckedCreateWithoutOwnersInput>
    where?: SchoolScholarshipWhereInput
  }

  export type SchoolScholarshipUpdateToOneWithWhereWithoutOwnersInput = {
    where?: SchoolScholarshipWhereInput
    data: XOR<SchoolScholarshipUpdateWithoutOwnersInput, SchoolScholarshipUncheckedUpdateWithoutOwnersInput>
  }

  export type SchoolScholarshipUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutScholarshipsNestedInput
    images?: SchoolScholarshipImageUpdateManyWithoutScholarshipNestedInput
  }

  export type SchoolScholarshipUncheckedUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolScholarshipImageUncheckedUpdateManyWithoutScholarshipNestedInput
  }

  export type SchoolGalleryImageCreateWithoutGalleryInput = {
    id?: string
    url: string
  }

  export type SchoolGalleryImageUncheckedCreateWithoutGalleryInput = {
    id?: string
    url: string
  }

  export type SchoolGalleryImageCreateOrConnectWithoutGalleryInput = {
    where: SchoolGalleryImageWhereUniqueInput
    create: XOR<SchoolGalleryImageCreateWithoutGalleryInput, SchoolGalleryImageUncheckedCreateWithoutGalleryInput>
  }

  export type SchoolGalleryImageCreateManyGalleryInputEnvelope = {
    data: SchoolGalleryImageCreateManyGalleryInput | SchoolGalleryImageCreateManyGalleryInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutGalleriesInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipCreateNestedManyWithoutSchoolInput
    news?: NewsCreateNestedManyWithoutSchoolInput
    contacts?: ContactCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutGalleriesInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationUncheckedCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramUncheckedCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipUncheckedCreateNestedManyWithoutSchoolInput
    news?: NewsUncheckedCreateNestedManyWithoutSchoolInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutGalleriesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutGalleriesInput, SchoolUncheckedCreateWithoutGalleriesInput>
  }

  export type SchoolGalleryImageUpsertWithWhereUniqueWithoutGalleryInput = {
    where: SchoolGalleryImageWhereUniqueInput
    update: XOR<SchoolGalleryImageUpdateWithoutGalleryInput, SchoolGalleryImageUncheckedUpdateWithoutGalleryInput>
    create: XOR<SchoolGalleryImageCreateWithoutGalleryInput, SchoolGalleryImageUncheckedCreateWithoutGalleryInput>
  }

  export type SchoolGalleryImageUpdateWithWhereUniqueWithoutGalleryInput = {
    where: SchoolGalleryImageWhereUniqueInput
    data: XOR<SchoolGalleryImageUpdateWithoutGalleryInput, SchoolGalleryImageUncheckedUpdateWithoutGalleryInput>
  }

  export type SchoolGalleryImageUpdateManyWithWhereWithoutGalleryInput = {
    where: SchoolGalleryImageScalarWhereInput
    data: XOR<SchoolGalleryImageUpdateManyMutationInput, SchoolGalleryImageUncheckedUpdateManyWithoutGalleryInput>
  }

  export type SchoolGalleryImageScalarWhereInput = {
    AND?: SchoolGalleryImageScalarWhereInput | SchoolGalleryImageScalarWhereInput[]
    OR?: SchoolGalleryImageScalarWhereInput[]
    NOT?: SchoolGalleryImageScalarWhereInput | SchoolGalleryImageScalarWhereInput[]
    id?: StringFilter<"SchoolGalleryImage"> | string
    url?: StringFilter<"SchoolGalleryImage"> | string
    galleryId?: StringFilter<"SchoolGalleryImage"> | string
  }

  export type SchoolUpsertWithoutGalleriesInput = {
    update: XOR<SchoolUpdateWithoutGalleriesInput, SchoolUncheckedUpdateWithoutGalleriesInput>
    create: XOR<SchoolCreateWithoutGalleriesInput, SchoolUncheckedCreateWithoutGalleriesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutGalleriesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutGalleriesInput, SchoolUncheckedUpdateWithoutGalleriesInput>
  }

  export type SchoolUpdateWithoutGalleriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUpdateManyWithoutSchoolNestedInput
    news?: NewsUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutGalleriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUncheckedUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUncheckedUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUncheckedUpdateManyWithoutSchoolNestedInput
    news?: NewsUncheckedUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolGalleryCreateWithoutImagesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutGalleriesInput
  }

  export type SchoolGalleryUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    description?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolGalleryCreateOrConnectWithoutImagesInput = {
    where: SchoolGalleryWhereUniqueInput
    create: XOR<SchoolGalleryCreateWithoutImagesInput, SchoolGalleryUncheckedCreateWithoutImagesInput>
  }

  export type SchoolGalleryUpsertWithoutImagesInput = {
    update: XOR<SchoolGalleryUpdateWithoutImagesInput, SchoolGalleryUncheckedUpdateWithoutImagesInput>
    create: XOR<SchoolGalleryCreateWithoutImagesInput, SchoolGalleryUncheckedCreateWithoutImagesInput>
    where?: SchoolGalleryWhereInput
  }

  export type SchoolGalleryUpdateToOneWithWhereWithoutImagesInput = {
    where?: SchoolGalleryWhereInput
    data: XOR<SchoolGalleryUpdateWithoutImagesInput, SchoolGalleryUncheckedUpdateWithoutImagesInput>
  }

  export type SchoolGalleryUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutGalleriesNestedInput
  }

  export type SchoolGalleryUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLocationImageCreateWithoutLocationInput = {
    id?: string
    url: string
  }

  export type SchoolLocationImageUncheckedCreateWithoutLocationInput = {
    id?: string
    url: string
  }

  export type SchoolLocationImageCreateOrConnectWithoutLocationInput = {
    where: SchoolLocationImageWhereUniqueInput
    create: XOR<SchoolLocationImageCreateWithoutLocationInput, SchoolLocationImageUncheckedCreateWithoutLocationInput>
  }

  export type SchoolLocationImageCreateManyLocationInputEnvelope = {
    data: SchoolLocationImageCreateManyLocationInput | SchoolLocationImageCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type SchoolLocationContactCreateWithoutLocationInput = {
    id?: string
    phone?: string | null
    hours?: string | null
    fax?: string | null
    email?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolLocationContactUncheckedCreateWithoutLocationInput = {
    id?: string
    phone?: string | null
    hours?: string | null
    fax?: string | null
    email?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolLocationContactCreateOrConnectWithoutLocationInput = {
    where: SchoolLocationContactWhereUniqueInput
    create: XOR<SchoolLocationContactCreateWithoutLocationInput, SchoolLocationContactUncheckedCreateWithoutLocationInput>
  }

  export type SchoolLocationContactCreateManyLocationInputEnvelope = {
    data: SchoolLocationContactCreateManyLocationInput | SchoolLocationContactCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type StudentSchoolLocationCreateWithoutLocationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutLocationInput
  }

  export type StudentSchoolLocationUncheckedCreateWithoutLocationInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolLocationCreateOrConnectWithoutLocationInput = {
    where: StudentSchoolLocationWhereUniqueInput
    create: XOR<StudentSchoolLocationCreateWithoutLocationInput, StudentSchoolLocationUncheckedCreateWithoutLocationInput>
  }

  export type StudentSchoolLocationCreateManyLocationInputEnvelope = {
    data: StudentSchoolLocationCreateManyLocationInput | StudentSchoolLocationCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutLocationsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipCreateNestedManyWithoutSchoolInput
    news?: NewsCreateNestedManyWithoutSchoolInput
    contacts?: ContactCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutLocationsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramUncheckedCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryUncheckedCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipUncheckedCreateNestedManyWithoutSchoolInput
    news?: NewsUncheckedCreateNestedManyWithoutSchoolInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutLocationsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutLocationsInput, SchoolUncheckedCreateWithoutLocationsInput>
  }

  export type SchoolLocationImageUpsertWithWhereUniqueWithoutLocationInput = {
    where: SchoolLocationImageWhereUniqueInput
    update: XOR<SchoolLocationImageUpdateWithoutLocationInput, SchoolLocationImageUncheckedUpdateWithoutLocationInput>
    create: XOR<SchoolLocationImageCreateWithoutLocationInput, SchoolLocationImageUncheckedCreateWithoutLocationInput>
  }

  export type SchoolLocationImageUpdateWithWhereUniqueWithoutLocationInput = {
    where: SchoolLocationImageWhereUniqueInput
    data: XOR<SchoolLocationImageUpdateWithoutLocationInput, SchoolLocationImageUncheckedUpdateWithoutLocationInput>
  }

  export type SchoolLocationImageUpdateManyWithWhereWithoutLocationInput = {
    where: SchoolLocationImageScalarWhereInput
    data: XOR<SchoolLocationImageUpdateManyMutationInput, SchoolLocationImageUncheckedUpdateManyWithoutLocationInput>
  }

  export type SchoolLocationImageScalarWhereInput = {
    AND?: SchoolLocationImageScalarWhereInput | SchoolLocationImageScalarWhereInput[]
    OR?: SchoolLocationImageScalarWhereInput[]
    NOT?: SchoolLocationImageScalarWhereInput | SchoolLocationImageScalarWhereInput[]
    id?: StringFilter<"SchoolLocationImage"> | string
    url?: StringFilter<"SchoolLocationImage"> | string
    locationId?: StringFilter<"SchoolLocationImage"> | string
  }

  export type SchoolLocationContactUpsertWithWhereUniqueWithoutLocationInput = {
    where: SchoolLocationContactWhereUniqueInput
    update: XOR<SchoolLocationContactUpdateWithoutLocationInput, SchoolLocationContactUncheckedUpdateWithoutLocationInput>
    create: XOR<SchoolLocationContactCreateWithoutLocationInput, SchoolLocationContactUncheckedCreateWithoutLocationInput>
  }

  export type SchoolLocationContactUpdateWithWhereUniqueWithoutLocationInput = {
    where: SchoolLocationContactWhereUniqueInput
    data: XOR<SchoolLocationContactUpdateWithoutLocationInput, SchoolLocationContactUncheckedUpdateWithoutLocationInput>
  }

  export type SchoolLocationContactUpdateManyWithWhereWithoutLocationInput = {
    where: SchoolLocationContactScalarWhereInput
    data: XOR<SchoolLocationContactUpdateManyMutationInput, SchoolLocationContactUncheckedUpdateManyWithoutLocationInput>
  }

  export type SchoolLocationContactScalarWhereInput = {
    AND?: SchoolLocationContactScalarWhereInput | SchoolLocationContactScalarWhereInput[]
    OR?: SchoolLocationContactScalarWhereInput[]
    NOT?: SchoolLocationContactScalarWhereInput | SchoolLocationContactScalarWhereInput[]
    id?: StringFilter<"SchoolLocationContact"> | string
    phone?: StringNullableFilter<"SchoolLocationContact"> | string | null
    hours?: StringNullableFilter<"SchoolLocationContact"> | string | null
    fax?: StringNullableFilter<"SchoolLocationContact"> | string | null
    email?: StringNullableFilter<"SchoolLocationContact"> | string | null
    url?: StringNullableFilter<"SchoolLocationContact"> | string | null
    locationId?: StringFilter<"SchoolLocationContact"> | string
    createdAt?: DateTimeFilter<"SchoolLocationContact"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolLocationContact"> | Date | string
  }

  export type StudentSchoolLocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: StudentSchoolLocationWhereUniqueInput
    update: XOR<StudentSchoolLocationUpdateWithoutLocationInput, StudentSchoolLocationUncheckedUpdateWithoutLocationInput>
    create: XOR<StudentSchoolLocationCreateWithoutLocationInput, StudentSchoolLocationUncheckedCreateWithoutLocationInput>
  }

  export type StudentSchoolLocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: StudentSchoolLocationWhereUniqueInput
    data: XOR<StudentSchoolLocationUpdateWithoutLocationInput, StudentSchoolLocationUncheckedUpdateWithoutLocationInput>
  }

  export type StudentSchoolLocationUpdateManyWithWhereWithoutLocationInput = {
    where: StudentSchoolLocationScalarWhereInput
    data: XOR<StudentSchoolLocationUpdateManyMutationInput, StudentSchoolLocationUncheckedUpdateManyWithoutLocationInput>
  }

  export type StudentSchoolLocationScalarWhereInput = {
    AND?: StudentSchoolLocationScalarWhereInput | StudentSchoolLocationScalarWhereInput[]
    OR?: StudentSchoolLocationScalarWhereInput[]
    NOT?: StudentSchoolLocationScalarWhereInput | StudentSchoolLocationScalarWhereInput[]
    id?: StringFilter<"StudentSchoolLocation"> | string
    studentId?: StringFilter<"StudentSchoolLocation"> | string
    locationId?: StringFilter<"StudentSchoolLocation"> | string
    createdAt?: DateTimeFilter<"StudentSchoolLocation"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSchoolLocation"> | Date | string
  }

  export type SchoolUpsertWithoutLocationsInput = {
    update: XOR<SchoolUpdateWithoutLocationsInput, SchoolUncheckedUpdateWithoutLocationsInput>
    create: XOR<SchoolCreateWithoutLocationsInput, SchoolUncheckedCreateWithoutLocationsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutLocationsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutLocationsInput, SchoolUncheckedUpdateWithoutLocationsInput>
  }

  export type SchoolUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUpdateManyWithoutSchoolNestedInput
    news?: NewsUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUncheckedUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUncheckedUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUncheckedUpdateManyWithoutSchoolNestedInput
    news?: NewsUncheckedUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolLocationCreateWithoutImagesInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: SchoolLocationContactCreateNestedManyWithoutLocationInput
    students?: StudentSchoolLocationCreateNestedManyWithoutLocationInput
    school: SchoolCreateNestedOneWithoutLocationsInput
  }

  export type SchoolLocationUncheckedCreateWithoutImagesInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: SchoolLocationContactUncheckedCreateNestedManyWithoutLocationInput
    students?: StudentSchoolLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type SchoolLocationCreateOrConnectWithoutImagesInput = {
    where: SchoolLocationWhereUniqueInput
    create: XOR<SchoolLocationCreateWithoutImagesInput, SchoolLocationUncheckedCreateWithoutImagesInput>
  }

  export type SchoolLocationUpsertWithoutImagesInput = {
    update: XOR<SchoolLocationUpdateWithoutImagesInput, SchoolLocationUncheckedUpdateWithoutImagesInput>
    create: XOR<SchoolLocationCreateWithoutImagesInput, SchoolLocationUncheckedCreateWithoutImagesInput>
    where?: SchoolLocationWhereInput
  }

  export type SchoolLocationUpdateToOneWithWhereWithoutImagesInput = {
    where?: SchoolLocationWhereInput
    data: XOR<SchoolLocationUpdateWithoutImagesInput, SchoolLocationUncheckedUpdateWithoutImagesInput>
  }

  export type SchoolLocationUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: SchoolLocationContactUpdateManyWithoutLocationNestedInput
    students?: StudentSchoolLocationUpdateManyWithoutLocationNestedInput
    school?: SchoolUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type SchoolLocationUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: SchoolLocationContactUncheckedUpdateManyWithoutLocationNestedInput
    students?: StudentSchoolLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type SchoolLocationCreateWithoutContactsInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolLocationImageCreateNestedManyWithoutLocationInput
    students?: StudentSchoolLocationCreateNestedManyWithoutLocationInput
    school: SchoolCreateNestedOneWithoutLocationsInput
  }

  export type SchoolLocationUncheckedCreateWithoutContactsInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolLocationImageUncheckedCreateNestedManyWithoutLocationInput
    students?: StudentSchoolLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type SchoolLocationCreateOrConnectWithoutContactsInput = {
    where: SchoolLocationWhereUniqueInput
    create: XOR<SchoolLocationCreateWithoutContactsInput, SchoolLocationUncheckedCreateWithoutContactsInput>
  }

  export type SchoolLocationUpsertWithoutContactsInput = {
    update: XOR<SchoolLocationUpdateWithoutContactsInput, SchoolLocationUncheckedUpdateWithoutContactsInput>
    create: XOR<SchoolLocationCreateWithoutContactsInput, SchoolLocationUncheckedCreateWithoutContactsInput>
    where?: SchoolLocationWhereInput
  }

  export type SchoolLocationUpdateToOneWithWhereWithoutContactsInput = {
    where?: SchoolLocationWhereInput
    data: XOR<SchoolLocationUpdateWithoutContactsInput, SchoolLocationUncheckedUpdateWithoutContactsInput>
  }

  export type SchoolLocationUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolLocationImageUpdateManyWithoutLocationNestedInput
    students?: StudentSchoolLocationUpdateManyWithoutLocationNestedInput
    school?: SchoolUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type SchoolLocationUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolLocationImageUncheckedUpdateManyWithoutLocationNestedInput
    students?: StudentSchoolLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type SchoolCreateWithoutProgramsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipCreateNestedManyWithoutSchoolInput
    news?: NewsCreateNestedManyWithoutSchoolInput
    contacts?: ContactCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutProgramsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationUncheckedCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryUncheckedCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipUncheckedCreateNestedManyWithoutSchoolInput
    news?: NewsUncheckedCreateNestedManyWithoutSchoolInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutProgramsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutProgramsInput, SchoolUncheckedCreateWithoutProgramsInput>
  }

  export type StudentSchoolProgramCreateWithoutProgramInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProgramInput
  }

  export type StudentSchoolProgramUncheckedCreateWithoutProgramInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolProgramCreateOrConnectWithoutProgramInput = {
    where: StudentSchoolProgramWhereUniqueInput
    create: XOR<StudentSchoolProgramCreateWithoutProgramInput, StudentSchoolProgramUncheckedCreateWithoutProgramInput>
  }

  export type StudentSchoolProgramCreateManyProgramInputEnvelope = {
    data: StudentSchoolProgramCreateManyProgramInput | StudentSchoolProgramCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type SchoolProgramImageCreateWithoutProgramInput = {
    id?: string
    url: string
  }

  export type SchoolProgramImageUncheckedCreateWithoutProgramInput = {
    id?: string
    url: string
  }

  export type SchoolProgramImageCreateOrConnectWithoutProgramInput = {
    where: SchoolProgramImageWhereUniqueInput
    create: XOR<SchoolProgramImageCreateWithoutProgramInput, SchoolProgramImageUncheckedCreateWithoutProgramInput>
  }

  export type SchoolProgramImageCreateManyProgramInputEnvelope = {
    data: SchoolProgramImageCreateManyProgramInput | SchoolProgramImageCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutProgramsInput = {
    update: XOR<SchoolUpdateWithoutProgramsInput, SchoolUncheckedUpdateWithoutProgramsInput>
    create: XOR<SchoolCreateWithoutProgramsInput, SchoolUncheckedCreateWithoutProgramsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutProgramsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutProgramsInput, SchoolUncheckedUpdateWithoutProgramsInput>
  }

  export type SchoolUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUpdateManyWithoutSchoolNestedInput
    news?: NewsUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUncheckedUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUncheckedUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUncheckedUpdateManyWithoutSchoolNestedInput
    news?: NewsUncheckedUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type StudentSchoolProgramUpsertWithWhereUniqueWithoutProgramInput = {
    where: StudentSchoolProgramWhereUniqueInput
    update: XOR<StudentSchoolProgramUpdateWithoutProgramInput, StudentSchoolProgramUncheckedUpdateWithoutProgramInput>
    create: XOR<StudentSchoolProgramCreateWithoutProgramInput, StudentSchoolProgramUncheckedCreateWithoutProgramInput>
  }

  export type StudentSchoolProgramUpdateWithWhereUniqueWithoutProgramInput = {
    where: StudentSchoolProgramWhereUniqueInput
    data: XOR<StudentSchoolProgramUpdateWithoutProgramInput, StudentSchoolProgramUncheckedUpdateWithoutProgramInput>
  }

  export type StudentSchoolProgramUpdateManyWithWhereWithoutProgramInput = {
    where: StudentSchoolProgramScalarWhereInput
    data: XOR<StudentSchoolProgramUpdateManyMutationInput, StudentSchoolProgramUncheckedUpdateManyWithoutProgramInput>
  }

  export type StudentSchoolProgramScalarWhereInput = {
    AND?: StudentSchoolProgramScalarWhereInput | StudentSchoolProgramScalarWhereInput[]
    OR?: StudentSchoolProgramScalarWhereInput[]
    NOT?: StudentSchoolProgramScalarWhereInput | StudentSchoolProgramScalarWhereInput[]
    id?: StringFilter<"StudentSchoolProgram"> | string
    studentId?: StringFilter<"StudentSchoolProgram"> | string
    programId?: StringFilter<"StudentSchoolProgram"> | string
    createdAt?: DateTimeFilter<"StudentSchoolProgram"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSchoolProgram"> | Date | string
  }

  export type SchoolProgramImageUpsertWithWhereUniqueWithoutProgramInput = {
    where: SchoolProgramImageWhereUniqueInput
    update: XOR<SchoolProgramImageUpdateWithoutProgramInput, SchoolProgramImageUncheckedUpdateWithoutProgramInput>
    create: XOR<SchoolProgramImageCreateWithoutProgramInput, SchoolProgramImageUncheckedCreateWithoutProgramInput>
  }

  export type SchoolProgramImageUpdateWithWhereUniqueWithoutProgramInput = {
    where: SchoolProgramImageWhereUniqueInput
    data: XOR<SchoolProgramImageUpdateWithoutProgramInput, SchoolProgramImageUncheckedUpdateWithoutProgramInput>
  }

  export type SchoolProgramImageUpdateManyWithWhereWithoutProgramInput = {
    where: SchoolProgramImageScalarWhereInput
    data: XOR<SchoolProgramImageUpdateManyMutationInput, SchoolProgramImageUncheckedUpdateManyWithoutProgramInput>
  }

  export type SchoolProgramImageScalarWhereInput = {
    AND?: SchoolProgramImageScalarWhereInput | SchoolProgramImageScalarWhereInput[]
    OR?: SchoolProgramImageScalarWhereInput[]
    NOT?: SchoolProgramImageScalarWhereInput | SchoolProgramImageScalarWhereInput[]
    id?: StringFilter<"SchoolProgramImage"> | string
    url?: StringFilter<"SchoolProgramImage"> | string
    programId?: StringFilter<"SchoolProgramImage"> | string
  }

  export type SchoolProgramCreateWithoutImagesInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutProgramsInput
    studentPrograms?: StudentSchoolProgramCreateNestedManyWithoutProgramInput
  }

  export type SchoolProgramUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentPrograms?: StudentSchoolProgramUncheckedCreateNestedManyWithoutProgramInput
  }

  export type SchoolProgramCreateOrConnectWithoutImagesInput = {
    where: SchoolProgramWhereUniqueInput
    create: XOR<SchoolProgramCreateWithoutImagesInput, SchoolProgramUncheckedCreateWithoutImagesInput>
  }

  export type SchoolProgramUpsertWithoutImagesInput = {
    update: XOR<SchoolProgramUpdateWithoutImagesInput, SchoolProgramUncheckedUpdateWithoutImagesInput>
    create: XOR<SchoolProgramCreateWithoutImagesInput, SchoolProgramUncheckedCreateWithoutImagesInput>
    where?: SchoolProgramWhereInput
  }

  export type SchoolProgramUpdateToOneWithWhereWithoutImagesInput = {
    where?: SchoolProgramWhereInput
    data: XOR<SchoolProgramUpdateWithoutImagesInput, SchoolProgramUncheckedUpdateWithoutImagesInput>
  }

  export type SchoolProgramUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutProgramsNestedInput
    studentPrograms?: StudentSchoolProgramUpdateManyWithoutProgramNestedInput
  }

  export type SchoolProgramUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentSchoolProgramUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type StudentCreateWithoutProgramInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutProgramInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutProgramInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput>
  }

  export type SchoolProgramCreateWithoutStudentProgramsInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutProgramsInput
    images?: SchoolProgramImageCreateNestedManyWithoutProgramInput
  }

  export type SchoolProgramUncheckedCreateWithoutStudentProgramsInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolProgramImageUncheckedCreateNestedManyWithoutProgramInput
  }

  export type SchoolProgramCreateOrConnectWithoutStudentProgramsInput = {
    where: SchoolProgramWhereUniqueInput
    create: XOR<SchoolProgramCreateWithoutStudentProgramsInput, SchoolProgramUncheckedCreateWithoutStudentProgramsInput>
  }

  export type StudentUpsertWithoutProgramInput = {
    update: XOR<StudentUpdateWithoutProgramInput, StudentUncheckedUpdateWithoutProgramInput>
    create: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutProgramInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutProgramInput, StudentUncheckedUpdateWithoutProgramInput>
  }

  export type StudentUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type SchoolProgramUpsertWithoutStudentProgramsInput = {
    update: XOR<SchoolProgramUpdateWithoutStudentProgramsInput, SchoolProgramUncheckedUpdateWithoutStudentProgramsInput>
    create: XOR<SchoolProgramCreateWithoutStudentProgramsInput, SchoolProgramUncheckedCreateWithoutStudentProgramsInput>
    where?: SchoolProgramWhereInput
  }

  export type SchoolProgramUpdateToOneWithWhereWithoutStudentProgramsInput = {
    where?: SchoolProgramWhereInput
    data: XOR<SchoolProgramUpdateWithoutStudentProgramsInput, SchoolProgramUncheckedUpdateWithoutStudentProgramsInput>
  }

  export type SchoolProgramUpdateWithoutStudentProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutProgramsNestedInput
    images?: SchoolProgramImageUpdateManyWithoutProgramNestedInput
  }

  export type SchoolProgramUncheckedUpdateWithoutStudentProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolProgramImageUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type StudentCreateWithoutLocationInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutLocationInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutLocationInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutLocationInput, StudentUncheckedCreateWithoutLocationInput>
  }

  export type SchoolLocationCreateWithoutStudentsInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolLocationImageCreateNestedManyWithoutLocationInput
    contacts?: SchoolLocationContactCreateNestedManyWithoutLocationInput
    school: SchoolCreateNestedOneWithoutLocationsInput
  }

  export type SchoolLocationUncheckedCreateWithoutStudentsInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: SchoolLocationImageUncheckedCreateNestedManyWithoutLocationInput
    contacts?: SchoolLocationContactUncheckedCreateNestedManyWithoutLocationInput
  }

  export type SchoolLocationCreateOrConnectWithoutStudentsInput = {
    where: SchoolLocationWhereUniqueInput
    create: XOR<SchoolLocationCreateWithoutStudentsInput, SchoolLocationUncheckedCreateWithoutStudentsInput>
  }

  export type StudentUpsertWithoutLocationInput = {
    update: XOR<StudentUpdateWithoutLocationInput, StudentUncheckedUpdateWithoutLocationInput>
    create: XOR<StudentCreateWithoutLocationInput, StudentUncheckedCreateWithoutLocationInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutLocationInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutLocationInput, StudentUncheckedUpdateWithoutLocationInput>
  }

  export type StudentUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type SchoolLocationUpsertWithoutStudentsInput = {
    update: XOR<SchoolLocationUpdateWithoutStudentsInput, SchoolLocationUncheckedUpdateWithoutStudentsInput>
    create: XOR<SchoolLocationCreateWithoutStudentsInput, SchoolLocationUncheckedCreateWithoutStudentsInput>
    where?: SchoolLocationWhereInput
  }

  export type SchoolLocationUpdateToOneWithWhereWithoutStudentsInput = {
    where?: SchoolLocationWhereInput
    data: XOR<SchoolLocationUpdateWithoutStudentsInput, SchoolLocationUncheckedUpdateWithoutStudentsInput>
  }

  export type SchoolLocationUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolLocationImageUpdateManyWithoutLocationNestedInput
    contacts?: SchoolLocationContactUpdateManyWithoutLocationNestedInput
    school?: SchoolUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type SchoolLocationUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolLocationImageUncheckedUpdateManyWithoutLocationNestedInput
    contacts?: SchoolLocationContactUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type AccountCreateWithoutStudentInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    password: string
    name: string
    dob: Date | string
    gender: $Enums.Gender
    phoneNumber: string
    idCardNumber: string
    address: string
    image?: string | null
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutStudentInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    password: string
    name: string
    dob: Date | string
    gender: $Enums.Gender
    phoneNumber: string
    idCardNumber: string
    address: string
    image?: string | null
    isLocked?: boolean
    isTwoFactorEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutStudentInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutStudentInput, AccountUncheckedCreateWithoutStudentInput>
  }

  export type SchoolCreateWithoutStudentsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: SchoolLocationCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipCreateNestedManyWithoutSchoolInput
    news?: NewsCreateNestedManyWithoutSchoolInput
    contacts?: ContactCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutStudentsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: SchoolLocationUncheckedCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramUncheckedCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryUncheckedCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipUncheckedCreateNestedManyWithoutSchoolInput
    news?: NewsUncheckedCreateNestedManyWithoutSchoolInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutStudentsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
  }

  export type MessageCreateWithoutStudentInput = {
    id?: string
    content: string
    createAt?: Date | string
    updateAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessegesInput
  }

  export type MessageUncheckedCreateWithoutStudentInput = {
    id?: string
    content: string
    createAt?: Date | string
    updateAt?: Date | string
    chatId: string
  }

  export type MessageCreateOrConnectWithoutStudentInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutStudentInput, MessageUncheckedCreateWithoutStudentInput>
  }

  export type MessageCreateManyStudentInputEnvelope = {
    data: MessageCreateManyStudentInput | MessageCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutStudentsInput = {
    id?: string
    name?: string | null
    creatAt?: Date | string
    updateAt?: Date | string
    messeges?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutStudentsInput = {
    id?: string
    name?: string | null
    creatAt?: Date | string
    updateAt?: Date | string
    messeges?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutStudentsInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutStudentsInput, ChatUncheckedCreateWithoutStudentsInput>
  }

  export type ProfileCreateWithoutStudentInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutStudentInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutStudentInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
  }

  export type StudentSchoolProgramCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    program: SchoolProgramCreateNestedOneWithoutStudentProgramsInput
  }

  export type StudentSchoolProgramUncheckedCreateWithoutStudentInput = {
    id?: string
    programId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolProgramCreateOrConnectWithoutStudentInput = {
    where: StudentSchoolProgramWhereUniqueInput
    create: XOR<StudentSchoolProgramCreateWithoutStudentInput, StudentSchoolProgramUncheckedCreateWithoutStudentInput>
  }

  export type StudentSchoolLocationCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    location: SchoolLocationCreateNestedOneWithoutStudentsInput
  }

  export type StudentSchoolLocationUncheckedCreateWithoutStudentInput = {
    id?: string
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolLocationCreateOrConnectWithoutStudentInput = {
    where: StudentSchoolLocationWhereUniqueInput
    create: XOR<StudentSchoolLocationCreateWithoutStudentInput, StudentSchoolLocationUncheckedCreateWithoutStudentInput>
  }

  export type StudentSchoolScholarshipCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    scholarship: SchoolScholarshipCreateNestedOneWithoutOwnersInput
  }

  export type StudentSchoolScholarshipUncheckedCreateWithoutStudentInput = {
    id?: string
    scholarshipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolScholarshipCreateOrConnectWithoutStudentInput = {
    where: StudentSchoolScholarshipWhereUniqueInput
    create: XOR<StudentSchoolScholarshipCreateWithoutStudentInput, StudentSchoolScholarshipUncheckedCreateWithoutStudentInput>
  }

  export type StudentSchoolScholarshipCreateManyStudentInputEnvelope = {
    data: StudentSchoolScholarshipCreateManyStudentInput | StudentSchoolScholarshipCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type NewsNotificationCreateWithoutStudentInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromStudent?: StudentCreateNestedOneWithoutOwnedNotificationsInput
    news: NewsCreateNestedOneWithoutNotificationsInput
  }

  export type NewsNotificationUncheckedCreateWithoutStudentInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    fromId?: string | null
    newsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsNotificationCreateOrConnectWithoutStudentInput = {
    where: NewsNotificationWhereUniqueInput
    create: XOR<NewsNotificationCreateWithoutStudentInput, NewsNotificationUncheckedCreateWithoutStudentInput>
  }

  export type NewsNotificationCreateManyStudentInputEnvelope = {
    data: NewsNotificationCreateManyStudentInput | NewsNotificationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type NewsNotificationCreateWithoutFromStudentInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutNotificationsInput
    news: NewsCreateNestedOneWithoutNotificationsInput
  }

  export type NewsNotificationUncheckedCreateWithoutFromStudentInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    studentId: string
    newsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsNotificationCreateOrConnectWithoutFromStudentInput = {
    where: NewsNotificationWhereUniqueInput
    create: XOR<NewsNotificationCreateWithoutFromStudentInput, NewsNotificationUncheckedCreateWithoutFromStudentInput>
  }

  export type NewsNotificationCreateManyFromStudentInputEnvelope = {
    data: NewsNotificationCreateManyFromStudentInput | NewsNotificationCreateManyFromStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentFollowCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    follower: StudentCreateNestedOneWithoutFollowersInput
  }

  export type StudentFollowUncheckedCreateWithoutStudentInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentFollowCreateOrConnectWithoutStudentInput = {
    where: StudentFollowWhereUniqueInput
    create: XOR<StudentFollowCreateWithoutStudentInput, StudentFollowUncheckedCreateWithoutStudentInput>
  }

  export type StudentFollowCreateManyStudentInputEnvelope = {
    data: StudentFollowCreateManyStudentInput | StudentFollowCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentFollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFollowsInput
  }

  export type StudentFollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentFollowCreateOrConnectWithoutFollowerInput = {
    where: StudentFollowWhereUniqueInput
    create: XOR<StudentFollowCreateWithoutFollowerInput, StudentFollowUncheckedCreateWithoutFollowerInput>
  }

  export type StudentFollowCreateManyFollowerInputEnvelope = {
    data: StudentFollowCreateManyFollowerInput | StudentFollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutStudentInput = {
    update: XOR<AccountUpdateWithoutStudentInput, AccountUncheckedUpdateWithoutStudentInput>
    create: XOR<AccountCreateWithoutStudentInput, AccountUncheckedCreateWithoutStudentInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutStudentInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutStudentInput, AccountUncheckedUpdateWithoutStudentInput>
  }

  export type AccountUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    phoneNumber?: StringFieldUpdateOperationsInput | string
    idCardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    phoneNumber?: StringFieldUpdateOperationsInput | string
    idCardNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutAccountNestedInput
  }

  export type SchoolUpsertWithoutStudentsInput = {
    update: XOR<SchoolUpdateWithoutStudentsInput, SchoolUncheckedUpdateWithoutStudentsInput>
    create: XOR<SchoolCreateWithoutStudentsInput, SchoolUncheckedCreateWithoutStudentsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutStudentsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutStudentsInput, SchoolUncheckedUpdateWithoutStudentsInput>
  }

  export type SchoolUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: SchoolLocationUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUpdateManyWithoutSchoolNestedInput
    news?: NewsUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: SchoolLocationUncheckedUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUncheckedUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUncheckedUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUncheckedUpdateManyWithoutSchoolNestedInput
    news?: NewsUncheckedUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutStudentInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutStudentInput, MessageUncheckedUpdateWithoutStudentInput>
    create: XOR<MessageCreateWithoutStudentInput, MessageUncheckedCreateWithoutStudentInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutStudentInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutStudentInput, MessageUncheckedUpdateWithoutStudentInput>
  }

  export type MessageUpdateManyWithWhereWithoutStudentInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutStudentInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createAt?: DateTimeFilter<"Message"> | Date | string
    updateAt?: DateTimeFilter<"Message"> | Date | string
    studentCode?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
  }

  export type ChatUpsertWithWhereUniqueWithoutStudentsInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutStudentsInput, ChatUncheckedUpdateWithoutStudentsInput>
    create: XOR<ChatCreateWithoutStudentsInput, ChatUncheckedCreateWithoutStudentsInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutStudentsInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutStudentsInput, ChatUncheckedUpdateWithoutStudentsInput>
  }

  export type ChatUpdateManyWithWhereWithoutStudentsInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutStudentsInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
    creatAt?: DateTimeFilter<"Chat"> | Date | string
    updateAt?: DateTimeFilter<"Chat"> | Date | string
  }

  export type ProfileUpsertWithoutStudentInput = {
    update: XOR<ProfileUpdateWithoutStudentInput, ProfileUncheckedUpdateWithoutStudentInput>
    create: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutStudentInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutStudentInput, ProfileUncheckedUpdateWithoutStudentInput>
  }

  export type ProfileUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type StudentSchoolProgramUpsertWithoutStudentInput = {
    update: XOR<StudentSchoolProgramUpdateWithoutStudentInput, StudentSchoolProgramUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSchoolProgramCreateWithoutStudentInput, StudentSchoolProgramUncheckedCreateWithoutStudentInput>
    where?: StudentSchoolProgramWhereInput
  }

  export type StudentSchoolProgramUpdateToOneWithWhereWithoutStudentInput = {
    where?: StudentSchoolProgramWhereInput
    data: XOR<StudentSchoolProgramUpdateWithoutStudentInput, StudentSchoolProgramUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSchoolProgramUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: SchoolProgramUpdateOneRequiredWithoutStudentProgramsNestedInput
  }

  export type StudentSchoolProgramUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolLocationUpsertWithoutStudentInput = {
    update: XOR<StudentSchoolLocationUpdateWithoutStudentInput, StudentSchoolLocationUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSchoolLocationCreateWithoutStudentInput, StudentSchoolLocationUncheckedCreateWithoutStudentInput>
    where?: StudentSchoolLocationWhereInput
  }

  export type StudentSchoolLocationUpdateToOneWithWhereWithoutStudentInput = {
    where?: StudentSchoolLocationWhereInput
    data: XOR<StudentSchoolLocationUpdateWithoutStudentInput, StudentSchoolLocationUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSchoolLocationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: SchoolLocationUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentSchoolLocationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolScholarshipUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSchoolScholarshipWhereUniqueInput
    update: XOR<StudentSchoolScholarshipUpdateWithoutStudentInput, StudentSchoolScholarshipUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSchoolScholarshipCreateWithoutStudentInput, StudentSchoolScholarshipUncheckedCreateWithoutStudentInput>
  }

  export type StudentSchoolScholarshipUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSchoolScholarshipWhereUniqueInput
    data: XOR<StudentSchoolScholarshipUpdateWithoutStudentInput, StudentSchoolScholarshipUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSchoolScholarshipUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSchoolScholarshipScalarWhereInput
    data: XOR<StudentSchoolScholarshipUpdateManyMutationInput, StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentInput>
  }

  export type NewsNotificationUpsertWithWhereUniqueWithoutStudentInput = {
    where: NewsNotificationWhereUniqueInput
    update: XOR<NewsNotificationUpdateWithoutStudentInput, NewsNotificationUncheckedUpdateWithoutStudentInput>
    create: XOR<NewsNotificationCreateWithoutStudentInput, NewsNotificationUncheckedCreateWithoutStudentInput>
  }

  export type NewsNotificationUpdateWithWhereUniqueWithoutStudentInput = {
    where: NewsNotificationWhereUniqueInput
    data: XOR<NewsNotificationUpdateWithoutStudentInput, NewsNotificationUncheckedUpdateWithoutStudentInput>
  }

  export type NewsNotificationUpdateManyWithWhereWithoutStudentInput = {
    where: NewsNotificationScalarWhereInput
    data: XOR<NewsNotificationUpdateManyMutationInput, NewsNotificationUncheckedUpdateManyWithoutStudentInput>
  }

  export type NewsNotificationScalarWhereInput = {
    AND?: NewsNotificationScalarWhereInput | NewsNotificationScalarWhereInput[]
    OR?: NewsNotificationScalarWhereInput[]
    NOT?: NewsNotificationScalarWhereInput | NewsNotificationScalarWhereInput[]
    id?: StringFilter<"NewsNotification"> | string
    type?: EnumNewsTypeFilter<"NewsNotification"> | $Enums.NewsType
    isRead?: BoolFilter<"NewsNotification"> | boolean
    studentId?: StringFilter<"NewsNotification"> | string
    fromId?: StringNullableFilter<"NewsNotification"> | string | null
    newsId?: StringFilter<"NewsNotification"> | string
    createdAt?: DateTimeFilter<"NewsNotification"> | Date | string
    updatedAt?: DateTimeFilter<"NewsNotification"> | Date | string
  }

  export type NewsNotificationUpsertWithWhereUniqueWithoutFromStudentInput = {
    where: NewsNotificationWhereUniqueInput
    update: XOR<NewsNotificationUpdateWithoutFromStudentInput, NewsNotificationUncheckedUpdateWithoutFromStudentInput>
    create: XOR<NewsNotificationCreateWithoutFromStudentInput, NewsNotificationUncheckedCreateWithoutFromStudentInput>
  }

  export type NewsNotificationUpdateWithWhereUniqueWithoutFromStudentInput = {
    where: NewsNotificationWhereUniqueInput
    data: XOR<NewsNotificationUpdateWithoutFromStudentInput, NewsNotificationUncheckedUpdateWithoutFromStudentInput>
  }

  export type NewsNotificationUpdateManyWithWhereWithoutFromStudentInput = {
    where: NewsNotificationScalarWhereInput
    data: XOR<NewsNotificationUpdateManyMutationInput, NewsNotificationUncheckedUpdateManyWithoutFromStudentInput>
  }

  export type StudentFollowUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentFollowWhereUniqueInput
    update: XOR<StudentFollowUpdateWithoutStudentInput, StudentFollowUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentFollowCreateWithoutStudentInput, StudentFollowUncheckedCreateWithoutStudentInput>
  }

  export type StudentFollowUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentFollowWhereUniqueInput
    data: XOR<StudentFollowUpdateWithoutStudentInput, StudentFollowUncheckedUpdateWithoutStudentInput>
  }

  export type StudentFollowUpdateManyWithWhereWithoutStudentInput = {
    where: StudentFollowScalarWhereInput
    data: XOR<StudentFollowUpdateManyMutationInput, StudentFollowUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentFollowScalarWhereInput = {
    AND?: StudentFollowScalarWhereInput | StudentFollowScalarWhereInput[]
    OR?: StudentFollowScalarWhereInput[]
    NOT?: StudentFollowScalarWhereInput | StudentFollowScalarWhereInput[]
    id?: StringFilter<"StudentFollow"> | string
    studentId?: StringFilter<"StudentFollow"> | string
    followerId?: StringFilter<"StudentFollow"> | string
    createdAt?: DateTimeFilter<"StudentFollow"> | Date | string
    updatedAt?: DateTimeFilter<"StudentFollow"> | Date | string
  }

  export type StudentFollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: StudentFollowWhereUniqueInput
    update: XOR<StudentFollowUpdateWithoutFollowerInput, StudentFollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<StudentFollowCreateWithoutFollowerInput, StudentFollowUncheckedCreateWithoutFollowerInput>
  }

  export type StudentFollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: StudentFollowWhereUniqueInput
    data: XOR<StudentFollowUpdateWithoutFollowerInput, StudentFollowUncheckedUpdateWithoutFollowerInput>
  }

  export type StudentFollowUpdateManyWithWhereWithoutFollowerInput = {
    where: StudentFollowScalarWhereInput
    data: XOR<StudentFollowUpdateManyMutationInput, StudentFollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    content: string
    createAt?: Date | string
    updateAt?: Date | string
    student: StudentCreateNestedOneWithoutMesseagesInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    content: string
    createAt?: Date | string
    updateAt?: Date | string
    studentCode: string
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutChatsInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutChatsInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutChatsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutChatsInput, StudentUncheckedCreateWithoutChatsInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutChatsInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutChatsInput, StudentUncheckedUpdateWithoutChatsInput>
    create: XOR<StudentCreateWithoutChatsInput, StudentUncheckedCreateWithoutChatsInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutChatsInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutChatsInput, StudentUncheckedUpdateWithoutChatsInput>
  }

  export type StudentUpdateManyWithWhereWithoutChatsInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutChatsInput>
  }

  export type StudentCreateWithoutMesseagesInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutMesseagesInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutMesseagesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutMesseagesInput, StudentUncheckedCreateWithoutMesseagesInput>
  }

  export type ChatCreateWithoutMessegesInput = {
    id?: string
    name?: string | null
    creatAt?: Date | string
    updateAt?: Date | string
    students?: StudentCreateNestedManyWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutMessegesInput = {
    id?: string
    name?: string | null
    creatAt?: Date | string
    updateAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutChatsInput
  }

  export type ChatCreateOrConnectWithoutMessegesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessegesInput, ChatUncheckedCreateWithoutMessegesInput>
  }

  export type StudentUpsertWithoutMesseagesInput = {
    update: XOR<StudentUpdateWithoutMesseagesInput, StudentUncheckedUpdateWithoutMesseagesInput>
    create: XOR<StudentCreateWithoutMesseagesInput, StudentUncheckedCreateWithoutMesseagesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutMesseagesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutMesseagesInput, StudentUncheckedUpdateWithoutMesseagesInput>
  }

  export type StudentUpdateWithoutMesseagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutMesseagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type ChatUpsertWithoutMessegesInput = {
    update: XOR<ChatUpdateWithoutMessegesInput, ChatUncheckedUpdateWithoutMessegesInput>
    create: XOR<ChatCreateWithoutMessegesInput, ChatUncheckedCreateWithoutMessegesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessegesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessegesInput, ChatUncheckedUpdateWithoutMessegesInput>
  }

  export type ChatUpdateWithoutMessegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessegesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type ProfileCreateWithoutHostedEventsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutHostedEventsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutHostedEventsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutHostedEventsInput, ProfileUncheckedCreateWithoutHostedEventsInput>
  }

  export type EventProfileCreateWithoutEventInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutParticipatedEventsInput
  }

  export type EventProfileUncheckedCreateWithoutEventInput = {
    id?: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventProfileCreateOrConnectWithoutEventInput = {
    where: EventProfileWhereUniqueInput
    create: XOR<EventProfileCreateWithoutEventInput, EventProfileUncheckedCreateWithoutEventInput>
  }

  export type EventProfileCreateManyEventInputEnvelope = {
    data: EventProfileCreateManyEventInput | EventProfileCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutHostedEventsInput = {
    update: XOR<ProfileUpdateWithoutHostedEventsInput, ProfileUncheckedUpdateWithoutHostedEventsInput>
    create: XOR<ProfileCreateWithoutHostedEventsInput, ProfileUncheckedCreateWithoutHostedEventsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutHostedEventsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutHostedEventsInput, ProfileUncheckedUpdateWithoutHostedEventsInput>
  }

  export type ProfileUpdateWithoutHostedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutHostedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type EventProfileUpsertWithWhereUniqueWithoutEventInput = {
    where: EventProfileWhereUniqueInput
    update: XOR<EventProfileUpdateWithoutEventInput, EventProfileUncheckedUpdateWithoutEventInput>
    create: XOR<EventProfileCreateWithoutEventInput, EventProfileUncheckedCreateWithoutEventInput>
  }

  export type EventProfileUpdateWithWhereUniqueWithoutEventInput = {
    where: EventProfileWhereUniqueInput
    data: XOR<EventProfileUpdateWithoutEventInput, EventProfileUncheckedUpdateWithoutEventInput>
  }

  export type EventProfileUpdateManyWithWhereWithoutEventInput = {
    where: EventProfileScalarWhereInput
    data: XOR<EventProfileUpdateManyMutationInput, EventProfileUncheckedUpdateManyWithoutEventInput>
  }

  export type EventProfileScalarWhereInput = {
    AND?: EventProfileScalarWhereInput | EventProfileScalarWhereInput[]
    OR?: EventProfileScalarWhereInput[]
    NOT?: EventProfileScalarWhereInput | EventProfileScalarWhereInput[]
    id?: StringFilter<"EventProfile"> | string
    eventId?: StringFilter<"EventProfile"> | string
    profileId?: StringFilter<"EventProfile"> | string
    createdAt?: DateTimeFilter<"EventProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EventProfile"> | Date | string
  }

  export type EventCreateWithoutParticipantsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    host: ProfileCreateNestedOneWithoutHostedEventsInput
  }

  export type EventUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    hostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutParticipantsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutParticipantsInput, EventUncheckedCreateWithoutParticipantsInput>
  }

  export type ProfileCreateWithoutParticipatedEventsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutParticipatedEventsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutParticipatedEventsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutParticipatedEventsInput, ProfileUncheckedCreateWithoutParticipatedEventsInput>
  }

  export type EventUpsertWithoutParticipantsInput = {
    update: XOR<EventUpdateWithoutParticipantsInput, EventUncheckedUpdateWithoutParticipantsInput>
    create: XOR<EventCreateWithoutParticipantsInput, EventUncheckedCreateWithoutParticipantsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutParticipantsInput, EventUncheckedUpdateWithoutParticipantsInput>
  }

  export type EventUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: ProfileUpdateOneRequiredWithoutHostedEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    hostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUpsertWithoutParticipatedEventsInput = {
    update: XOR<ProfileUpdateWithoutParticipatedEventsInput, ProfileUncheckedUpdateWithoutParticipatedEventsInput>
    create: XOR<ProfileCreateWithoutParticipatedEventsInput, ProfileUncheckedCreateWithoutParticipatedEventsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutParticipatedEventsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutParticipatedEventsInput, ProfileUncheckedUpdateWithoutParticipatedEventsInput>
  }

  export type ProfileUpdateWithoutParticipatedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutParticipatedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type StudentCreateWithoutProfileInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutProfileInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutProfileInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
  }

  export type EventCreateWithoutHostInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: EventProfileCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutHostInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: EventProfileUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutHostInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutHostInput, EventUncheckedCreateWithoutHostInput>
  }

  export type EventCreateManyHostInputEnvelope = {
    data: EventCreateManyHostInput | EventCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type EventProfileCreateWithoutProfileInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutParticipantsInput
  }

  export type EventProfileUncheckedCreateWithoutProfileInput = {
    id?: string
    eventId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventProfileCreateOrConnectWithoutProfileInput = {
    where: EventProfileWhereUniqueInput
    create: XOR<EventProfileCreateWithoutProfileInput, EventProfileUncheckedCreateWithoutProfileInput>
  }

  export type EventProfileCreateManyProfileInputEnvelope = {
    data: EventProfileCreateManyProfileInput | EventProfileCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutProfileInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PostImageCreateNestedManyWithoutPostInput
    comments?: PostCommentCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
    shares?: PostShareCreateNestedManyWithoutPostInput
    saves?: PostSaveCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutProfileInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    shares?: PostShareUncheckedCreateNestedManyWithoutPostInput
    saves?: PostSaveUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutProfileInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutProfileInput, PostUncheckedCreateWithoutProfileInput>
  }

  export type PostCreateManyProfileInputEnvelope = {
    data: PostCreateManyProfileInput | PostCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileBiographyCreateWithoutProfileInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    areas?: ProfileBiographyAreaCreateNestedManyWithoutBiographyInput
    socials?: ProfileBiographySocialCreateNestedManyWithoutProfileBiographyInput
  }

  export type ProfileBiographyUncheckedCreateWithoutProfileInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    areas?: ProfileBiographyAreaUncheckedCreateNestedManyWithoutBiographyInput
    socials?: ProfileBiographySocialUncheckedCreateNestedManyWithoutProfileBiographyInput
  }

  export type ProfileBiographyCreateOrConnectWithoutProfileInput = {
    where: ProfileBiographyWhereUniqueInput
    create: XOR<ProfileBiographyCreateWithoutProfileInput, ProfileBiographyUncheckedCreateWithoutProfileInput>
  }

  export type ProfileFriendCreateWithoutProfileOneInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileTwo: ProfileCreateNestedOneWithoutFriendReceivedInput
  }

  export type ProfileFriendUncheckedCreateWithoutProfileOneInput = {
    id?: string
    isActive?: boolean
    profileIdTwo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileFriendCreateOrConnectWithoutProfileOneInput = {
    where: ProfileFriendWhereUniqueInput
    create: XOR<ProfileFriendCreateWithoutProfileOneInput, ProfileFriendUncheckedCreateWithoutProfileOneInput>
  }

  export type ProfileFriendCreateManyProfileOneInputEnvelope = {
    data: ProfileFriendCreateManyProfileOneInput | ProfileFriendCreateManyProfileOneInput[]
    skipDuplicates?: boolean
  }

  export type ProfileFriendCreateWithoutProfileTwoInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileOne: ProfileCreateNestedOneWithoutFriendRequestsInput
  }

  export type ProfileFriendUncheckedCreateWithoutProfileTwoInput = {
    id?: string
    isActive?: boolean
    profileIdOne: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileFriendCreateOrConnectWithoutProfileTwoInput = {
    where: ProfileFriendWhereUniqueInput
    create: XOR<ProfileFriendCreateWithoutProfileTwoInput, ProfileFriendUncheckedCreateWithoutProfileTwoInput>
  }

  export type ProfileFriendCreateManyProfileTwoInputEnvelope = {
    data: ProfileFriendCreateManyProfileTwoInput | ProfileFriendCreateManyProfileTwoInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profiles?: ProfileGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutOwnerInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput>
  }

  export type GroupCreateManyOwnerInputEnvelope = {
    data: GroupCreateManyOwnerInput | GroupCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProfileGroupCreateWithoutProfileInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutProfilesInput
  }

  export type ProfileGroupUncheckedCreateWithoutProfileInput = {
    id?: string
    groupId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileGroupCreateOrConnectWithoutProfileInput = {
    where: ProfileGroupWhereUniqueInput
    create: XOR<ProfileGroupCreateWithoutProfileInput, ProfileGroupUncheckedCreateWithoutProfileInput>
  }

  export type ProfileGroupCreateManyProfileInputEnvelope = {
    data: ProfileGroupCreateManyProfileInput | ProfileGroupCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileBlogCreateWithoutProfileInput = {
    id?: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProfileBlogImageCreateNestedManyWithoutProfileBlogInput
  }

  export type ProfileBlogUncheckedCreateWithoutProfileInput = {
    id?: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProfileBlogImageUncheckedCreateNestedManyWithoutProfileBlogInput
  }

  export type ProfileBlogCreateOrConnectWithoutProfileInput = {
    where: ProfileBlogWhereUniqueInput
    create: XOR<ProfileBlogCreateWithoutProfileInput, ProfileBlogUncheckedCreateWithoutProfileInput>
  }

  export type ProfileBlogCreateManyProfileInputEnvelope = {
    data: ProfileBlogCreateManyProfileInput | ProfileBlogCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type PostCommentCreateWithoutProfileInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    parentComment?: PostCommentCreateNestedOneWithoutChildrenInput
    children?: PostCommentCreateNestedManyWithoutParentCommentInput
    likes?: PostCommentLikeCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentUncheckedCreateWithoutProfileInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    postId: string
    parentCommentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostCommentUncheckedCreateNestedManyWithoutParentCommentInput
    likes?: PostCommentLikeUncheckedCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentCreateOrConnectWithoutProfileInput = {
    where: PostCommentWhereUniqueInput
    create: XOR<PostCommentCreateWithoutProfileInput, PostCommentUncheckedCreateWithoutProfileInput>
  }

  export type PostCommentCreateManyProfileInputEnvelope = {
    data: PostCommentCreateManyProfileInput | PostCommentCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type PostCommentLikeCreateWithoutProfileInput = {
    id?: string
    postComment: PostCommentCreateNestedOneWithoutLikesInput
  }

  export type PostCommentLikeUncheckedCreateWithoutProfileInput = {
    id?: string
    postCommentId: string
  }

  export type PostCommentLikeCreateOrConnectWithoutProfileInput = {
    where: PostCommentLikeWhereUniqueInput
    create: XOR<PostCommentLikeCreateWithoutProfileInput, PostCommentLikeUncheckedCreateWithoutProfileInput>
  }

  export type PostCommentLikeCreateManyProfileInputEnvelope = {
    data: PostCommentLikeCreateManyProfileInput | PostCommentLikeCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type PostLikeCreateWithoutProfileInput = {
    id?: string
    post: PostCreateNestedOneWithoutLikesInput
  }

  export type PostLikeUncheckedCreateWithoutProfileInput = {
    id?: string
    postId: string
  }

  export type PostLikeCreateOrConnectWithoutProfileInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutProfileInput, PostLikeUncheckedCreateWithoutProfileInput>
  }

  export type PostLikeCreateManyProfileInputEnvelope = {
    data: PostLikeCreateManyProfileInput | PostLikeCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type PostShareCreateWithoutProfileInput = {
    id?: string
    post: PostCreateNestedOneWithoutSharesInput
  }

  export type PostShareUncheckedCreateWithoutProfileInput = {
    id?: string
    postId: string
  }

  export type PostShareCreateOrConnectWithoutProfileInput = {
    where: PostShareWhereUniqueInput
    create: XOR<PostShareCreateWithoutProfileInput, PostShareUncheckedCreateWithoutProfileInput>
  }

  export type PostShareCreateManyProfileInputEnvelope = {
    data: PostShareCreateManyProfileInput | PostShareCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type PostSaveCreateWithoutProfileInput = {
    id?: string
    post: PostCreateNestedOneWithoutSavesInput
  }

  export type PostSaveUncheckedCreateWithoutProfileInput = {
    id?: string
    postId: string
  }

  export type PostSaveCreateOrConnectWithoutProfileInput = {
    where: PostSaveWhereUniqueInput
    create: XOR<PostSaveCreateWithoutProfileInput, PostSaveUncheckedCreateWithoutProfileInput>
  }

  export type PostSaveCreateManyProfileInputEnvelope = {
    data: PostSaveCreateManyProfileInput | PostSaveCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutProfileInput = {
    update: XOR<StudentUpdateWithoutProfileInput, StudentUncheckedUpdateWithoutProfileInput>
    create: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutProfileInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutProfileInput, StudentUncheckedUpdateWithoutProfileInput>
  }

  export type StudentUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutHostInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutHostInput, EventUncheckedUpdateWithoutHostInput>
    create: XOR<EventCreateWithoutHostInput, EventUncheckedCreateWithoutHostInput>
  }

  export type EventUpdateWithWhereUniqueWithoutHostInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutHostInput, EventUncheckedUpdateWithoutHostInput>
  }

  export type EventUpdateManyWithWhereWithoutHostInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutHostInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    hostId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type EventProfileUpsertWithWhereUniqueWithoutProfileInput = {
    where: EventProfileWhereUniqueInput
    update: XOR<EventProfileUpdateWithoutProfileInput, EventProfileUncheckedUpdateWithoutProfileInput>
    create: XOR<EventProfileCreateWithoutProfileInput, EventProfileUncheckedCreateWithoutProfileInput>
  }

  export type EventProfileUpdateWithWhereUniqueWithoutProfileInput = {
    where: EventProfileWhereUniqueInput
    data: XOR<EventProfileUpdateWithoutProfileInput, EventProfileUncheckedUpdateWithoutProfileInput>
  }

  export type EventProfileUpdateManyWithWhereWithoutProfileInput = {
    where: EventProfileScalarWhereInput
    data: XOR<EventProfileUpdateManyMutationInput, EventProfileUncheckedUpdateManyWithoutProfileInput>
  }

  export type PostUpsertWithWhereUniqueWithoutProfileInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutProfileInput, PostUncheckedUpdateWithoutProfileInput>
    create: XOR<PostCreateWithoutProfileInput, PostUncheckedCreateWithoutProfileInput>
  }

  export type PostUpdateWithWhereUniqueWithoutProfileInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutProfileInput, PostUncheckedUpdateWithoutProfileInput>
  }

  export type PostUpdateManyWithWhereWithoutProfileInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutProfileInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    isArchived?: BoolFilter<"Post"> | boolean
    profileId?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type ProfileBiographyUpsertWithoutProfileInput = {
    update: XOR<ProfileBiographyUpdateWithoutProfileInput, ProfileBiographyUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileBiographyCreateWithoutProfileInput, ProfileBiographyUncheckedCreateWithoutProfileInput>
    where?: ProfileBiographyWhereInput
  }

  export type ProfileBiographyUpdateToOneWithWhereWithoutProfileInput = {
    where?: ProfileBiographyWhereInput
    data: XOR<ProfileBiographyUpdateWithoutProfileInput, ProfileBiographyUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileBiographyUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areas?: ProfileBiographyAreaUpdateManyWithoutBiographyNestedInput
    socials?: ProfileBiographySocialUpdateManyWithoutProfileBiographyNestedInput
  }

  export type ProfileBiographyUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areas?: ProfileBiographyAreaUncheckedUpdateManyWithoutBiographyNestedInput
    socials?: ProfileBiographySocialUncheckedUpdateManyWithoutProfileBiographyNestedInput
  }

  export type ProfileFriendUpsertWithWhereUniqueWithoutProfileOneInput = {
    where: ProfileFriendWhereUniqueInput
    update: XOR<ProfileFriendUpdateWithoutProfileOneInput, ProfileFriendUncheckedUpdateWithoutProfileOneInput>
    create: XOR<ProfileFriendCreateWithoutProfileOneInput, ProfileFriendUncheckedCreateWithoutProfileOneInput>
  }

  export type ProfileFriendUpdateWithWhereUniqueWithoutProfileOneInput = {
    where: ProfileFriendWhereUniqueInput
    data: XOR<ProfileFriendUpdateWithoutProfileOneInput, ProfileFriendUncheckedUpdateWithoutProfileOneInput>
  }

  export type ProfileFriendUpdateManyWithWhereWithoutProfileOneInput = {
    where: ProfileFriendScalarWhereInput
    data: XOR<ProfileFriendUpdateManyMutationInput, ProfileFriendUncheckedUpdateManyWithoutProfileOneInput>
  }

  export type ProfileFriendScalarWhereInput = {
    AND?: ProfileFriendScalarWhereInput | ProfileFriendScalarWhereInput[]
    OR?: ProfileFriendScalarWhereInput[]
    NOT?: ProfileFriendScalarWhereInput | ProfileFriendScalarWhereInput[]
    id?: StringFilter<"ProfileFriend"> | string
    isActive?: BoolFilter<"ProfileFriend"> | boolean
    profileIdOne?: StringFilter<"ProfileFriend"> | string
    profileIdTwo?: StringFilter<"ProfileFriend"> | string
    createdAt?: DateTimeFilter<"ProfileFriend"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileFriend"> | Date | string
  }

  export type ProfileFriendUpsertWithWhereUniqueWithoutProfileTwoInput = {
    where: ProfileFriendWhereUniqueInput
    update: XOR<ProfileFriendUpdateWithoutProfileTwoInput, ProfileFriendUncheckedUpdateWithoutProfileTwoInput>
    create: XOR<ProfileFriendCreateWithoutProfileTwoInput, ProfileFriendUncheckedCreateWithoutProfileTwoInput>
  }

  export type ProfileFriendUpdateWithWhereUniqueWithoutProfileTwoInput = {
    where: ProfileFriendWhereUniqueInput
    data: XOR<ProfileFriendUpdateWithoutProfileTwoInput, ProfileFriendUncheckedUpdateWithoutProfileTwoInput>
  }

  export type ProfileFriendUpdateManyWithWhereWithoutProfileTwoInput = {
    where: ProfileFriendScalarWhereInput
    data: XOR<ProfileFriendUpdateManyMutationInput, ProfileFriendUncheckedUpdateManyWithoutProfileTwoInput>
  }

  export type GroupUpsertWithWhereUniqueWithoutOwnerInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutOwnerInput, GroupUncheckedUpdateWithoutOwnerInput>
    create: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutOwnerInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutOwnerInput, GroupUncheckedUpdateWithoutOwnerInput>
  }

  export type GroupUpdateManyWithWhereWithoutOwnerInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutOwnerInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    ownerId?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type ProfileGroupUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileGroupWhereUniqueInput
    update: XOR<ProfileGroupUpdateWithoutProfileInput, ProfileGroupUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileGroupCreateWithoutProfileInput, ProfileGroupUncheckedCreateWithoutProfileInput>
  }

  export type ProfileGroupUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileGroupWhereUniqueInput
    data: XOR<ProfileGroupUpdateWithoutProfileInput, ProfileGroupUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileGroupUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileGroupScalarWhereInput
    data: XOR<ProfileGroupUpdateManyMutationInput, ProfileGroupUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfileGroupScalarWhereInput = {
    AND?: ProfileGroupScalarWhereInput | ProfileGroupScalarWhereInput[]
    OR?: ProfileGroupScalarWhereInput[]
    NOT?: ProfileGroupScalarWhereInput | ProfileGroupScalarWhereInput[]
    id?: StringFilter<"ProfileGroup"> | string
    profileId?: StringFilter<"ProfileGroup"> | string
    groupId?: StringFilter<"ProfileGroup"> | string
    createdAt?: DateTimeFilter<"ProfileGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileGroup"> | Date | string
  }

  export type ProfileBlogUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileBlogWhereUniqueInput
    update: XOR<ProfileBlogUpdateWithoutProfileInput, ProfileBlogUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileBlogCreateWithoutProfileInput, ProfileBlogUncheckedCreateWithoutProfileInput>
  }

  export type ProfileBlogUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileBlogWhereUniqueInput
    data: XOR<ProfileBlogUpdateWithoutProfileInput, ProfileBlogUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileBlogUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileBlogScalarWhereInput
    data: XOR<ProfileBlogUpdateManyMutationInput, ProfileBlogUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfileBlogScalarWhereInput = {
    AND?: ProfileBlogScalarWhereInput | ProfileBlogScalarWhereInput[]
    OR?: ProfileBlogScalarWhereInput[]
    NOT?: ProfileBlogScalarWhereInput | ProfileBlogScalarWhereInput[]
    id?: StringFilter<"ProfileBlog"> | string
    title?: StringFilter<"ProfileBlog"> | string
    content?: StringNullableFilter<"ProfileBlog"> | string | null
    profileId?: StringFilter<"ProfileBlog"> | string
    createdAt?: DateTimeFilter<"ProfileBlog"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBlog"> | Date | string
  }

  export type PostCommentUpsertWithWhereUniqueWithoutProfileInput = {
    where: PostCommentWhereUniqueInput
    update: XOR<PostCommentUpdateWithoutProfileInput, PostCommentUncheckedUpdateWithoutProfileInput>
    create: XOR<PostCommentCreateWithoutProfileInput, PostCommentUncheckedCreateWithoutProfileInput>
  }

  export type PostCommentUpdateWithWhereUniqueWithoutProfileInput = {
    where: PostCommentWhereUniqueInput
    data: XOR<PostCommentUpdateWithoutProfileInput, PostCommentUncheckedUpdateWithoutProfileInput>
  }

  export type PostCommentUpdateManyWithWhereWithoutProfileInput = {
    where: PostCommentScalarWhereInput
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyWithoutProfileInput>
  }

  export type PostCommentScalarWhereInput = {
    AND?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
    OR?: PostCommentScalarWhereInput[]
    NOT?: PostCommentScalarWhereInput | PostCommentScalarWhereInput[]
    id?: StringFilter<"PostComment"> | string
    content?: StringNullableFilter<"PostComment"> | string | null
    image?: StringNullableFilter<"PostComment"> | string | null
    isArchived?: BoolFilter<"PostComment"> | boolean
    profileId?: StringFilter<"PostComment"> | string
    postId?: StringFilter<"PostComment"> | string
    parentCommentId?: StringNullableFilter<"PostComment"> | string | null
    createdAt?: DateTimeFilter<"PostComment"> | Date | string
    updatedAt?: DateTimeFilter<"PostComment"> | Date | string
  }

  export type PostCommentLikeUpsertWithWhereUniqueWithoutProfileInput = {
    where: PostCommentLikeWhereUniqueInput
    update: XOR<PostCommentLikeUpdateWithoutProfileInput, PostCommentLikeUncheckedUpdateWithoutProfileInput>
    create: XOR<PostCommentLikeCreateWithoutProfileInput, PostCommentLikeUncheckedCreateWithoutProfileInput>
  }

  export type PostCommentLikeUpdateWithWhereUniqueWithoutProfileInput = {
    where: PostCommentLikeWhereUniqueInput
    data: XOR<PostCommentLikeUpdateWithoutProfileInput, PostCommentLikeUncheckedUpdateWithoutProfileInput>
  }

  export type PostCommentLikeUpdateManyWithWhereWithoutProfileInput = {
    where: PostCommentLikeScalarWhereInput
    data: XOR<PostCommentLikeUpdateManyMutationInput, PostCommentLikeUncheckedUpdateManyWithoutProfileInput>
  }

  export type PostCommentLikeScalarWhereInput = {
    AND?: PostCommentLikeScalarWhereInput | PostCommentLikeScalarWhereInput[]
    OR?: PostCommentLikeScalarWhereInput[]
    NOT?: PostCommentLikeScalarWhereInput | PostCommentLikeScalarWhereInput[]
    id?: StringFilter<"PostCommentLike"> | string
    profileId?: StringFilter<"PostCommentLike"> | string
    postCommentId?: StringFilter<"PostCommentLike"> | string
  }

  export type PostLikeUpsertWithWhereUniqueWithoutProfileInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutProfileInput, PostLikeUncheckedUpdateWithoutProfileInput>
    create: XOR<PostLikeCreateWithoutProfileInput, PostLikeUncheckedCreateWithoutProfileInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutProfileInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutProfileInput, PostLikeUncheckedUpdateWithoutProfileInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutProfileInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutProfileInput>
  }

  export type PostLikeScalarWhereInput = {
    AND?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
    OR?: PostLikeScalarWhereInput[]
    NOT?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
    id?: StringFilter<"PostLike"> | string
    profileId?: StringFilter<"PostLike"> | string
    postId?: StringFilter<"PostLike"> | string
  }

  export type PostShareUpsertWithWhereUniqueWithoutProfileInput = {
    where: PostShareWhereUniqueInput
    update: XOR<PostShareUpdateWithoutProfileInput, PostShareUncheckedUpdateWithoutProfileInput>
    create: XOR<PostShareCreateWithoutProfileInput, PostShareUncheckedCreateWithoutProfileInput>
  }

  export type PostShareUpdateWithWhereUniqueWithoutProfileInput = {
    where: PostShareWhereUniqueInput
    data: XOR<PostShareUpdateWithoutProfileInput, PostShareUncheckedUpdateWithoutProfileInput>
  }

  export type PostShareUpdateManyWithWhereWithoutProfileInput = {
    where: PostShareScalarWhereInput
    data: XOR<PostShareUpdateManyMutationInput, PostShareUncheckedUpdateManyWithoutProfileInput>
  }

  export type PostShareScalarWhereInput = {
    AND?: PostShareScalarWhereInput | PostShareScalarWhereInput[]
    OR?: PostShareScalarWhereInput[]
    NOT?: PostShareScalarWhereInput | PostShareScalarWhereInput[]
    id?: StringFilter<"PostShare"> | string
    profileId?: StringFilter<"PostShare"> | string
    postId?: StringFilter<"PostShare"> | string
  }

  export type PostSaveUpsertWithWhereUniqueWithoutProfileInput = {
    where: PostSaveWhereUniqueInput
    update: XOR<PostSaveUpdateWithoutProfileInput, PostSaveUncheckedUpdateWithoutProfileInput>
    create: XOR<PostSaveCreateWithoutProfileInput, PostSaveUncheckedCreateWithoutProfileInput>
  }

  export type PostSaveUpdateWithWhereUniqueWithoutProfileInput = {
    where: PostSaveWhereUniqueInput
    data: XOR<PostSaveUpdateWithoutProfileInput, PostSaveUncheckedUpdateWithoutProfileInput>
  }

  export type PostSaveUpdateManyWithWhereWithoutProfileInput = {
    where: PostSaveScalarWhereInput
    data: XOR<PostSaveUpdateManyMutationInput, PostSaveUncheckedUpdateManyWithoutProfileInput>
  }

  export type PostSaveScalarWhereInput = {
    AND?: PostSaveScalarWhereInput | PostSaveScalarWhereInput[]
    OR?: PostSaveScalarWhereInput[]
    NOT?: PostSaveScalarWhereInput | PostSaveScalarWhereInput[]
    id?: StringFilter<"PostSave"> | string
    profileId?: StringFilter<"PostSave"> | string
    postId?: StringFilter<"PostSave"> | string
  }

  export type ProfileCreateWithoutFriendRequestsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutFriendRequestsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutFriendRequestsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutFriendRequestsInput, ProfileUncheckedCreateWithoutFriendRequestsInput>
  }

  export type ProfileCreateWithoutFriendReceivedInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutFriendReceivedInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutFriendReceivedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutFriendReceivedInput, ProfileUncheckedCreateWithoutFriendReceivedInput>
  }

  export type ProfileUpsertWithoutFriendRequestsInput = {
    update: XOR<ProfileUpdateWithoutFriendRequestsInput, ProfileUncheckedUpdateWithoutFriendRequestsInput>
    create: XOR<ProfileCreateWithoutFriendRequestsInput, ProfileUncheckedCreateWithoutFriendRequestsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutFriendRequestsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutFriendRequestsInput, ProfileUncheckedUpdateWithoutFriendRequestsInput>
  }

  export type ProfileUpdateWithoutFriendRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutFriendRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUpsertWithoutFriendReceivedInput = {
    update: XOR<ProfileUpdateWithoutFriendReceivedInput, ProfileUncheckedUpdateWithoutFriendReceivedInput>
    create: XOR<ProfileCreateWithoutFriendReceivedInput, ProfileUncheckedCreateWithoutFriendReceivedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutFriendReceivedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutFriendReceivedInput, ProfileUncheckedUpdateWithoutFriendReceivedInput>
  }

  export type ProfileUpdateWithoutFriendReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutFriendReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileBiographyAreaCreateWithoutAreaInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    biography: ProfileBiographyCreateNestedOneWithoutAreasInput
  }

  export type ProfileBiographyAreaUncheckedCreateWithoutAreaInput = {
    id?: string
    biographyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographyAreaCreateOrConnectWithoutAreaInput = {
    where: ProfileBiographyAreaWhereUniqueInput
    create: XOR<ProfileBiographyAreaCreateWithoutAreaInput, ProfileBiographyAreaUncheckedCreateWithoutAreaInput>
  }

  export type ProfileBiographyAreaCreateManyAreaInputEnvelope = {
    data: ProfileBiographyAreaCreateManyAreaInput | ProfileBiographyAreaCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type ProfileBiographyAreaUpsertWithWhereUniqueWithoutAreaInput = {
    where: ProfileBiographyAreaWhereUniqueInput
    update: XOR<ProfileBiographyAreaUpdateWithoutAreaInput, ProfileBiographyAreaUncheckedUpdateWithoutAreaInput>
    create: XOR<ProfileBiographyAreaCreateWithoutAreaInput, ProfileBiographyAreaUncheckedCreateWithoutAreaInput>
  }

  export type ProfileBiographyAreaUpdateWithWhereUniqueWithoutAreaInput = {
    where: ProfileBiographyAreaWhereUniqueInput
    data: XOR<ProfileBiographyAreaUpdateWithoutAreaInput, ProfileBiographyAreaUncheckedUpdateWithoutAreaInput>
  }

  export type ProfileBiographyAreaUpdateManyWithWhereWithoutAreaInput = {
    where: ProfileBiographyAreaScalarWhereInput
    data: XOR<ProfileBiographyAreaUpdateManyMutationInput, ProfileBiographyAreaUncheckedUpdateManyWithoutAreaInput>
  }

  export type ProfileBiographyAreaScalarWhereInput = {
    AND?: ProfileBiographyAreaScalarWhereInput | ProfileBiographyAreaScalarWhereInput[]
    OR?: ProfileBiographyAreaScalarWhereInput[]
    NOT?: ProfileBiographyAreaScalarWhereInput | ProfileBiographyAreaScalarWhereInput[]
    id?: StringFilter<"ProfileBiographyArea"> | string
    biographyId?: StringFilter<"ProfileBiographyArea"> | string
    areaId?: StringFilter<"ProfileBiographyArea"> | string
    createdAt?: DateTimeFilter<"ProfileBiographyArea"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBiographyArea"> | Date | string
  }

  export type ProfileCreateWithoutBiographyInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutBiographyInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutBiographyInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutBiographyInput, ProfileUncheckedCreateWithoutBiographyInput>
  }

  export type ProfileBiographyAreaCreateWithoutBiographyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    area: AreaCreateNestedOneWithoutBiographiesInput
  }

  export type ProfileBiographyAreaUncheckedCreateWithoutBiographyInput = {
    id?: string
    areaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographyAreaCreateOrConnectWithoutBiographyInput = {
    where: ProfileBiographyAreaWhereUniqueInput
    create: XOR<ProfileBiographyAreaCreateWithoutBiographyInput, ProfileBiographyAreaUncheckedCreateWithoutBiographyInput>
  }

  export type ProfileBiographyAreaCreateManyBiographyInputEnvelope = {
    data: ProfileBiographyAreaCreateManyBiographyInput | ProfileBiographyAreaCreateManyBiographyInput[]
    skipDuplicates?: boolean
  }

  export type ProfileBiographySocialCreateWithoutProfileBiographyInput = {
    id?: string
    type: $Enums.SocialType
    href: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput = {
    id?: string
    type: $Enums.SocialType
    href: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographySocialCreateOrConnectWithoutProfileBiographyInput = {
    where: ProfileBiographySocialWhereUniqueInput
    create: XOR<ProfileBiographySocialCreateWithoutProfileBiographyInput, ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput>
  }

  export type ProfileBiographySocialCreateManyProfileBiographyInputEnvelope = {
    data: ProfileBiographySocialCreateManyProfileBiographyInput | ProfileBiographySocialCreateManyProfileBiographyInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutBiographyInput = {
    update: XOR<ProfileUpdateWithoutBiographyInput, ProfileUncheckedUpdateWithoutBiographyInput>
    create: XOR<ProfileCreateWithoutBiographyInput, ProfileUncheckedCreateWithoutBiographyInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutBiographyInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutBiographyInput, ProfileUncheckedUpdateWithoutBiographyInput>
  }

  export type ProfileUpdateWithoutBiographyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutBiographyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileBiographyAreaUpsertWithWhereUniqueWithoutBiographyInput = {
    where: ProfileBiographyAreaWhereUniqueInput
    update: XOR<ProfileBiographyAreaUpdateWithoutBiographyInput, ProfileBiographyAreaUncheckedUpdateWithoutBiographyInput>
    create: XOR<ProfileBiographyAreaCreateWithoutBiographyInput, ProfileBiographyAreaUncheckedCreateWithoutBiographyInput>
  }

  export type ProfileBiographyAreaUpdateWithWhereUniqueWithoutBiographyInput = {
    where: ProfileBiographyAreaWhereUniqueInput
    data: XOR<ProfileBiographyAreaUpdateWithoutBiographyInput, ProfileBiographyAreaUncheckedUpdateWithoutBiographyInput>
  }

  export type ProfileBiographyAreaUpdateManyWithWhereWithoutBiographyInput = {
    where: ProfileBiographyAreaScalarWhereInput
    data: XOR<ProfileBiographyAreaUpdateManyMutationInput, ProfileBiographyAreaUncheckedUpdateManyWithoutBiographyInput>
  }

  export type ProfileBiographySocialUpsertWithWhereUniqueWithoutProfileBiographyInput = {
    where: ProfileBiographySocialWhereUniqueInput
    update: XOR<ProfileBiographySocialUpdateWithoutProfileBiographyInput, ProfileBiographySocialUncheckedUpdateWithoutProfileBiographyInput>
    create: XOR<ProfileBiographySocialCreateWithoutProfileBiographyInput, ProfileBiographySocialUncheckedCreateWithoutProfileBiographyInput>
  }

  export type ProfileBiographySocialUpdateWithWhereUniqueWithoutProfileBiographyInput = {
    where: ProfileBiographySocialWhereUniqueInput
    data: XOR<ProfileBiographySocialUpdateWithoutProfileBiographyInput, ProfileBiographySocialUncheckedUpdateWithoutProfileBiographyInput>
  }

  export type ProfileBiographySocialUpdateManyWithWhereWithoutProfileBiographyInput = {
    where: ProfileBiographySocialScalarWhereInput
    data: XOR<ProfileBiographySocialUpdateManyMutationInput, ProfileBiographySocialUncheckedUpdateManyWithoutProfileBiographyInput>
  }

  export type ProfileBiographySocialScalarWhereInput = {
    AND?: ProfileBiographySocialScalarWhereInput | ProfileBiographySocialScalarWhereInput[]
    OR?: ProfileBiographySocialScalarWhereInput[]
    NOT?: ProfileBiographySocialScalarWhereInput | ProfileBiographySocialScalarWhereInput[]
    id?: StringFilter<"ProfileBiographySocial"> | string
    type?: EnumSocialTypeFilter<"ProfileBiographySocial"> | $Enums.SocialType
    href?: StringFilter<"ProfileBiographySocial"> | string
    profileBiographyId?: StringFilter<"ProfileBiographySocial"> | string
    createdAt?: DateTimeFilter<"ProfileBiographySocial"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileBiographySocial"> | Date | string
  }

  export type ProfileBiographyCreateWithoutAreasInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutBiographyInput
    socials?: ProfileBiographySocialCreateNestedManyWithoutProfileBiographyInput
  }

  export type ProfileBiographyUncheckedCreateWithoutAreasInput = {
    id?: string
    content: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    socials?: ProfileBiographySocialUncheckedCreateNestedManyWithoutProfileBiographyInput
  }

  export type ProfileBiographyCreateOrConnectWithoutAreasInput = {
    where: ProfileBiographyWhereUniqueInput
    create: XOR<ProfileBiographyCreateWithoutAreasInput, ProfileBiographyUncheckedCreateWithoutAreasInput>
  }

  export type AreaCreateWithoutBiographiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AreaUncheckedCreateWithoutBiographiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AreaCreateOrConnectWithoutBiographiesInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutBiographiesInput, AreaUncheckedCreateWithoutBiographiesInput>
  }

  export type ProfileBiographyUpsertWithoutAreasInput = {
    update: XOR<ProfileBiographyUpdateWithoutAreasInput, ProfileBiographyUncheckedUpdateWithoutAreasInput>
    create: XOR<ProfileBiographyCreateWithoutAreasInput, ProfileBiographyUncheckedCreateWithoutAreasInput>
    where?: ProfileBiographyWhereInput
  }

  export type ProfileBiographyUpdateToOneWithWhereWithoutAreasInput = {
    where?: ProfileBiographyWhereInput
    data: XOR<ProfileBiographyUpdateWithoutAreasInput, ProfileBiographyUncheckedUpdateWithoutAreasInput>
  }

  export type ProfileBiographyUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutBiographyNestedInput
    socials?: ProfileBiographySocialUpdateManyWithoutProfileBiographyNestedInput
  }

  export type ProfileBiographyUncheckedUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socials?: ProfileBiographySocialUncheckedUpdateManyWithoutProfileBiographyNestedInput
  }

  export type AreaUpsertWithoutBiographiesInput = {
    update: XOR<AreaUpdateWithoutBiographiesInput, AreaUncheckedUpdateWithoutBiographiesInput>
    create: XOR<AreaCreateWithoutBiographiesInput, AreaUncheckedCreateWithoutBiographiesInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutBiographiesInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutBiographiesInput, AreaUncheckedUpdateWithoutBiographiesInput>
  }

  export type AreaUpdateWithoutBiographiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaUncheckedUpdateWithoutBiographiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographyCreateWithoutSocialsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutBiographyInput
    areas?: ProfileBiographyAreaCreateNestedManyWithoutBiographyInput
  }

  export type ProfileBiographyUncheckedCreateWithoutSocialsInput = {
    id?: string
    content: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    areas?: ProfileBiographyAreaUncheckedCreateNestedManyWithoutBiographyInput
  }

  export type ProfileBiographyCreateOrConnectWithoutSocialsInput = {
    where: ProfileBiographyWhereUniqueInput
    create: XOR<ProfileBiographyCreateWithoutSocialsInput, ProfileBiographyUncheckedCreateWithoutSocialsInput>
  }

  export type ProfileBiographyUpsertWithoutSocialsInput = {
    update: XOR<ProfileBiographyUpdateWithoutSocialsInput, ProfileBiographyUncheckedUpdateWithoutSocialsInput>
    create: XOR<ProfileBiographyCreateWithoutSocialsInput, ProfileBiographyUncheckedCreateWithoutSocialsInput>
    where?: ProfileBiographyWhereInput
  }

  export type ProfileBiographyUpdateToOneWithWhereWithoutSocialsInput = {
    where?: ProfileBiographyWhereInput
    data: XOR<ProfileBiographyUpdateWithoutSocialsInput, ProfileBiographyUncheckedUpdateWithoutSocialsInput>
  }

  export type ProfileBiographyUpdateWithoutSocialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutBiographyNestedInput
    areas?: ProfileBiographyAreaUpdateManyWithoutBiographyNestedInput
  }

  export type ProfileBiographyUncheckedUpdateWithoutSocialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areas?: ProfileBiographyAreaUncheckedUpdateManyWithoutBiographyNestedInput
  }

  export type ProfileBlogImageCreateWithoutProfileBlogInput = {
    id?: string
    url: string
  }

  export type ProfileBlogImageUncheckedCreateWithoutProfileBlogInput = {
    id?: string
    url: string
  }

  export type ProfileBlogImageCreateOrConnectWithoutProfileBlogInput = {
    where: ProfileBlogImageWhereUniqueInput
    create: XOR<ProfileBlogImageCreateWithoutProfileBlogInput, ProfileBlogImageUncheckedCreateWithoutProfileBlogInput>
  }

  export type ProfileBlogImageCreateManyProfileBlogInputEnvelope = {
    data: ProfileBlogImageCreateManyProfileBlogInput | ProfileBlogImageCreateManyProfileBlogInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutBlogsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutBlogsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutBlogsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutBlogsInput, ProfileUncheckedCreateWithoutBlogsInput>
  }

  export type ProfileBlogImageUpsertWithWhereUniqueWithoutProfileBlogInput = {
    where: ProfileBlogImageWhereUniqueInput
    update: XOR<ProfileBlogImageUpdateWithoutProfileBlogInput, ProfileBlogImageUncheckedUpdateWithoutProfileBlogInput>
    create: XOR<ProfileBlogImageCreateWithoutProfileBlogInput, ProfileBlogImageUncheckedCreateWithoutProfileBlogInput>
  }

  export type ProfileBlogImageUpdateWithWhereUniqueWithoutProfileBlogInput = {
    where: ProfileBlogImageWhereUniqueInput
    data: XOR<ProfileBlogImageUpdateWithoutProfileBlogInput, ProfileBlogImageUncheckedUpdateWithoutProfileBlogInput>
  }

  export type ProfileBlogImageUpdateManyWithWhereWithoutProfileBlogInput = {
    where: ProfileBlogImageScalarWhereInput
    data: XOR<ProfileBlogImageUpdateManyMutationInput, ProfileBlogImageUncheckedUpdateManyWithoutProfileBlogInput>
  }

  export type ProfileBlogImageScalarWhereInput = {
    AND?: ProfileBlogImageScalarWhereInput | ProfileBlogImageScalarWhereInput[]
    OR?: ProfileBlogImageScalarWhereInput[]
    NOT?: ProfileBlogImageScalarWhereInput | ProfileBlogImageScalarWhereInput[]
    id?: StringFilter<"ProfileBlogImage"> | string
    url?: StringFilter<"ProfileBlogImage"> | string
    profileBlogId?: StringFilter<"ProfileBlogImage"> | string
  }

  export type ProfileUpsertWithoutBlogsInput = {
    update: XOR<ProfileUpdateWithoutBlogsInput, ProfileUncheckedUpdateWithoutBlogsInput>
    create: XOR<ProfileCreateWithoutBlogsInput, ProfileUncheckedCreateWithoutBlogsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutBlogsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutBlogsInput, ProfileUncheckedUpdateWithoutBlogsInput>
  }

  export type ProfileUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileBlogCreateWithoutImagesInput = {
    id?: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutBlogsInput
  }

  export type ProfileBlogUncheckedCreateWithoutImagesInput = {
    id?: string
    title: string
    content?: string | null
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBlogCreateOrConnectWithoutImagesInput = {
    where: ProfileBlogWhereUniqueInput
    create: XOR<ProfileBlogCreateWithoutImagesInput, ProfileBlogUncheckedCreateWithoutImagesInput>
  }

  export type ProfileBlogUpsertWithoutImagesInput = {
    update: XOR<ProfileBlogUpdateWithoutImagesInput, ProfileBlogUncheckedUpdateWithoutImagesInput>
    create: XOR<ProfileBlogCreateWithoutImagesInput, ProfileBlogUncheckedCreateWithoutImagesInput>
    where?: ProfileBlogWhereInput
  }

  export type ProfileBlogUpdateToOneWithWhereWithoutImagesInput = {
    where?: ProfileBlogWhereInput
    data: XOR<ProfileBlogUpdateWithoutImagesInput, ProfileBlogUncheckedUpdateWithoutImagesInput>
  }

  export type ProfileBlogUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutBlogsNestedInput
  }

  export type ProfileBlogUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateWithoutPostsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPostsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPostsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
  }

  export type PostImageCreateWithoutPostInput = {
    id?: string
    url: string
  }

  export type PostImageUncheckedCreateWithoutPostInput = {
    id?: string
    url: string
  }

  export type PostImageCreateOrConnectWithoutPostInput = {
    where: PostImageWhereUniqueInput
    create: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput>
  }

  export type PostImageCreateManyPostInputEnvelope = {
    data: PostImageCreateManyPostInput | PostImageCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostCommentCreateWithoutPostInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostCommentsInput
    parentComment?: PostCommentCreateNestedOneWithoutChildrenInput
    children?: PostCommentCreateNestedManyWithoutParentCommentInput
    likes?: PostCommentLikeCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentUncheckedCreateWithoutPostInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    profileId: string
    parentCommentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostCommentUncheckedCreateNestedManyWithoutParentCommentInput
    likes?: PostCommentLikeUncheckedCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentCreateOrConnectWithoutPostInput = {
    where: PostCommentWhereUniqueInput
    create: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
  }

  export type PostCommentCreateManyPostInputEnvelope = {
    data: PostCommentCreateManyPostInput | PostCommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostLikeCreateWithoutPostInput = {
    id?: string
    profile: ProfileCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateWithoutPostInput = {
    id?: string
    profileId: string
  }

  export type PostLikeCreateOrConnectWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeCreateManyPostInputEnvelope = {
    data: PostLikeCreateManyPostInput | PostLikeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostShareCreateWithoutPostInput = {
    id?: string
    profile: ProfileCreateNestedOneWithoutPostSharesInput
  }

  export type PostShareUncheckedCreateWithoutPostInput = {
    id?: string
    profileId: string
  }

  export type PostShareCreateOrConnectWithoutPostInput = {
    where: PostShareWhereUniqueInput
    create: XOR<PostShareCreateWithoutPostInput, PostShareUncheckedCreateWithoutPostInput>
  }

  export type PostShareCreateManyPostInputEnvelope = {
    data: PostShareCreateManyPostInput | PostShareCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostSaveCreateWithoutPostInput = {
    id?: string
    profile: ProfileCreateNestedOneWithoutPostSavedInput
  }

  export type PostSaveUncheckedCreateWithoutPostInput = {
    id?: string
    profileId: string
  }

  export type PostSaveCreateOrConnectWithoutPostInput = {
    where: PostSaveWhereUniqueInput
    create: XOR<PostSaveCreateWithoutPostInput, PostSaveUncheckedCreateWithoutPostInput>
  }

  export type PostSaveCreateManyPostInputEnvelope = {
    data: PostSaveCreateManyPostInput | PostSaveCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutPostsInput = {
    update: XOR<ProfileUpdateWithoutPostsInput, ProfileUncheckedUpdateWithoutPostsInput>
    create: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostsInput, ProfileUncheckedUpdateWithoutPostsInput>
  }

  export type ProfileUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type PostImageUpsertWithWhereUniqueWithoutPostInput = {
    where: PostImageWhereUniqueInput
    update: XOR<PostImageUpdateWithoutPostInput, PostImageUncheckedUpdateWithoutPostInput>
    create: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput>
  }

  export type PostImageUpdateWithWhereUniqueWithoutPostInput = {
    where: PostImageWhereUniqueInput
    data: XOR<PostImageUpdateWithoutPostInput, PostImageUncheckedUpdateWithoutPostInput>
  }

  export type PostImageUpdateManyWithWhereWithoutPostInput = {
    where: PostImageScalarWhereInput
    data: XOR<PostImageUpdateManyMutationInput, PostImageUncheckedUpdateManyWithoutPostInput>
  }

  export type PostImageScalarWhereInput = {
    AND?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
    OR?: PostImageScalarWhereInput[]
    NOT?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
    id?: StringFilter<"PostImage"> | string
    url?: StringFilter<"PostImage"> | string
    postId?: StringFilter<"PostImage"> | string
  }

  export type PostCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: PostCommentWhereUniqueInput
    update: XOR<PostCommentUpdateWithoutPostInput, PostCommentUncheckedUpdateWithoutPostInput>
    create: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
  }

  export type PostCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: PostCommentWhereUniqueInput
    data: XOR<PostCommentUpdateWithoutPostInput, PostCommentUncheckedUpdateWithoutPostInput>
  }

  export type PostCommentUpdateManyWithWhereWithoutPostInput = {
    where: PostCommentScalarWhereInput
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostLikeUpsertWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutPostInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutPostInput>
  }

  export type PostShareUpsertWithWhereUniqueWithoutPostInput = {
    where: PostShareWhereUniqueInput
    update: XOR<PostShareUpdateWithoutPostInput, PostShareUncheckedUpdateWithoutPostInput>
    create: XOR<PostShareCreateWithoutPostInput, PostShareUncheckedCreateWithoutPostInput>
  }

  export type PostShareUpdateWithWhereUniqueWithoutPostInput = {
    where: PostShareWhereUniqueInput
    data: XOR<PostShareUpdateWithoutPostInput, PostShareUncheckedUpdateWithoutPostInput>
  }

  export type PostShareUpdateManyWithWhereWithoutPostInput = {
    where: PostShareScalarWhereInput
    data: XOR<PostShareUpdateManyMutationInput, PostShareUncheckedUpdateManyWithoutPostInput>
  }

  export type PostSaveUpsertWithWhereUniqueWithoutPostInput = {
    where: PostSaveWhereUniqueInput
    update: XOR<PostSaveUpdateWithoutPostInput, PostSaveUncheckedUpdateWithoutPostInput>
    create: XOR<PostSaveCreateWithoutPostInput, PostSaveUncheckedCreateWithoutPostInput>
  }

  export type PostSaveUpdateWithWhereUniqueWithoutPostInput = {
    where: PostSaveWhereUniqueInput
    data: XOR<PostSaveUpdateWithoutPostInput, PostSaveUncheckedUpdateWithoutPostInput>
  }

  export type PostSaveUpdateManyWithWhereWithoutPostInput = {
    where: PostSaveScalarWhereInput
    data: XOR<PostSaveUpdateManyMutationInput, PostSaveUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutImagesInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostsInput
    comments?: PostCommentCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
    shares?: PostShareCreateNestedManyWithoutPostInput
    saves?: PostSaveCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutImagesInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    shares?: PostShareUncheckedCreateNestedManyWithoutPostInput
    saves?: PostSaveUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutImagesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
  }

  export type PostUpsertWithoutImagesInput = {
    update: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutImagesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
  }

  export type PostUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    comments?: PostCommentUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
    shares?: PostShareUpdateManyWithoutPostNestedInput
    saves?: PostSaveUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    shares?: PostShareUncheckedUpdateManyWithoutPostNestedInput
    saves?: PostSaveUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ProfileCreateWithoutPostLikesInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPostLikesInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPostLikesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostLikesInput, ProfileUncheckedCreateWithoutPostLikesInput>
  }

  export type PostCreateWithoutLikesInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostsInput
    images?: PostImageCreateNestedManyWithoutPostInput
    comments?: PostCommentCreateNestedManyWithoutPostInput
    shares?: PostShareCreateNestedManyWithoutPostInput
    saves?: PostSaveCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutLikesInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
    shares?: PostShareUncheckedCreateNestedManyWithoutPostInput
    saves?: PostSaveUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutLikesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
  }

  export type ProfileUpsertWithoutPostLikesInput = {
    update: XOR<ProfileUpdateWithoutPostLikesInput, ProfileUncheckedUpdateWithoutPostLikesInput>
    create: XOR<ProfileCreateWithoutPostLikesInput, ProfileUncheckedCreateWithoutPostLikesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostLikesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostLikesInput, ProfileUncheckedUpdateWithoutPostLikesInput>
  }

  export type ProfileUpdateWithoutPostLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type PostUpsertWithoutLikesInput = {
    update: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
  }

  export type PostUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    comments?: PostCommentUpdateManyWithoutPostNestedInput
    shares?: PostShareUpdateManyWithoutPostNestedInput
    saves?: PostSaveUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
    shares?: PostShareUncheckedUpdateManyWithoutPostNestedInput
    saves?: PostSaveUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ProfileCreateWithoutPostSharesInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPostSharesInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPostSharesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostSharesInput, ProfileUncheckedCreateWithoutPostSharesInput>
  }

  export type PostCreateWithoutSharesInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostsInput
    images?: PostImageCreateNestedManyWithoutPostInput
    comments?: PostCommentCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
    saves?: PostSaveCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutSharesInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    saves?: PostSaveUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutSharesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutSharesInput, PostUncheckedCreateWithoutSharesInput>
  }

  export type ProfileUpsertWithoutPostSharesInput = {
    update: XOR<ProfileUpdateWithoutPostSharesInput, ProfileUncheckedUpdateWithoutPostSharesInput>
    create: XOR<ProfileCreateWithoutPostSharesInput, ProfileUncheckedCreateWithoutPostSharesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostSharesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostSharesInput, ProfileUncheckedUpdateWithoutPostSharesInput>
  }

  export type ProfileUpdateWithoutPostSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type PostUpsertWithoutSharesInput = {
    update: XOR<PostUpdateWithoutSharesInput, PostUncheckedUpdateWithoutSharesInput>
    create: XOR<PostCreateWithoutSharesInput, PostUncheckedCreateWithoutSharesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutSharesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutSharesInput, PostUncheckedUpdateWithoutSharesInput>
  }

  export type PostUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    comments?: PostCommentUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
    saves?: PostSaveUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    saves?: PostSaveUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ProfileCreateWithoutPostSavedInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPostSavedInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPostSavedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostSavedInput, ProfileUncheckedCreateWithoutPostSavedInput>
  }

  export type PostCreateWithoutSavesInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostsInput
    images?: PostImageCreateNestedManyWithoutPostInput
    comments?: PostCommentCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
    shares?: PostShareCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutSavesInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    shares?: PostShareUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutSavesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutSavesInput, PostUncheckedCreateWithoutSavesInput>
  }

  export type ProfileUpsertWithoutPostSavedInput = {
    update: XOR<ProfileUpdateWithoutPostSavedInput, ProfileUncheckedUpdateWithoutPostSavedInput>
    create: XOR<ProfileCreateWithoutPostSavedInput, ProfileUncheckedCreateWithoutPostSavedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostSavedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostSavedInput, ProfileUncheckedUpdateWithoutPostSavedInput>
  }

  export type ProfileUpdateWithoutPostSavedInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostSavedInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type PostUpsertWithoutSavesInput = {
    update: XOR<PostUpdateWithoutSavesInput, PostUncheckedUpdateWithoutSavesInput>
    create: XOR<PostCreateWithoutSavesInput, PostUncheckedCreateWithoutSavesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutSavesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutSavesInput, PostUncheckedUpdateWithoutSavesInput>
  }

  export type PostUpdateWithoutSavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    comments?: PostCommentUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
    shares?: PostShareUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutSavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    shares?: PostShareUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ProfileCreateWithoutPostCommentsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPostCommentsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPostCommentsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostCommentsInput, ProfileUncheckedCreateWithoutPostCommentsInput>
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostsInput
    images?: PostImageCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
    shares?: PostShareCreateNestedManyWithoutPostInput
    saves?: PostSaveCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    shares?: PostShareUncheckedCreateNestedManyWithoutPostInput
    saves?: PostSaveUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type PostCommentCreateWithoutChildrenInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostCommentsInput
    post: PostCreateNestedOneWithoutCommentsInput
    parentComment?: PostCommentCreateNestedOneWithoutChildrenInput
    likes?: PostCommentLikeCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentUncheckedCreateWithoutChildrenInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    profileId: string
    postId: string
    parentCommentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: PostCommentLikeUncheckedCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentCreateOrConnectWithoutChildrenInput = {
    where: PostCommentWhereUniqueInput
    create: XOR<PostCommentCreateWithoutChildrenInput, PostCommentUncheckedCreateWithoutChildrenInput>
  }

  export type PostCommentCreateWithoutParentCommentInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostCommentsInput
    post: PostCreateNestedOneWithoutCommentsInput
    children?: PostCommentCreateNestedManyWithoutParentCommentInput
    likes?: PostCommentLikeCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentUncheckedCreateWithoutParentCommentInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    profileId: string
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostCommentUncheckedCreateNestedManyWithoutParentCommentInput
    likes?: PostCommentLikeUncheckedCreateNestedManyWithoutPostCommentInput
  }

  export type PostCommentCreateOrConnectWithoutParentCommentInput = {
    where: PostCommentWhereUniqueInput
    create: XOR<PostCommentCreateWithoutParentCommentInput, PostCommentUncheckedCreateWithoutParentCommentInput>
  }

  export type PostCommentCreateManyParentCommentInputEnvelope = {
    data: PostCommentCreateManyParentCommentInput | PostCommentCreateManyParentCommentInput[]
    skipDuplicates?: boolean
  }

  export type PostCommentLikeCreateWithoutPostCommentInput = {
    id?: string
    profile: ProfileCreateNestedOneWithoutPostCommentLikesInput
  }

  export type PostCommentLikeUncheckedCreateWithoutPostCommentInput = {
    id?: string
    profileId: string
  }

  export type PostCommentLikeCreateOrConnectWithoutPostCommentInput = {
    where: PostCommentLikeWhereUniqueInput
    create: XOR<PostCommentLikeCreateWithoutPostCommentInput, PostCommentLikeUncheckedCreateWithoutPostCommentInput>
  }

  export type PostCommentLikeCreateManyPostCommentInputEnvelope = {
    data: PostCommentLikeCreateManyPostCommentInput | PostCommentLikeCreateManyPostCommentInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutPostCommentsInput = {
    update: XOR<ProfileUpdateWithoutPostCommentsInput, ProfileUncheckedUpdateWithoutPostCommentsInput>
    create: XOR<ProfileCreateWithoutPostCommentsInput, ProfileUncheckedCreateWithoutPostCommentsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostCommentsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostCommentsInput, ProfileUncheckedUpdateWithoutPostCommentsInput>
  }

  export type ProfileUpdateWithoutPostCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
    shares?: PostShareUpdateManyWithoutPostNestedInput
    saves?: PostSaveUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    shares?: PostShareUncheckedUpdateManyWithoutPostNestedInput
    saves?: PostSaveUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCommentUpsertWithoutChildrenInput = {
    update: XOR<PostCommentUpdateWithoutChildrenInput, PostCommentUncheckedUpdateWithoutChildrenInput>
    create: XOR<PostCommentCreateWithoutChildrenInput, PostCommentUncheckedCreateWithoutChildrenInput>
    where?: PostCommentWhereInput
  }

  export type PostCommentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: PostCommentWhereInput
    data: XOR<PostCommentUpdateWithoutChildrenInput, PostCommentUncheckedUpdateWithoutChildrenInput>
  }

  export type PostCommentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostCommentsNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: PostCommentUpdateOneWithoutChildrenNestedInput
    likes?: PostCommentLikeUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: PostCommentLikeUncheckedUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: PostCommentWhereUniqueInput
    update: XOR<PostCommentUpdateWithoutParentCommentInput, PostCommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<PostCommentCreateWithoutParentCommentInput, PostCommentUncheckedCreateWithoutParentCommentInput>
  }

  export type PostCommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: PostCommentWhereUniqueInput
    data: XOR<PostCommentUpdateWithoutParentCommentInput, PostCommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type PostCommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: PostCommentScalarWhereInput
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyWithoutParentCommentInput>
  }

  export type PostCommentLikeUpsertWithWhereUniqueWithoutPostCommentInput = {
    where: PostCommentLikeWhereUniqueInput
    update: XOR<PostCommentLikeUpdateWithoutPostCommentInput, PostCommentLikeUncheckedUpdateWithoutPostCommentInput>
    create: XOR<PostCommentLikeCreateWithoutPostCommentInput, PostCommentLikeUncheckedCreateWithoutPostCommentInput>
  }

  export type PostCommentLikeUpdateWithWhereUniqueWithoutPostCommentInput = {
    where: PostCommentLikeWhereUniqueInput
    data: XOR<PostCommentLikeUpdateWithoutPostCommentInput, PostCommentLikeUncheckedUpdateWithoutPostCommentInput>
  }

  export type PostCommentLikeUpdateManyWithWhereWithoutPostCommentInput = {
    where: PostCommentLikeScalarWhereInput
    data: XOR<PostCommentLikeUpdateManyMutationInput, PostCommentLikeUncheckedUpdateManyWithoutPostCommentInput>
  }

  export type ProfileCreateWithoutPostCommentLikesInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPostCommentLikesInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPostCommentLikesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostCommentLikesInput, ProfileUncheckedCreateWithoutPostCommentLikesInput>
  }

  export type PostCommentCreateWithoutLikesInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostCommentsInput
    post: PostCreateNestedOneWithoutCommentsInput
    parentComment?: PostCommentCreateNestedOneWithoutChildrenInput
    children?: PostCommentCreateNestedManyWithoutParentCommentInput
  }

  export type PostCommentUncheckedCreateWithoutLikesInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    profileId: string
    postId: string
    parentCommentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type PostCommentCreateOrConnectWithoutLikesInput = {
    where: PostCommentWhereUniqueInput
    create: XOR<PostCommentCreateWithoutLikesInput, PostCommentUncheckedCreateWithoutLikesInput>
  }

  export type ProfileUpsertWithoutPostCommentLikesInput = {
    update: XOR<ProfileUpdateWithoutPostCommentLikesInput, ProfileUncheckedUpdateWithoutPostCommentLikesInput>
    create: XOR<ProfileCreateWithoutPostCommentLikesInput, ProfileUncheckedCreateWithoutPostCommentLikesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostCommentLikesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostCommentLikesInput, ProfileUncheckedUpdateWithoutPostCommentLikesInput>
  }

  export type ProfileUpdateWithoutPostCommentLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostCommentLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type PostCommentUpsertWithoutLikesInput = {
    update: XOR<PostCommentUpdateWithoutLikesInput, PostCommentUncheckedUpdateWithoutLikesInput>
    create: XOR<PostCommentCreateWithoutLikesInput, PostCommentUncheckedCreateWithoutLikesInput>
    where?: PostCommentWhereInput
  }

  export type PostCommentUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostCommentWhereInput
    data: XOR<PostCommentUpdateWithoutLikesInput, PostCommentUncheckedUpdateWithoutLikesInput>
  }

  export type PostCommentUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostCommentsNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: PostCommentUpdateOneWithoutChildrenNestedInput
    children?: PostCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type PostCommentUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type ProfileCreateWithoutOwnedGroupsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    groups?: ProfileGroupCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutOwnedGroupsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    groups?: ProfileGroupUncheckedCreateNestedManyWithoutProfileInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutOwnedGroupsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutOwnedGroupsInput, ProfileUncheckedCreateWithoutOwnedGroupsInput>
  }

  export type ProfileGroupCreateWithoutGroupInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutGroupsInput
  }

  export type ProfileGroupUncheckedCreateWithoutGroupInput = {
    id?: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileGroupCreateOrConnectWithoutGroupInput = {
    where: ProfileGroupWhereUniqueInput
    create: XOR<ProfileGroupCreateWithoutGroupInput, ProfileGroupUncheckedCreateWithoutGroupInput>
  }

  export type ProfileGroupCreateManyGroupInputEnvelope = {
    data: ProfileGroupCreateManyGroupInput | ProfileGroupCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutOwnedGroupsInput = {
    update: XOR<ProfileUpdateWithoutOwnedGroupsInput, ProfileUncheckedUpdateWithoutOwnedGroupsInput>
    create: XOR<ProfileCreateWithoutOwnedGroupsInput, ProfileUncheckedCreateWithoutOwnedGroupsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutOwnedGroupsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutOwnedGroupsInput, ProfileUncheckedUpdateWithoutOwnedGroupsInput>
  }

  export type ProfileUpdateWithoutOwnedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    groups?: ProfileGroupUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutOwnedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    groups?: ProfileGroupUncheckedUpdateManyWithoutProfileNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileGroupUpsertWithWhereUniqueWithoutGroupInput = {
    where: ProfileGroupWhereUniqueInput
    update: XOR<ProfileGroupUpdateWithoutGroupInput, ProfileGroupUncheckedUpdateWithoutGroupInput>
    create: XOR<ProfileGroupCreateWithoutGroupInput, ProfileGroupUncheckedCreateWithoutGroupInput>
  }

  export type ProfileGroupUpdateWithWhereUniqueWithoutGroupInput = {
    where: ProfileGroupWhereUniqueInput
    data: XOR<ProfileGroupUpdateWithoutGroupInput, ProfileGroupUncheckedUpdateWithoutGroupInput>
  }

  export type ProfileGroupUpdateManyWithWhereWithoutGroupInput = {
    where: ProfileGroupScalarWhereInput
    data: XOR<ProfileGroupUpdateManyMutationInput, ProfileGroupUncheckedUpdateManyWithoutGroupInput>
  }

  export type ProfileCreateWithoutGroupsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
    hostedEvents?: EventCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileCreateNestedManyWithoutProfileInput
    posts?: PostCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    blogs?: ProfileBlogCreateNestedManyWithoutProfileInput
    postComments?: PostCommentCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeCreateNestedManyWithoutProfileInput
    postShares?: PostShareCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutGroupsInput = {
    id?: string
    status?: $Enums.ProfileStatus
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    hostedEvents?: EventUncheckedCreateNestedManyWithoutHostInput
    participatedEvents?: EventProfileUncheckedCreateNestedManyWithoutProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutProfileInput
    biography?: ProfileBiographyUncheckedCreateNestedOneWithoutProfileInput
    friendRequests?: ProfileFriendUncheckedCreateNestedManyWithoutProfileOneInput
    friendReceived?: ProfileFriendUncheckedCreateNestedManyWithoutProfileTwoInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    blogs?: ProfileBlogUncheckedCreateNestedManyWithoutProfileInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutProfileInput
    postCommentLikes?: PostCommentLikeUncheckedCreateNestedManyWithoutProfileInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutProfileInput
    postShares?: PostShareUncheckedCreateNestedManyWithoutProfileInput
    postSaved?: PostSaveUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutGroupsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutGroupsInput, ProfileUncheckedCreateWithoutGroupsInput>
  }

  export type GroupCreateWithoutProfilesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: ProfileCreateNestedOneWithoutOwnedGroupsInput
  }

  export type GroupUncheckedCreateWithoutProfilesInput = {
    id?: string
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupCreateOrConnectWithoutProfilesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutProfilesInput, GroupUncheckedCreateWithoutProfilesInput>
  }

  export type ProfileUpsertWithoutGroupsInput = {
    update: XOR<ProfileUpdateWithoutGroupsInput, ProfileUncheckedUpdateWithoutGroupsInput>
    create: XOR<ProfileCreateWithoutGroupsInput, ProfileUncheckedCreateWithoutGroupsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutGroupsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutGroupsInput, ProfileUncheckedUpdateWithoutGroupsInput>
  }

  export type ProfileUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
    hostedEvents?: EventUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUpdateManyWithoutProfileNestedInput
    posts?: PostUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    blogs?: ProfileBlogUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProfileStatusFieldUpdateOperationsInput | $Enums.ProfileStatus
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostedEvents?: EventUncheckedUpdateManyWithoutHostNestedInput
    participatedEvents?: EventProfileUncheckedUpdateManyWithoutProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutProfileNestedInput
    biography?: ProfileBiographyUncheckedUpdateOneWithoutProfileNestedInput
    friendRequests?: ProfileFriendUncheckedUpdateManyWithoutProfileOneNestedInput
    friendReceived?: ProfileFriendUncheckedUpdateManyWithoutProfileTwoNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    blogs?: ProfileBlogUncheckedUpdateManyWithoutProfileNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutProfileNestedInput
    postCommentLikes?: PostCommentLikeUncheckedUpdateManyWithoutProfileNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutProfileNestedInput
    postShares?: PostShareUncheckedUpdateManyWithoutProfileNestedInput
    postSaved?: PostSaveUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type GroupUpsertWithoutProfilesInput = {
    update: XOR<GroupUpdateWithoutProfilesInput, GroupUncheckedUpdateWithoutProfilesInput>
    create: XOR<GroupCreateWithoutProfilesInput, GroupUncheckedCreateWithoutProfilesInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutProfilesInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutProfilesInput, GroupUncheckedUpdateWithoutProfilesInput>
  }

  export type GroupUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: ProfileUpdateOneRequiredWithoutOwnedGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateWithoutNewsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipCreateNestedManyWithoutSchoolInput
    contacts?: ContactCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutNewsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationUncheckedCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramUncheckedCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryUncheckedCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipUncheckedCreateNestedManyWithoutSchoolInput
    contacts?: ContactUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutNewsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutNewsInput, SchoolUncheckedCreateWithoutNewsInput>
  }

  export type NewsNotificationCreateWithoutNewsInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutNotificationsInput
    fromStudent?: StudentCreateNestedOneWithoutOwnedNotificationsInput
  }

  export type NewsNotificationUncheckedCreateWithoutNewsInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    studentId: string
    fromId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsNotificationCreateOrConnectWithoutNewsInput = {
    where: NewsNotificationWhereUniqueInput
    create: XOR<NewsNotificationCreateWithoutNewsInput, NewsNotificationUncheckedCreateWithoutNewsInput>
  }

  export type NewsNotificationCreateManyNewsInputEnvelope = {
    data: NewsNotificationCreateManyNewsInput | NewsNotificationCreateManyNewsInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutNewsInput = {
    update: XOR<SchoolUpdateWithoutNewsInput, SchoolUncheckedUpdateWithoutNewsInput>
    create: XOR<SchoolCreateWithoutNewsInput, SchoolUncheckedCreateWithoutNewsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutNewsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutNewsInput, SchoolUncheckedUpdateWithoutNewsInput>
  }

  export type SchoolUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUncheckedUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUncheckedUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUncheckedUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUncheckedUpdateManyWithoutSchoolNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type NewsNotificationUpsertWithWhereUniqueWithoutNewsInput = {
    where: NewsNotificationWhereUniqueInput
    update: XOR<NewsNotificationUpdateWithoutNewsInput, NewsNotificationUncheckedUpdateWithoutNewsInput>
    create: XOR<NewsNotificationCreateWithoutNewsInput, NewsNotificationUncheckedCreateWithoutNewsInput>
  }

  export type NewsNotificationUpdateWithWhereUniqueWithoutNewsInput = {
    where: NewsNotificationWhereUniqueInput
    data: XOR<NewsNotificationUpdateWithoutNewsInput, NewsNotificationUncheckedUpdateWithoutNewsInput>
  }

  export type NewsNotificationUpdateManyWithWhereWithoutNewsInput = {
    where: NewsNotificationScalarWhereInput
    data: XOR<NewsNotificationUpdateManyMutationInput, NewsNotificationUncheckedUpdateManyWithoutNewsInput>
  }

  export type StudentCreateWithoutNotificationsInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutNotificationsInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutNotificationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
  }

  export type StudentCreateWithoutOwnedNotificationsInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutOwnedNotificationsInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutOwnedNotificationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutOwnedNotificationsInput, StudentUncheckedCreateWithoutOwnedNotificationsInput>
  }

  export type NewsCreateWithoutNotificationsInput = {
    id?: string
    title: string
    content?: string | null
    type: $Enums.NewsType
    cover: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutNotificationsInput = {
    id?: string
    title: string
    content?: string | null
    type: $Enums.NewsType
    cover: string
    isPublished?: boolean
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsCreateOrConnectWithoutNotificationsInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutNotificationsInput, NewsUncheckedCreateWithoutNotificationsInput>
  }

  export type StudentUpsertWithoutNotificationsInput = {
    update: XOR<StudentUpdateWithoutNotificationsInput, StudentUncheckedUpdateWithoutNotificationsInput>
    create: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutNotificationsInput, StudentUncheckedUpdateWithoutNotificationsInput>
  }

  export type StudentUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUpsertWithoutOwnedNotificationsInput = {
    update: XOR<StudentUpdateWithoutOwnedNotificationsInput, StudentUncheckedUpdateWithoutOwnedNotificationsInput>
    create: XOR<StudentCreateWithoutOwnedNotificationsInput, StudentUncheckedCreateWithoutOwnedNotificationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutOwnedNotificationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutOwnedNotificationsInput, StudentUncheckedUpdateWithoutOwnedNotificationsInput>
  }

  export type StudentUpdateWithoutOwnedNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutOwnedNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type NewsUpsertWithoutNotificationsInput = {
    update: XOR<NewsUpdateWithoutNotificationsInput, NewsUncheckedUpdateWithoutNotificationsInput>
    create: XOR<NewsCreateWithoutNotificationsInput, NewsUncheckedCreateWithoutNotificationsInput>
    where?: NewsWhereInput
  }

  export type NewsUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: NewsWhereInput
    data: XOR<NewsUpdateWithoutNotificationsInput, NewsUncheckedUpdateWithoutNotificationsInput>
  }

  export type NewsUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    cover?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    cover?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutFollowsInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    followers?: StudentFollowCreateNestedManyWithoutFollowerInput
  }

  export type StudentUncheckedCreateWithoutFollowsInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    followers?: StudentFollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type StudentCreateOrConnectWithoutFollowsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFollowsInput, StudentUncheckedCreateWithoutFollowsInput>
  }

  export type StudentCreateWithoutFollowersInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutStudentInput
    school: SchoolCreateNestedOneWithoutStudentsInput
    messeages?: MessageCreateNestedManyWithoutStudentInput
    chats?: ChatCreateNestedManyWithoutStudentsInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutFollowersInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messeages?: MessageUncheckedCreateNestedManyWithoutStudentInput
    chats?: ChatUncheckedCreateNestedManyWithoutStudentsInput
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    program?: StudentSchoolProgramUncheckedCreateNestedOneWithoutStudentInput
    location?: StudentSchoolLocationUncheckedCreateNestedOneWithoutStudentInput
    scholarship?: StudentSchoolScholarshipUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NewsNotificationUncheckedCreateNestedManyWithoutStudentInput
    ownedNotifications?: NewsNotificationUncheckedCreateNestedManyWithoutFromStudentInput
    follows?: StudentFollowUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFollowersInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFollowersInput, StudentUncheckedCreateWithoutFollowersInput>
  }

  export type StudentUpsertWithoutFollowsInput = {
    update: XOR<StudentUpdateWithoutFollowsInput, StudentUncheckedUpdateWithoutFollowsInput>
    create: XOR<StudentCreateWithoutFollowsInput, StudentUncheckedCreateWithoutFollowsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFollowsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFollowsInput, StudentUncheckedUpdateWithoutFollowsInput>
  }

  export type StudentUpdateWithoutFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUpsertWithoutFollowersInput = {
    update: XOR<StudentUpdateWithoutFollowersInput, StudentUncheckedUpdateWithoutFollowersInput>
    create: XOR<StudentCreateWithoutFollowersInput, StudentUncheckedCreateWithoutFollowersInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFollowersInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFollowersInput, StudentUncheckedUpdateWithoutFollowersInput>
  }

  export type StudentUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SchoolCreateWithoutContactsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipCreateNestedManyWithoutSchoolInput
    news?: NewsCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutContactsInput = {
    id?: string
    logo: string
    background: string
    name: string
    short?: string | null
    description?: string | null
    history?: string | null
    color: string
    isPublished?: boolean
    country: $Enums.Country
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutSchoolInput
    locations?: SchoolLocationUncheckedCreateNestedManyWithoutSchoolInput
    programs?: SchoolProgramUncheckedCreateNestedManyWithoutSchoolInput
    galleries?: SchoolGalleryUncheckedCreateNestedManyWithoutSchoolInput
    scholarships?: SchoolScholarshipUncheckedCreateNestedManyWithoutSchoolInput
    news?: NewsUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutContactsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutContactsInput, SchoolUncheckedCreateWithoutContactsInput>
  }

  export type SchoolUpsertWithoutContactsInput = {
    update: XOR<SchoolUpdateWithoutContactsInput, SchoolUncheckedUpdateWithoutContactsInput>
    create: XOR<SchoolCreateWithoutContactsInput, SchoolUncheckedCreateWithoutContactsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutContactsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutContactsInput, SchoolUncheckedUpdateWithoutContactsInput>
  }

  export type SchoolUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUpdateManyWithoutSchoolNestedInput
    news?: NewsUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    short?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    country?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutSchoolNestedInput
    locations?: SchoolLocationUncheckedUpdateManyWithoutSchoolNestedInput
    programs?: SchoolProgramUncheckedUpdateManyWithoutSchoolNestedInput
    galleries?: SchoolGalleryUncheckedUpdateManyWithoutSchoolNestedInput
    scholarships?: SchoolScholarshipUncheckedUpdateManyWithoutSchoolNestedInput
    news?: NewsUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type StudentCreateManySchoolInput = {
    id?: string
    studentCode?: string | null
    degreeType: $Enums.DegreeType
    certificateType: $Enums.CertificateType
    certificateImg: string
    gradeType: $Enums.GradeType
    gradeScore: number
    cover?: string | null
    additional?: string | null
    status?: $Enums.StudentStatus
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolLocationCreateManySchoolInput = {
    id?: string
    cover?: string | null
    name: string
    address: string
    isMain?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolProgramCreateManySchoolInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolGalleryCreateManySchoolInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolScholarshipCreateManySchoolInput = {
    id?: string
    name: string
    description: string
    cover?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsCreateManySchoolInput = {
    id?: string
    title: string
    content?: string | null
    type: $Enums.NewsType
    cover: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManySchoolInput = {
    id?: string
    name: string
    title: $Enums.ContactTitle
    phone: string
    email: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    chats?: ChatUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    chats?: ChatUncheckedUpdateManyWithoutStudentsNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLocationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolLocationImageUpdateManyWithoutLocationNestedInput
    contacts?: SchoolLocationContactUpdateManyWithoutLocationNestedInput
    students?: StudentSchoolLocationUpdateManyWithoutLocationNestedInput
  }

  export type SchoolLocationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolLocationImageUncheckedUpdateManyWithoutLocationNestedInput
    contacts?: SchoolLocationContactUncheckedUpdateManyWithoutLocationNestedInput
    students?: StudentSchoolLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type SchoolLocationUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolProgramUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentSchoolProgramUpdateManyWithoutProgramNestedInput
    images?: SchoolProgramImageUpdateManyWithoutProgramNestedInput
  }

  export type SchoolProgramUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentPrograms?: StudentSchoolProgramUncheckedUpdateManyWithoutProgramNestedInput
    images?: SchoolProgramImageUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type SchoolProgramUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolGalleryUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolGalleryImageUpdateManyWithoutGalleryNestedInput
  }

  export type SchoolGalleryUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: SchoolGalleryImageUncheckedUpdateManyWithoutGalleryNestedInput
  }

  export type SchoolGalleryUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolScholarshipUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: StudentSchoolScholarshipUpdateManyWithoutScholarshipNestedInput
    images?: SchoolScholarshipImageUpdateManyWithoutScholarshipNestedInput
  }

  export type SchoolScholarshipUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: StudentSchoolScholarshipUncheckedUpdateManyWithoutScholarshipNestedInput
    images?: SchoolScholarshipImageUncheckedUpdateManyWithoutScholarshipNestedInput
  }

  export type SchoolScholarshipUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    cover?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NewsNotificationUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    cover?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NewsNotificationUncheckedUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    cover?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: EnumContactTitleFieldUpdateOperationsInput | $Enums.ContactTitle
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: EnumContactTitleFieldUpdateOperationsInput | $Enums.ContactTitle
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: EnumContactTitleFieldUpdateOperationsInput | $Enums.ContactTitle
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolScholarshipCreateManyScholarshipInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolScholarshipImageCreateManyScholarshipInput = {
    id?: string
    url: string
  }

  export type StudentSchoolScholarshipUpdateWithoutScholarshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutScholarshipNestedInput
  }

  export type StudentSchoolScholarshipUncheckedUpdateWithoutScholarshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolScholarshipUncheckedUpdateManyWithoutScholarshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolScholarshipImageUpdateWithoutScholarshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolScholarshipImageUncheckedUpdateWithoutScholarshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolScholarshipImageUncheckedUpdateManyWithoutScholarshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolGalleryImageCreateManyGalleryInput = {
    id?: string
    url: string
  }

  export type SchoolGalleryImageUpdateWithoutGalleryInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolGalleryImageUncheckedUpdateWithoutGalleryInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolGalleryImageUncheckedUpdateManyWithoutGalleryInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolLocationImageCreateManyLocationInput = {
    id?: string
    url: string
  }

  export type SchoolLocationContactCreateManyLocationInput = {
    id?: string
    phone?: string | null
    hours?: string | null
    fax?: string | null
    email?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSchoolLocationCreateManyLocationInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolLocationImageUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolLocationImageUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolLocationImageUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolLocationContactUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLocationContactUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolLocationContactUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hours?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolLocationUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLocationNestedInput
  }

  export type StudentSchoolLocationUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolLocationUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolProgramCreateManyProgramInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolProgramImageCreateManyProgramInput = {
    id?: string
    url: string
  }

  export type StudentSchoolProgramUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProgramNestedInput
  }

  export type StudentSchoolProgramUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolProgramUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolProgramImageUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolProgramImageUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolProgramImageUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyStudentInput = {
    id?: string
    content: string
    createAt?: Date | string
    updateAt?: Date | string
    chatId: string
  }

  export type StudentSchoolScholarshipCreateManyStudentInput = {
    id?: string
    scholarshipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsNotificationCreateManyStudentInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    fromId?: string | null
    newsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsNotificationCreateManyFromStudentInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    studentId: string
    newsId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentFollowCreateManyStudentInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentFollowCreateManyFollowerInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessegesNestedInput
  }

  export type MessageUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeges?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeges?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    creatAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolScholarshipUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scholarship?: SchoolScholarshipUpdateOneRequiredWithoutOwnersNestedInput
  }

  export type StudentSchoolScholarshipUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    scholarshipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    scholarshipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsNotificationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromStudent?: StudentUpdateOneWithoutOwnedNotificationsNestedInput
    news?: NewsUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NewsNotificationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    fromId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsNotificationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    fromId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsNotificationUpdateWithoutFromStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutNotificationsNestedInput
    news?: NewsUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NewsNotificationUncheckedUpdateWithoutFromStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsNotificationUncheckedUpdateManyWithoutFromStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    newsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentFollowUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: StudentUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type StudentFollowUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentFollowUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentFollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFollowsNestedInput
  }

  export type StudentFollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentFollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyChatInput = {
    id?: string
    content: string
    createAt?: Date | string
    updateAt?: Date | string
    studentCode: string
  }

  export type MessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMesseagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutStudentNestedInput
    school?: SchoolUpdateOneRequiredWithoutStudentsNestedInput
    messeages?: MessageUpdateManyWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messeages?: MessageUncheckedUpdateManyWithoutStudentNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    program?: StudentSchoolProgramUncheckedUpdateOneWithoutStudentNestedInput
    location?: StudentSchoolLocationUncheckedUpdateOneWithoutStudentNestedInput
    scholarship?: StudentSchoolScholarshipUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NewsNotificationUncheckedUpdateManyWithoutStudentNestedInput
    ownedNotifications?: NewsNotificationUncheckedUpdateManyWithoutFromStudentNestedInput
    follows?: StudentFollowUncheckedUpdateManyWithoutStudentNestedInput
    followers?: StudentFollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentCode?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: EnumDegreeTypeFieldUpdateOperationsInput | $Enums.DegreeType
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateImg?: StringFieldUpdateOperationsInput | string
    gradeType?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    gradeScore?: FloatFieldUpdateOperationsInput | number
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    additional?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    accountId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventProfileCreateManyEventInput = {
    id?: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventProfileUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutParticipatedEventsNestedInput
  }

  export type EventProfileUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventProfileUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyHostInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventProfileCreateManyProfileInput = {
    id?: string
    eventId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyProfileInput = {
    id?: string
    content?: string | null
    status?: $Enums.PostStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileFriendCreateManyProfileOneInput = {
    id?: string
    isActive?: boolean
    profileIdTwo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileFriendCreateManyProfileTwoInput = {
    id?: string
    isActive?: boolean
    profileIdOne: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupCreateManyOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileGroupCreateManyProfileInput = {
    id?: string
    groupId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBlogCreateManyProfileInput = {
    id?: string
    title: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCommentCreateManyProfileInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    postId: string
    parentCommentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCommentLikeCreateManyProfileInput = {
    id?: string
    postCommentId: string
  }

  export type PostLikeCreateManyProfileInput = {
    id?: string
    postId: string
  }

  export type PostShareCreateManyProfileInput = {
    id?: string
    postId: string
  }

  export type PostSaveCreateManyProfileInput = {
    id?: string
    postId: string
  }

  export type EventUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: EventProfileUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: EventProfileUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventProfileUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type EventProfileUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventProfileUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PostImageUpdateManyWithoutPostNestedInput
    comments?: PostCommentUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
    shares?: PostShareUpdateManyWithoutPostNestedInput
    saves?: PostSaveUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    shares?: PostShareUncheckedUpdateManyWithoutPostNestedInput
    saves?: PostSaveUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileFriendUpdateWithoutProfileOneInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileTwo?: ProfileUpdateOneRequiredWithoutFriendReceivedNestedInput
  }

  export type ProfileFriendUncheckedUpdateWithoutProfileOneInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileIdTwo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileFriendUncheckedUpdateManyWithoutProfileOneInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileIdTwo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileFriendUpdateWithoutProfileTwoInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileOne?: ProfileUpdateOneRequiredWithoutFriendRequestsNestedInput
  }

  export type ProfileFriendUncheckedUpdateWithoutProfileTwoInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileIdOne?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileFriendUncheckedUpdateManyWithoutProfileTwoInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileIdOne?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileGroupUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutProfilesNestedInput
  }

  export type ProfileGroupUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileGroupUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBlogUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProfileBlogImageUpdateManyWithoutProfileBlogNestedInput
  }

  export type ProfileBlogUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProfileBlogImageUncheckedUpdateManyWithoutProfileBlogNestedInput
  }

  export type ProfileBlogUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: PostCommentUpdateOneWithoutChildrenNestedInput
    children?: PostCommentUpdateManyWithoutParentCommentNestedInput
    likes?: PostCommentLikeUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostCommentUncheckedUpdateManyWithoutParentCommentNestedInput
    likes?: PostCommentLikeUncheckedUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentLikeUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postComment?: PostCommentUpdateOneRequiredWithoutLikesNestedInput
  }

  export type PostCommentLikeUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postCommentId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentLikeUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postCommentId?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostShareUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutSharesNestedInput
  }

  export type PostShareUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostShareUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostSaveUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutSavesNestedInput
  }

  export type PostSaveUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostSaveUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileBiographyAreaCreateManyAreaInput = {
    id?: string
    biographyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographyAreaUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biography?: ProfileBiographyUpdateOneRequiredWithoutAreasNestedInput
  }

  export type ProfileBiographyAreaUncheckedUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    biographyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographyAreaUncheckedUpdateManyWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    biographyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographyAreaCreateManyBiographyInput = {
    id?: string
    areaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographySocialCreateManyProfileBiographyInput = {
    id?: string
    type: $Enums.SocialType
    href: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileBiographyAreaUpdateWithoutBiographyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaUpdateOneRequiredWithoutBiographiesNestedInput
  }

  export type ProfileBiographyAreaUncheckedUpdateWithoutBiographyInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographyAreaUncheckedUpdateManyWithoutBiographyInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographySocialUpdateWithoutProfileBiographyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialTypeFieldUpdateOperationsInput | $Enums.SocialType
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographySocialUncheckedUpdateWithoutProfileBiographyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialTypeFieldUpdateOperationsInput | $Enums.SocialType
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBiographySocialUncheckedUpdateManyWithoutProfileBiographyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialTypeFieldUpdateOperationsInput | $Enums.SocialType
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileBlogImageCreateManyProfileBlogInput = {
    id?: string
    url: string
  }

  export type ProfileBlogImageUpdateWithoutProfileBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileBlogImageUncheckedUpdateWithoutProfileBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileBlogImageUncheckedUpdateManyWithoutProfileBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PostImageCreateManyPostInput = {
    id?: string
    url: string
  }

  export type PostCommentCreateManyPostInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    profileId: string
    parentCommentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostLikeCreateManyPostInput = {
    id?: string
    profileId: string
  }

  export type PostShareCreateManyPostInput = {
    id?: string
    profileId: string
  }

  export type PostSaveCreateManyPostInput = {
    id?: string
    profileId: string
  }

  export type PostImageUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PostImageUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PostImageUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostCommentsNestedInput
    parentComment?: PostCommentUpdateOneWithoutChildrenNestedInput
    children?: PostCommentUpdateManyWithoutParentCommentNestedInput
    likes?: PostCommentLikeUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostCommentUncheckedUpdateManyWithoutParentCommentNestedInput
    likes?: PostCommentLikeUncheckedUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostLikeUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type PostShareUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneRequiredWithoutPostSharesNestedInput
  }

  export type PostShareUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type PostShareUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type PostSaveUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneRequiredWithoutPostSavedNestedInput
  }

  export type PostSaveUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type PostSaveUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentCreateManyParentCommentInput = {
    id?: string
    content?: string | null
    image?: string | null
    isArchived?: boolean
    profileId: string
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCommentLikeCreateManyPostCommentInput = {
    id?: string
    profileId: string
  }

  export type PostCommentUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostCommentsNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    children?: PostCommentUpdateManyWithoutParentCommentNestedInput
    likes?: PostCommentLikeUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentUncheckedUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostCommentUncheckedUpdateManyWithoutParentCommentNestedInput
    likes?: PostCommentLikeUncheckedUpdateManyWithoutPostCommentNestedInput
  }

  export type PostCommentUncheckedUpdateManyWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentLikeUpdateWithoutPostCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneRequiredWithoutPostCommentLikesNestedInput
  }

  export type PostCommentLikeUncheckedUpdateWithoutPostCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentLikeUncheckedUpdateManyWithoutPostCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileGroupCreateManyGroupInput = {
    id?: string
    profileId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileGroupUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type ProfileGroupUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileGroupUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsNotificationCreateManyNewsInput = {
    id?: string
    type: $Enums.NewsType
    isRead: boolean
    studentId: string
    fromId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsNotificationUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutNotificationsNestedInput
    fromStudent?: StudentUpdateOneWithoutOwnedNotificationsNestedInput
  }

  export type NewsNotificationUncheckedUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    fromId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsNotificationUncheckedUpdateManyWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNewsTypeFieldUpdateOperationsInput | $Enums.NewsType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    fromId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SchoolCountOutputTypeDefaultArgs instead
     */
    export type SchoolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolScholarshipCountOutputTypeDefaultArgs instead
     */
    export type SchoolScholarshipCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolScholarshipCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolGalleryCountOutputTypeDefaultArgs instead
     */
    export type SchoolGalleryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolGalleryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolLocationCountOutputTypeDefaultArgs instead
     */
    export type SchoolLocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolLocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolProgramCountOutputTypeDefaultArgs instead
     */
    export type SchoolProgramCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolProgramCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatCountOutputTypeDefaultArgs instead
     */
    export type ChatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileCountOutputTypeDefaultArgs instead
     */
    export type ProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaCountOutputTypeDefaultArgs instead
     */
    export type AreaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileBiographyCountOutputTypeDefaultArgs instead
     */
    export type ProfileBiographyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileBiographyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileBlogCountOutputTypeDefaultArgs instead
     */
    export type ProfileBlogCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileBlogCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCommentCountOutputTypeDefaultArgs instead
     */
    export type PostCommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupCountOutputTypeDefaultArgs instead
     */
    export type GroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsCountOutputTypeDefaultArgs instead
     */
    export type NewsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TwoFactorTokenDefaultArgs instead
     */
    export type TwoFactorTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TwoFactorTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TwoFactorConfirmationDefaultArgs instead
     */
    export type TwoFactorConfirmationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TwoFactorConfirmationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolDefaultArgs instead
     */
    export type SchoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolScholarshipDefaultArgs instead
     */
    export type SchoolScholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolScholarshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolScholarshipImageDefaultArgs instead
     */
    export type SchoolScholarshipImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolScholarshipImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSchoolScholarshipDefaultArgs instead
     */
    export type StudentSchoolScholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentSchoolScholarshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolGalleryDefaultArgs instead
     */
    export type SchoolGalleryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolGalleryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolGalleryImageDefaultArgs instead
     */
    export type SchoolGalleryImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolGalleryImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolLocationDefaultArgs instead
     */
    export type SchoolLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolLocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolLocationImageDefaultArgs instead
     */
    export type SchoolLocationImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolLocationImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolLocationContactDefaultArgs instead
     */
    export type SchoolLocationContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolLocationContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolProgramDefaultArgs instead
     */
    export type SchoolProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolProgramImageDefaultArgs instead
     */
    export type SchoolProgramImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolProgramImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSchoolProgramDefaultArgs instead
     */
    export type StudentSchoolProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentSchoolProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSchoolLocationDefaultArgs instead
     */
    export type StudentSchoolLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentSchoolLocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatDefaultArgs instead
     */
    export type ChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventProfileDefaultArgs instead
     */
    export type EventProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileFriendDefaultArgs instead
     */
    export type ProfileFriendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileFriendDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaDefaultArgs instead
     */
    export type AreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileBiographyDefaultArgs instead
     */
    export type ProfileBiographyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileBiographyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileBiographyAreaDefaultArgs instead
     */
    export type ProfileBiographyAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileBiographyAreaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileBiographySocialDefaultArgs instead
     */
    export type ProfileBiographySocialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileBiographySocialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileBlogDefaultArgs instead
     */
    export type ProfileBlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileBlogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileBlogImageDefaultArgs instead
     */
    export type ProfileBlogImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileBlogImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostImageDefaultArgs instead
     */
    export type PostImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostLikeDefaultArgs instead
     */
    export type PostLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostLikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostShareDefaultArgs instead
     */
    export type PostShareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostShareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostSaveDefaultArgs instead
     */
    export type PostSaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostSaveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCommentDefaultArgs instead
     */
    export type PostCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCommentLikeDefaultArgs instead
     */
    export type PostCommentLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCommentLikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupDefaultArgs instead
     */
    export type GroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileGroupDefaultArgs instead
     */
    export type ProfileGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsDefaultArgs instead
     */
    export type NewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsNotificationDefaultArgs instead
     */
    export type NewsNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentFollowDefaultArgs instead
     */
    export type StudentFollowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentFollowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}